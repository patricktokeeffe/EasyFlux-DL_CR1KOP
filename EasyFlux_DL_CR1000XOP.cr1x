' Version 2.01 for CR1000X + CDM-A116/VOLT116 + IRGASON or (CSAT3A and EC150) + slow microclimate sensors, based on EasyFlux_DL for CR3000

' Requirements: EC100   OS version 8.02 or newer
'               CR1000X OS version 6.00 or newer               

' Copyright (c), 2022 Campbell Scientific, Inc. All rights reserved.
' This program is intended for use with Campbell Scientific open-path eddy-covariance systems manufactured 
' after fall 2010 that use an IRGASON or (CSAT3A and EC150) along with microclimate sensors.
' The most common or “best practice” corrections are applied to fluxes in this program. For details on these corrections, 
' consult the manual:
'   Campbell Scientific Inc. 2012. EasyFlux DL CR1000XOP for CR1000X and Open-path Eddy-Covariance Systems. Logan, UT, USA. 
  
' It is the responsibility of the user to determine appropriateness of the corrections used. 
' Campbell Scientific always recommends saving raw time series data in case reprocessing of raw data is warranted.
' Furthermore, it is the responsibility of the user and associated researchers to determine the quality and fitness of any and
' all data, regardless of whether said data were processed by this program or another tool.

' Version numbers less than 1.00 of this program are not fully tested or officially released. Campbell Scientific is not responsible 
' for any errors in data collected using program versions prior to 1.00.
  
'* SITE AND CALIBRATION CONSTANTS
' Search for the text string "Unique" in this program to find the lines below where "Unique" site constants and sensor calibration constants are entered.
  
'*************************************************************************
'*****            USER-DEFINED CONFIGURATION CONSTANTS               *****
'*************************************************************************

'Start of Constants Customization Section
ConstTable (Const_Table)
  
'* PROGRAM FUNCTION CONSTANTS
Const SCN_INTV                 = 100         'Unique: measurement rate (ms): 40 ms (25 Hz), 50 ms (20 Hz), 100 ms (10 Hz), 200 ms (5 Hz), or 1000 ms (1 Hz)
Const SLW_SCN_INTV             = 5000        'Unique: slow sequence measurement rate (ms) >3000 ms and <6000ms (Note: SDI-12 sensors slow for sub-second intervals)
Const OUTPUT_INTV              = 30          'Unique: online flux data output interval (minutes).
Const DAY_FLUX_CRD             = 30          'Unique: number of days of Flux_AmeriFluxFormat, Flux_CSFormat, Flux_Notes table data to store in each file on the MicroSD card. Number of files stored depends on card size.
Const DAY_TSRS_CRD             = 1           'Unique: number of days of Time_Series table data to store in each file on the card. Number of files stored depends on card size.
Const NTCH_FRQ_SLW As Long     = 60          'Unique: slowsequence analog measurement integration time, 60 for 60Hz (e.g. in US, Canada, etc.) or 50 for 50Hz (e.g. in Europe, China, etc.)
Const ONE_FL_TABLE As Boolean  = FALSE       'Unique: whether or not all half-hourly or hourly data in Flux_CSFormat and Flux_Notes are stored in one table (FALSE as default).

'* GAS ANALYZER AND SONIC ANEMOMETER
Const IRGASON       As Boolean = TRUE        'Unique: IRGASON. TRUE as default. If TRUE, CSAT3A_EC150 must be set to FALSE 
Const CSAT3A_EC150  As Boolean = FALSE       'Unique: CSAT3A + EC150. FALSE as default. If TRUE, IRGASON must be set to FALSE.
Const SDM_CLCK_SPD  As Long    = 30          'Unique: default SDM clock speed (uS). May need to increase if using long SDM cables while skipped scans are observed.
Const EC100SDM_ADR As Long     = 1           'Unique: SDM address for EC100 (1 as default).
Const BANDWIDTH                = 20          'Unique: in Hz. For spectral analysis, set to 1/2 sampling freq. Options: 5, 10, 12.5, or 20. For flux only, set 20 Hz if sampling freq is 10 Hz
#If (CSAT3A_EC150) Then 
Const CSAT_TYP_3AH As Boolean  = FALSE       'Unique: CSAT3AH (heated sonic anemometer). If TRUE, IRGASON must be set as FALSE and CSAT3A_EC150 as TRUE.     
#EndIf 

'* GPS
Const SENSOR_GPS   As Boolean  = FALSE       'Unique: GPS16X-HVS GPS receiver with integrated antenna (FALSE as default).
Const UTC_OFST                 = -7          'Unique: The local standard time, in hours, from UTC/GMT. The time in Logan, UT, US is 7 hours behind UTC/GMT.

'* PERIPHERAL
Const CDM_VOLT_116 As Boolean  = FALSE        'Unique: A CDM-A/VOLT116 is being used with the CR1000X (FALSE as default. Required for full suite of energy balance sensors). 
#If (CDM_VOLT_116) Then  
Const SN_CDM_VOLT  As Long     = 0000        'Unique: CDM-A/VOLT116 serial number. 
Const MODEL_CDMVLT             = VOLT116     'Unique: CDM-A/VOLT Model: VOLT116 or CDM_A116.
Const CPI_CDM_VOLT As Long     = 1           'Unique: CPI address for CDM-A/VOLT116.
Const CPI_DEVICE   As String   = "VOLT116"   'Unique: CDM-A/VOLT116 module name or identifier.
#EndIf

'* FINE WIRE THERMOCOUPLE
Const SENSOR_FW    As Boolean  = FALSE       'Unique: FW05, FW1, FW3, or other fine wire thermocouple (FALSE as default).

'* TEMP/RH PROBE
Const SENSOR_HYGRO As Boolean  = FALSE       'Unique: HygroVUE10 temperature and relative humidity sensor (FALSE as default).
Const SENSOR_T_RH As Boolean   = FALSE       'Unique: HMP155A or EE08: temperature and relative humidity probe (FALSE as Default).
#If (SENSOR_HYGRO) Then 
Const HYGROSDI_ADR             = 1           'Unique: HygroVUE10 SDI address (1 as default).
#ElseIf (SENSOR_T_RH) Then 
Const TMPR_MULT    As Float    = 0.14        'Unique: multiplier for temperature: HMP155A = 0.14, or EE08 = 0.04 C mV-1.
Const TMPR_OFST    As Float    = -80.0       'Unique: offset for temperature:     HMP155A = -80,  or EE08 = -40  C.
Const RH_MULT      As Float    = 0.1         'Unique: multiplier for RH:          HMP155A = 0.1,  or EE08 = 0.04 % mV-1.
Const RH_OFST      As Float    = 0.0         'Unique: offset for RH:              HMP155A = 0,    or EE08 = 0    %.
#EndIf 

'* RAIN GAGE
Const SENSOR_TE525  As Boolean = FALSE      'Unique: TE525mm rain gauge. FALSE as default.
#If (SENSOR_TE525) Then  
Const TE525_MULT    As Float   = 0.1        'Unique: multiplier for TE525MM =0.1 mm/tip, TE525 = 0.254 mm/tip, TE525WS = 0.254 mm/tip, TE525WS (w/ 8 in funnel) = 0.1459 mm/tip.   
#EndIf 

'*PYRANOMETER
Const SENSOR_CS301 As Boolean  = FALSE      'Unique: CS301 pyranometer. FALSE as default. If true, SENSOR_NR01, _CNR4, _SN500, and _CS320 must be set to FALSE.
#If (SENSOR_CS301)
Const PYRAN_MULT   As Float    = 5          'Unique: multiplier.
#EndIf

Const SENSOR_CS320 As Boolean  = FALSE      'Unique: CS320: pyranometer. FALSE as default. If true, SENSOR_NR01, _CNR4, _SN500, and _CS301 must be set to FALSE.
#If (SENSOR_CS320) Then  
Const CS320SDI_ADR             = 2          'Unique: SDI address for CS320 (2 as default).
#EndIf
 
'* QUANTUM SENSOR
Const SENSOR_CS310 As Boolean  = FALSE      'Unique: CS310 Quantum Sensor.
#If (SENSOR_CS310) Then 
Const QUNTM_MULT As Float      = 100        'Unique: Multiplier [(umolPhoton m-2 s-1)/mV]. 
#EndIf 

#If (CDM_VOLT_116) Then 
'* IR RADIOMETER
Const SENSOR_SI111 As Boolean  = FALSE      'Unique: SI111 Infrared radiometer. FALSE as default. If true, SENSOR_NR01, and _CNR4 must be set to FALSE.
#If (SENSOR_SI111) Then 
Const m0_SI111     As Float    =  1.41970e9 'Unique: calbration m0, differ for each sensor.
Const m1_SI111     As Float    =  7.84100e6 'Unique: calbration m1, differ for each sensor.
Const m2_SI111     As Float    =  82213     'Unique: calbration m2, differ for each sensor.
Const b0_SI111     As Float    = -1.72150e7 'Unique: calbration b0, differ for each sensor.
Const b1_SI111     As Float    =  1.85020e5 'Unique: calbration b1, differ for each sensor.
Const b2_SI111     As Float    =  13114     'Unique: calbration b2, differ for each sensor.
#EndIf '(SENSOR_SI111)
#EndIf '(CDM_VOLT_116)

'* NR01/CRR4/SN500 4-WAY NET RADIOMETER
Const SENSOR_NR01 As Boolean   = FALSE      'Unique: NR01 4-way net radiometer. FALSE as default. If true, SENSOR_CNR4, _SN500, _CS301, _CS320, and _SI111 must be set to FALSE.
Const SENSOR_CNR4 As Boolean   = FALSE      'Unique: CNR4 4-way net radiometer. FALSE as default. If true, SENSOR_NR01, _SN500, _CS301, _CS320, and _SI111 must be set to FALSE.
Const SENSOR_CNF4 As Boolean   = FALSE      'Unique: CNR4 heating and ventilation unit. A21 REL-12 is additionally required. If TRUE, SENOR_CNR4 must be TRUE. 
#If (SENSOR_NR01 OR SENSOR_CNR4) Then 
Const SW_IN_SNSTVT As Float    = 15.35      'Unique: NR01/CNR4 sensitivity of upward facing pyranometer as reported on sensor calibration sheet [uV/(W m-2)].
Const SWOUT_SNSTVT As Float    = 15.41      'Unique: NR01/CNR4 sensitivity of downward facing pyranometer as reported on sensor calibration sheet [uV/(W m-2)].
Const LW_IN_SNSTVT As Float    = 8.50       'Unique: NR01/CNR4 sensitivity of upward facing pyrgeometer as reported on sensor calibration sheet [uV/(W m-2)].
Const LWOUT_SNSTVT As Float    = 7.09       'Unique: NR01/CNR4 sensitivity of downward facing pyrgeometer as reported on sensor calibration sheet [uV/(W m-2)].
#EndIf

Const SENSOR_SN500 As Boolean  = FALSE       'Unique: SN500SS 4-way net radiometer. FALSE as default. If true, SENSOR_CNR4, _NR01, _CS301, _CS320, and _CS310 must be set to FALSE.
#If (SENSOR_SN500) Then 
Const SN500SDI_ADR             = 3          'Unique: SDI address for SN500 (3 as default). 
#EndIf

'* TCAV SOIL TEMPERATURE PROBE
Const SENSOR_TCAV   As Boolean = FALSE      'Unique: TCAV type E thermocouple averaging soil temperature probes (FALSE as default).
#If (SENSOR_TCAV)   Then
Const NMBR_TCAV     As Long    = 3          'Unique: Number of TCAV (Maximum is 3. 2 as default, NMBR_TCAV = NMBR_CS65x = NMBR_HFP).
#EndIf
 
'* SOIL WATER CONTENT PROBE
Const SENSOR_CS65X  As Boolean = FALSE      'Unique: CS650 or CS655: water content reflectometers for volumetric soil moisture. FALSE as default. If true, SENSOR_TDR must be set to FALSE.
#If (SENSOR_CS65X) Then  
Const NMBR_CS65x    As Long    = 3          'Unique: Number of CS650, or CS655 sensors (Maximum is 3, 2 as default, NMBR_CS65x = NMBR_HFP = NMBR_TCAV).
Const CS65SDI_ADR1             = 4          'Unique: SDI address for CS65X #1 (4 as default).
#If (NMBR_CS65x > 1) Then 
Const CS65SDI_ADR2             = 5          'Unique: SDI address for CS65X #2 (5 as default).
#EndIf
#If (NMBR_CS65x > 2) Then 
Const CS65SDI_ADR3             = 6          'Unique: SDI address for CS65X #3 (6 as default).
#EndIf
#EndIf '(SENSOR_CS65X)

'* SOIL WATER CONTENT PROBE
Const SENSOR_TDR As Boolean = FALSE        'Unique: Acclima TDR series water content reflectometers for volumetric soil moisture. FALSE as default. If true, SENSOR_CS65x must be set to FALSE.
#If (SENSOR_TDR) Then
Const NMBR_CS65x    As Long    = 3         'Unique: Number of TDR series sensors (Maximum is 3, 2 as default, NMBR_TDR = NMBR_HFP = NMBR_TCAV).
Const TDRSDI_ADR1              = 4         'Unique: SDI address for TDR #1 (4 as default).
#If (NMBR_CS65x > 1) Then
Const TDRSDI_ADR2              = 5         'Unique: SDI address for TDR #2 (5 as default).
#EndIf
#If (NMBR_CS65x > 2) Then
Const TDRSDI_ADR3              = 6         'Unique: SDI address for TDR #3 (6 as default).
#EndIf
#EndIf '(SENSOR_TDR)

'* SOIL HEAT FLUX PLATE
Const SENSOR_HFP01 As Boolean = FALSE      'Unique: HFP01 soil heat flux plates. FALSE as default. If TRUE, SENSOR_HFPSC must be set to FALSE
Const SENSOR_HFPSC As Boolean = FALSE      'Unique: HFP01SC self-calibrating soil heat flux plates. FALSE as default. If TRUE, SENSOR_HFP01 must be set to FALSE
#If (SENSOR_HFP01 OR SENSOR_HFPSC) Then  
Const NMBR_HFP     As Long    = 3          'Unique: Number of HFP01 or HFP01SC sensors (Maximum is 3, 2 as default, NMBR_HFP = NMBR_TCAV = NMBR_CS65x).
Const HFP_SNSTVT_1 As Float   = 62.0       'Unique: Sensitivity of HFP01/HFP01SC #1 as reported on sensor product certificate [uV/(W m-2)].
#If (NMBR_HFP > 1) Then 
Const HFP_SNSTVT_2 As Float   = 62.0       'Unique: Sensitivity of HFP01/HFP01SC #2 as reported on sensor product certificate [uV/(W m-2)].
#EndIf 
#If (NMBR_HFP > 2) Then
Const HFP_SNSTVT_3 As Float   = 62.0       'Unique: Sensitivity of HFP01/HFP01SC #3 as reported on sensor product certificate [uV/(W m-2)].
#EndIf

#If (SENSOR_HFPSC) Then  
Const HFP_OHM_1   As Float    = 95         'Unique: Heater resistance of HFP01SC #1 as reported on sensor product certificate (ohms).
#If (NMBR_HFP > 1) Then 
Const HFP_OHM_2  As Float     = 95         'Unique: Heater resistance of HFP01SC #2 as reported on sensor product certificate (ohms).  
#EndIf
#If (NMBR_HFP > 2) Then 
Const HFP_OHM_3  As Float     = 95         'Unique: Heater resistance of HFP01SC #3 as reported on sensor product certificate (ohms).  
#EndIf
Const CAL_INTERVAL            = 1440       'Unique: HFP01SC insitu calibration interval (minutes) (Recommended >360 minutes. Only applicable to HFP01SC plates).
#EndIf '(SENSOR_HFPSC)
#EndIf '(SENSOR_HFP01 OR SENSOR_HFPSC)

EndConstTable
'End of Constants Customization Section

'* Composite Boolean variables for variables above
Const SENSOR_Rn            = (SENSOR_CNR4 OR SENSOR_NR01 OR SENSOR_SN500)
Const SENSOR_SWC           = (SENSOR_CS65X OR SENSOR_TDR)
Const SENSOR_HFP           = (SENSOR_HFP01 OR SENSOR_HFPSC)
Const SCAN_INTERVAL_WEIGHT = SLW_SCN_INTV/(60*1000*OUTPUT_INTV)           'Used to calculate the fraction of day time in an scan interval  
'************* END OF USER-DEFINED CONFIGURATION CONSTANTS ***************

  
'*************************************************************************
'*****            DEFAULT SETTING FOR CR1000X AND PROGRAM            *****
'************************************************************************* 
PipeLineMode
AngleDegrees         'Angle degree used throughout the program
PreserveVariables    'PreserveVariable if CR1000X restarts
SDMBeginPort(C5)     'Starting port for SDM (valid starting ports: C1 or C5). 

'************** END of DEFAULT SETTING FOR CR1000X AND PROGRAM ***********


'*************************************************************************
'*****                    NOTES AND EXPLANATIONS                     *****
'*************************************************************************
'*** SIGN CONVENTION
' Positive fluxes are away from the ground surface, and negative towards the ground surface.

'*** LAGS
' Instrument scan lag: Before computing online fluxes and writing to the time series data table, an instrument scan lag for each variable is introduced
' to account for the fixed instrument delays so that any pair of variables for covariance are aligned at the time resolution of the scan rate. Scan lags
' depend on instrument settings and/or the datalogger scan interval. In the case of the IRGASON or EC150 with CSAT3A, the instrument delay is determined
' by the bandwidth setting in the EC100 electronics (see appendix A of IRGASON manual, Revision 08/2021). For analog measurements such as FW sensors,
' the measurements are assumed to have no scan delay. After instrument scan lags are applied, the data are recorded in the time series output table. 
' After instrument lag, any two variables from the flow to all sensors at the same time in the same record are paired as measured at the same time.  

' Sensing time lag: After the instrument scan lag is applied, an additional lag called the sensing time lag may be applied if there is a spatial separation
' between the scalar sensor (e.g. FW or IRGA) and CSAT. The sensing lag is positive if wind passed the CSAT first followed by the scalar sensor; otherwise,
' the sensing lag is negative. The size of sensing time lag depends on wind speed and sensor separation. An algorithm in the program selects a lag that maximizes
' covariances and is physically possible. The final outputs in the flux output table have sensing time lags applied.
' ****************** END OF NOTES AND EXPLANATIONS ***********************


'*************************************************************************
'*****          ABBREVIATIONS IN COMMENTS AND VARIABLES              *****
'*************************************************************************
'AG     analog ground
'amb    ambient 
'CSAT   CSAT3A/CSAT3AH or IRGASON sonic anemometer 
'CS65X  CS650 or CS655
'cumul  cumulative
'deg    degree
'dia    diameter
'diag   diagnostic
'dir    direction
'dist   distance
'f      flag (information or program control, dim variable)
'flg    flag (user interactive flag, public variable)
'FP     footprint
'Freq   frequency
'frac   fraction
'FTPRNT footprint
'FW     FW05, FW1, or FW3 (FW is an abbreviation for fine wire thermocouple)
'G      ground (i.e., power ground)
'HFP    HFP01 or HFP01SC soil heat flux plate sensor
'intrst interest
'IRGA   EC150 or IRGASON InfraRed CO2/H2O Analyzer
'nmbr   number
'pct    percent
'press  pressure
'Pyran  pyranometer
'RH     relative humidity
'rng    range
'QC     quality control or quality classification
'shf    soil heat flux
'sig    signal
'strgth strength
'win    within
'wnd    wind
'wtr    water
'***********  END OF ABBREVIATIONS IN COMMENTS AND VARIABLES  ************


'*************************************************************************
'*****                     UNIT DEFINITIONS                          *****
'*************************************************************************
'SYMBOL      UNIT
'C           Celsius
'degrees     angle degrees
'frac_v_wtr  Fraction volumetric water content
'g           grams
'J           Joules
'Hz          Hertz
'kg          kilograms
'kPa         kilopascals
'm           meters
'mg          milligrams
'mmol        millimoles
'mol         moles
'ms          milliseconds
's           seconds
'umol        micromoles
'usec        microseconds
'V           volts
'W           Watts
'**********************  END OF UNIT DEFINITIONS *************************


'*************************************************************************
'*****   BEGINNING CONSTANTS AND VARIABLES FOR ATMOSPHERIC PHYSICS   *****
'*****    [Unless noted, see page 467 in Wallace AND Hobbs (2006)]   *****
'*************************************************************************
Const Cpd     = 1004.0             'specific heat of dry air at constant pressure [J/(kg K)]
Const Cpw     = 1952.0             'specific heat of water vapor at constant pressure [J/(kg K)]
Const Cw      = 4218.0             'specific heat of liquid water at 0 C [J/(kg K)]
Const epsilon = 18.016/28.97       'molecular mass ratio of water vapor to dry air
Const g0      = 9.81               'acceleration due to gravity at sea level (m/s^2)
Const k       = 0.41               'von Karman constant (Dyer & Hicker 1970, Webb 1970)
Const MU_WPL  = 28.97/18.016       'molecular mass ratio of dry air to water vapor (used in WPL correction)
Const Omega   = 7.292e-5           'Angular velocity of the earth for calculation of Coriolis Force (2PI/sidreal_day, where sidereal day = 23 hr 56 min. [rad/s]
Const R       = 8.3143e-3          'Universal gas constant [kPa m^3/(K mol)]
Const Rd      = R/28.97            'Gas constant for dry air [kPa m^3/(K g)]
Const Rv      = R/18.016           'Gas constant for water vapor [kPa m^3/(K g)]
Const PI      = 3.1415926          'Pi (just use the seven digits after decimal, commonly used) 
Const Sigma_SB= 5.6718e-8          'Stefan-Boltzmann constant in air [J/(K^4 m^2 s), see page 336 in McGee (1988)] 
Const T_0C_K  = 273.15             'Temperature in K at 0 degree C

Dim Cp                             'specific heat of moist air at constant pressure, calculated using measurements from EC100 data [J/(kg deg C)]
Units  Cp = J kg-1 deg C-1

Dim Lv                             'Latent heat of vaporization, calculated using air temperature [J/g].
Units  Lv = J g-1
'******** END OF CONSTANTS AND VARIABLES FOR ATMOSPHERIC PHYSICS *********


'*************************************************************************  
'*****                   WIRING INSTRUCTIONS                         *****
'*************************************************************************

'*** Beginning of power supply wiring 
'CR1000X 12V Power In     Positive of 12Vdc battery or external power supply 
'CR1000X G Power In       Negative of 12Vdc battery or external power supply 
  
'*** Beginning of EC100 wiring 
' Positive of power supply EC100 12V
' Negative of power supply EC100 G  
    
'CR1000X C5                EC100 SDM C1
'CR1000X C6                EC100 SDM C2                   
'CR1000X C7                EC100 SDM C3                   
'CR1000X G                 EC100 SDM G                    

#If (CSAT3A_EC150) Then 
#If (CSAT_TYP_3AH) Then
'*** Beginning of CSAT3AH heating controller wiring  
'* CSAT3AH to heating controller
'Heater cable               Heater port of heating controller
'Chassis Temp cable         Chassis port of heating controller 

'* Temp/RH probe to heating controller
'Temp/RH probe cable        Temp/RH port of heating controller

'* Controller to CR1000X for RS485 communication
'Controller RS 485 A- (brown)          CR1000X CS I/O with MD485
'Controller RS 485 B+ (white)          CR1000X CS I/O with MD485
'Controller signal Ground (black)      CR1000X CS I/O with MD485

'* Heating controller to power source 
'Power In (red)             power source DC 24V + positive              
'power in (black)           power source DC 24V - negative  
#EndIf '(CSAT_TYP_3AH)  
#EndIf '(CSAT3A_EC150) 

#If (SENSOR_GPS) Then
Const GPS16X_PORT           = C1          'Pulse input channel
Const GPS16X_COM_PORT       = COMC1       'Pulse input channel
Const TIME_DIFF_RST_CR1000X = 1.0         'The maximum difference in ms between the CR1000X and GPS clocks before CR1000X clock is reset.
'*** Beginning of GPS16X wiring
'CR1000X C1     PPS (grey) 
'CR1000X C2     TXD (white)
'CR1000X G      Power switch to keep on (yellow) 
'CR1000X G      Rx data, datalogger-based configuration (blue) 
'CR1000X AG     Shield (clear)
  
'CR1000X 12V    Power positive (red) 
'CR1000X G      Power negative (black)
#EndIf '(SENSOR_GPS) 

#If (SENSOR_CS65X) Then
Const CS65X_SDI_PORT = C3       'SDI port.
'*** Beginning of CS65X wiring 
'CR1000X C3      SDI-12 data #1 (green)
'CR1000X 12V     SDI-12 power #1 (red)
'CR1000X G       SDI-12 data/power reference #1 (black)
'CR1000X G       Orange wire #1 (orange) is not used
'CR1000X AG      Shield #1 (clear)
 #If (NMBR_CS65x > 1) Then 
'CR1000X C3      SDI-12 data #2 (green)
'CR1000X 12V     SDI-12 power #2 (red)
'CR1000X G       SDI-12 data/power reference #2 (black)
'CR1000X G       Orange wire #2 (orange) is not used   
'CR1000X AG      Shield #2 (clear)
 #EndIf 
 #If (NMBR_CS65x > 2) Then 
'CR1000X C3      SDI-12 data #3 (green)
'CR1000X 12V     SDI-12 power #3 (red)
'CR1000X G       SDI-12 data/power reference #3 (black)
'CR1000X G       Orange wire #3 (orange) is not used   
'CR1000X AG      Shield #3 (clear)
 #EndIf 
#EndIf '(SENSOR_CS65X)

#If (SENSOR_TDR) Then
Const TDR_SDI_PORT = C3       'SDI port.
'*** Beginning of TDR wiring 
'CR1000X C3      SDI-12 data #1 (blue)
'CR1000X 12V     SDI-12 power #1 (red)
'CR1000X G       SDI-12 data/power reference #1 (white)
 #If (NMBR_CS65x > 1) Then 
'CR1000X C3      SDI-12 data #2 (blue)
'CR1000X 12V     SDI-12 power #2 (red)
'CR1000X G       SDI-12 data/power reference #2 (white)
 #EndIf 
 #If (NMBR_CS65x > 2) Then 
'CR1000X C3      SDI-12 data #3 (blue)
'CR1000X 12V     SDI-12 power #3 (red)
'CR1000X G       SDI-12 data/power reference #3 (white)
 #EndIf 
#EndIf '(SENSOR_TDR)

#If (SENSOR_CNF4) Then 
Const CNF4_TACHMTR_INPUT = P1 
'*** Beginning of CNF4 wiring 
'CR1000X P1     CNF4 tachometer signal (green)
'CR1000X AG     CNF4 tachometer reference (grey)
#EndIf

#If (SENSOR_TE525) Then
Const TE525_PULSE_INPUT = P2                  'Pulse input channel rain gauge.
'*** Beginning of TE525mm wiring
'CR1000X P2    Precipitation signal (black)
'CR1000X AG    Signal reference (white)
'CR1000X AG    Shield (clear)
#EndIf
  
#If (SENSOR_T_RH) Then
Const TMPR_RH_ANALOG_INPUT = 7        
'*** Beginning of HMP and EE08 wiring ***
#If (SENSOR_CS310) Then 
'CR1000X SE7             Temperature signal (brown/yellow)
'CR1000X SE8             Relative humidity signal (white/blue)
'CR1000X G               Signal reference (yellow/white)
#Else 
'CR1000X SE7             Temperature signal (brown/yellow)
'CR1000X SE8             Signal reference (yellow/white)
Const TMPR_RH_CDMVOLT_INPUT = 8
'CDM-A/VOLT116 8H        Relative humidity signal (white/blue)
'CDM-A/VOLT116 8L        Signal reference (yellow/white)
'CR1000X AG              Shield (clear/clear)
#EndIf '(SENSOR_CS310) 

'CR1000X AG   Shield (clear/clear)
'12V          Power (green/red)
'G            Power reference (grey/black)

#ElseIf (SENSOR_HYGRO) Then 
Const HYGRO_SDI_PORT = C3
 '*** Beginning of HygroVUE10 wiring ***
'CR1000X C3   SDI-12 temperature and RH signals (white)
'CR1000X AG   Shield (clear)
'12V          Power (brown)
'G            Power reference (grey/black)

#EndIf '(SENSOR_T_RH)

#If (SENSOR_CS320) Then                      'CS320 is not allowed to use if CNR4, NR01, SN500, or CS301 is used already
  Const CS320_SDI_PORT = C3                  'SDI port.
  '*** Beginning of Pyranometer wiring
  'CR1000X C3    Pyranometer signal (white)
  'CR1000X AG    Pyranometer signal reference (blue)
  'CR1000X AG    Shield (clear)
  'CR1000X 12V   Pyranometer power positive (red)
  'CR1000X G     Pyranometer power Negative (black)
#EndIf


#If (CDM_VOLT_116) Then  
'*** Beginning of CDM-A/VOLT116 wiring to CR1000X  
' CR1000X CPI port                             CDM-A/VOLT116 CPI PORT (Use Cat5 or Cat6 Ethernet cable)
' Positive of power supply or CR1000X 12V      CDM-A/VOLT116 12V                      
' Negative of power supply or CR1000X G        CDM-A/VOLT116 G                        
#EndIf

#If (SENSOR_TCAV) Then
Const TCAV_ANALOG_INPUT = 1                  'Staring differential analog input channel in CDM-A/VOLT116 for TCAV.

'*** Beginning of TCAV wiring
#If (NMBR_TCAV <= 2) Then 
' CDM-A/VOLT116 2H     Signal #1 (purple)
' CDM-A/VOLT116 2L     Signal reference #1 (red)
' CDM-A/VOLT116 AG     Shield #1 (clear)
#If (NMBR_TCAV = 2) Then 
' CDM-A/VOLT116 3H     Signal #2 (purple)
' CDM-A/VOLT116 3L     Signal reference #2 (red)
' CDM-A/VOLT116 AG     Shield #2 (clear)
#EndIf 
#EndIf ' (NMBR_TCAV <= 2)

#If (NMBR_TCAV = 3) Then 
' CDM-A/VOLT116 1H     Signal #1 (purple)
' CDM-A/VOLT116 1L     Signal reference #1 (red)
' CDM-A/VOLT116 AG     Shield #1 (clear)
  
' CDM-A/VOLT116 2H     Signal #2 (purple)
' CDM-A/VOLT116 2L     Signal reference #2 (red)
' CDM-A/VOLT116 AG     Shield #2 (clear)

' CDM-A/VOLT116 3H     Signal #3 (purple)
' CDM-A/VOLT116 3L     Signal reference #3 (red)
' CDM-A/VOLT116 AG     Shield #3 (clear)
#EndIf '(NMBR_TCAV = 3)
#EndIf '(SENSOR_TCAV)
  
#If (SENSOR_HFP) Then
'Soil heat flux plates
Const SHF_ANALOG_INPUT = 5                     'Starting differential analog input channel in CDM-A/VOLT116.

'*** Beginning of HFP01/HFP01SC wiring ***
' CDM-A/VOLT116 5H     Signal #1 (white)
' CDM-A/VOLT116 5L     Signal reference #1 (green)
' CDM-A/VOLT116 AG     Shield #1 (clear)
#If (NMBR_HFP >1) Then 
' CDM-A/VOLT116 6H     Signal #2 (white)
' CDM-A/VOLT116 6L     Signal reference #2 (green)
' CDM-A/VOLT116 AG     Shield #2 (clear)
#EndIf 
#If (NMBR_HFP >2) Then 
' CDM-A/VOLT116 7H     Signal #3 (white)
' CDM-A/VOLT116 7L     Signal reference #3 (green)
' CDM-A/VOLT116 AG     Shield #3 (clear)
#EndIf  
  
#If (SENSOR_HFPSC) Then
Const SHF_HEATER_ANALOG_INPUT = 13               'Starting differential analog input channel in CDM-A/VOLT116 to measure the heater of HFP01SC #1.

'*** Beginning of HFP01SC heater wiring ***
' CDM-A/VOLT116 13H    Heater resistor signal #1 (yellow)
' CDM-A/VOLT116 13L    Heater resistor signal reference #1 (purple)
' CDM-A/VOLT116 SW12-1 Heater power positive #1 (red)
' CDM-A/VOLT116 G      Heater power negative #1 (black)
' CDM-A/VOLT116 AG     Heater shield #1 (clear)
#If (NMBR_HFP > 1) Then 
' CDM-A/VOLT116 14H    Heater resistor signal #2 (yellow)
' CDM-A/VOLT116 14L    Heater resistor signal reference #2 (purple)
' CDM-A/VOLT116 SW12-1 Heater power positive #2 (red)
' CDM-A/VOLT116 G      Heater power negative #2 (black)
' CDM-A/VOLT116 AG     Heater shield #2 (clear)
#EndIf
#If (NMBR_HFP > 2) Then 
' CDM-A/VOLT116 16H    Heater resistor signal #3 (yellow)
' CDM-A/VOLT116 16L    Heater resistor signal reference #3 (purple)
' CDM-A/VOLT116 SW12-2 Heater power positive #3 (red)
' CDM-A/VOLT116 G      Heater power negative #3 (black)
' CDM-A/VOLT116 AG     Heater shield #3 (clear)
#EndIf 
#EndIf '(SENSOR_HFPSC)
#EndIf '(SENSOR_HFP)

#If (SENSOR_FW) Then
Const FW_ANALOG_INPUT = 15                    'Differential analog input channel in CDM-A/VOLT116 for FW (Input channels 2, 3, 6, 7, 10, 11, 14, or 15 are recommended)
'*** Beginning of FW wiring
' CDM-A/VOLT116 15H     FW signal (purple)
' CDM-A/VOLT116 15L     FW signal reference (red)
' CDM-A/VOLT116 AG      FW shield (clear)
#EndIf  

#If (SENSOR_NR01 OR SENSOR_CNR4) Then
Const NR_ANALOG_INPUT   = 9                    '1st differential analog input channel CDM-A/VOLT116 for a 4-way net radiation sensor.
Const T_NR_ANALOG_INPUT = 4                    'Differential analog input channel in CDM-A/VOLT116 to measure body temperature of 4-way radiation sensor. 
Const SW_IN_CAL  = 1000/SW_IN_SNSTVT           'Multiplier for NR01/CNR4 shortwave downwelling (incoming) radiation [w/(m^2 mV)].
Const SW_OUT_CAL = 1000/SWOUT_SNSTVT           'Multiplier for NR01/CNR4 shortwave upwelling (outgoing) radiation [w/(m^2 mV)].
Const LW_IN_CAL  = 1000/LW_IN_SNSTVT           'Multiplier for NR01/CNR4 longwave downwelling (incoming) radiation [w/(m^2 mV)].
Const LW_OUT_CAL = 1000/LWOUT_SNSTVT           'Multiplier for NR01/CNR4 longwave upwelling (outgoing) radiation [w/(m^2 mV)].
#EndIf

#If (SENSOR_NR01) Then
Const T_NR_CURRENT_EXCITATION = X1             'Current excitation channel in CDM-A/VOLT116.

'*** Beginning of NR01 wiring
'Cable 1 (solar cable)
' CDM-A/VOLT116 9H     Downwelling (incoming) shortwave radiation signal (red)
' CDM-A/VOLT116 9L     Downwelling (incoming) shortwave radiation signal reference (blue)
' CDM-A/VOLT116 AG     Shield (clear)
' CDM-A/VOLT116 10H    Upwelling (outgoing) shortwave radiation signal (white)
' CDM-A/VOLT116 10L    Upwelling (outgoing) shortwave radiation signal reference (green/black). Jump to 9L 
' CDM-A/VOLT116 11H    Downwelling (incoming) longwave radiation signal (brown/grey or orange)
' CDM-A/VOLT116 11L    Downwelling (incoming) longwave radiation signal reference (yellow). Jump to 10L.
' CDM-A/VOLT116 12H    Upwelling (outgoing) longwave radiation signal (purple or pink/brown)
' CDM-A/VOLT116 12L    Upwelling (outgoing) longwave radiation signal reference (grey/green). Jump to 11L.

' Cable 2 (Temp cable)
' CDM-A/VOLT116 4H     Pt100 signal (white)
' CDM-A/VOLT116 4L     Pt100 signal reference (green)
' CDM-A.VOLT116 AG     Pt100 shield (silver/bare)
' CDM-A/VOLT116 X1     Current excitation (red)
' CDM-A/VOLT116 AG     Current excitation reference (blue)

#If (NOT SENSOR_HFPSC) Then 
' CDM-A/VOLT116 SW12-1  Heater power (brown)
' CDM-A/VOLT116 G       Heater Ground (yellow)
#Else 
' CR1000X SW12-1        Heater power (brown)
' CR1000X G             Heater Ground (yellow)
#EndIf  

' CDM-A/VOLT116 G       Ground (purple/pink) 
' CDM-A/VOLT116 AG      Shield (Grey) 
#EndIf '(SENSOR_NR01) 

#If (SENSOR_CNR4) Then
Const T_NR_VOLTAGE_EXCITATION = X1               'Voltage excitation channel in CDM-A/VOLT116.
'*** Beginning of CNR4 wiring
'Solar cable 
' CDM-A/VOLT116 9H     Downwelling (incoming) shortwave radiation signal (red)
' CDM-A/VOLT116 9L     Downwelling (incoming) shortwave radiation signal reference (blue)
' CDM-A/VOLT116 AG     Shield (clear)
'                      
' CDM-A/VOLT116 10H    Upwelling (outgoing) shortwave radiation signal (white)
' CDM-A/VOLT116 10L    Upwelling (outgoing) shortwave radiation signal reference (black). Jumper wire to 9L

' CDM-A/VOLT116 11H    Downwelling (incoming) longwave radiation signal (grey)
' CDM-A/VOLT116 11L    Downwelling (incoming) longwave radiation signal reference (yellow).Jumper wire to 10L

' CDM-A/VOLT116 12H    Upwelling (outgoing) longwave radiation signal (brown)
' CDM-A/VOLT116 12L    Upwelling (outgoing) longwave radiation signal reference (green). Jumper wire to 11L

'Temp cable
' CDM-A/VOLT116 4H     Thermistor signal (white)
' CDM-A/VOLT116 AG     Thermistor signal reference (black)
' CDM-A/VOLT116 AG     Shield (clear)
' CDM-A/VOLT116 X1     Thermistor voltage excitation (red)

#If (SENSOR_CNF4) Then
Const CNF4_FAN_SW5_PORT = 1
Const CNF4_HEATER1_SW5_PORT = 2
Const CNF4_HEATER2_SW5_PORT = 3

'*** Beginning of CNF4 wiring to A21REL-12 and CR1000X 
' A21REL-12 and CNF4 cable
' Ordered as shown in A21REL-12 

' A21REL-12 +12V               Positive in an external 12V power source (Neither CR1000X 12V nor CDM-A/VOLT 12V)
' A21REL-12 G (near +12V)      Negative in an external 12V power source (Neither CR1000X 12V nor CDM-A/VOLT 12V  

' A21REL-12 G (near REL 1 COM) CNF4 ventilator, Heater 1, and heater 2 negative (brown, red, and blue)
'                              CDM-A/VOLT116 G 

' A21REL-12 REL  1 COM         Jump to A21REL-12 +12V 
' A21REL-12 REL  1 NO          CNF4 ventilator positive, 0.4A at 12V (yellow)
' A21REL-12 CTRL 1             CDM-A/VOLT116 SW5V 1 (user-defined color)

' A21REL-12 REL  2 COM         Jump to A21REL-12 1 COM 
' A21REL-12 REL  2 NO          CNF4 heater 1 positive, 0.536A at 12V (White)
' A21REL-12 CTRL 2             CDM-A/VOLT116 SW5V 2 (user-defined color) 

' A21REL-12 REL  3 COM         Jump to A21REL-12 2 COM 
' A21REL-12 REL  3 NO          CNF4 heater 2 positive, 0.642A at 12V (Black)
' A21REL-12 CTRL 3             CDM-A/VOLT116 SW5V 3 (user-defined color) 

' CR1000X P1                   CNF4 tachometer signal (green)
' CR1000X AG                   CNF4 tachometer reference (grey)
 #EndIf '(SENSOR_CNF4)                                             
#EndIf '(SENSOR_CNR4) 

#If (SENSOR_SN500) Then
Const SN500_SDI_PORT = C3   'SDI input port.
'*** Beginning of SN500 wiring
'C3      SDI-12 data (white if SN1086 or later and black if SN1085 or earlier)
'12V     SDI-12 power (Red, external 12V power is recommended because SN500 has a heater))
'G       SDI-12 Ground (black if SN1086 or later and clear if SN1085 or earlier)
'        Shield #1 (clear if SN1086 or later and N/A if SN1085 or earlier))
#EndIf  

#If (CDM_VOLT_116) Then 
  
#If (SENSOR_CS310) Then
Const QUANTUM_ANALOG_INPUT  = 8         'Differential analog input channel in CDM-A/VOLT116 for quantum PAR sensor
'*** Beginning of Quantum wiring
' CDM-A/VOLT116 8H    Quantum signal (white)
' CDM-A/VOLT116 8L    Quantum signal reference (black)
' CDM-A/VOLT116 AG    Shield (clear)
#EndIf 
  
#If (SENSOR_CS301) Then
Const PYRAN_ANALOG_INPUT  = 10          'Differential analog input channel in CDM-A/VOLT116 for CS301 Pyranometer.
'*** Beginning of Pyranometer wiring
'CDM-A/VOLT116 10H    Pyranometer signal (white)
'CDM-A/VOLT116 10L    Pyranometer signal reference (black)
'CDM-A/VOLT116 AG     Shield (clear)
#EndIf
 
#If (SENSOR_SI111) Then
Const SI111_ANALOG_INPUT   = 11    'Differential analog input channel in CDM_A/VOLT116 for SI-111 sensor
Const SI111_EXCITATION     = X3    'Voltage excitation channel for SI-111 sensor
'*** Beginning of SI-111 precision infrared radiometer wiring
' CDM-A/VOLT116 11H    SI111 target signal (red)
' CDM-A/VOLT116 11L    SI111 target signal reference (black)
' CDM-A/VOLT116 AG     SI111 shield (clear)
' CDM-A/VOLT116 12H    SI111 body temperature signal (green)
' CDM-A/VOLT116 AG     SI111 body temperature signal reference (blue)
' CDM-A/VOLT116 X3     SI111 voltage excitation (white)
#EndIf

#EndIf  '(CDM_VOLT_116)

'********************* END OF WIRING INSTRUCTIONS ************************ 
Public message As String * 60                                       'Message string for system status and change 

'*************************************************************************
'*****         BEGINNING OF MEASUREMENT CONSTANTS                    *****
'*************************************************************************
Const NMBR_DAY_CPU     = 7                                          'Number of days of flux data to store on the CPU.
Const FLUX_SIZE_CPU    = Ceiling ((NMBR_DAY_CPU*1440)/OUTPUT_INTV)  'Number of records in a half- or one-hour data file for NMBR_DAY_CPU [(days*1440 minutes/day)/(minutes/record)] = records].
Const OFFSET           = 46                                         'An offset delay for lagging irga and FW data against CSAT data (Max needed: (4000/5-Hz bandwidth)/50-Hz scan interval + 1 + MAM_LAG = 46.
Const SCAN_BUFFER_SIZE = 30*INT (1000/SCN_INTV)                     'Compute a 5-second scan buffer. 
Const FIRST_NOTCH_FREQ_MAIN_SCAN = 3750                             'Measurement integration frequency. The frequency of 3750 Hz allows CDM-A/VOLT series to perform a 0.2667 ms integration for 20Hz main scan rate.
'************** END OF MEASUREMENT CONSTANTS *****************************


'*************************************************************************
'*****          BEGINNING OF VARIABLES FOR MicroSD                  ******
'*************************************************************************
'***Variables used to estimate the number of days for MicroSD to be continuously used
Dim card_bytes_free                                                 'Free bytes of MicroSD in bytes
Dim card_bytes_free_assgnd                                          'Free bytes of MicroSD that were assigned for more DataTable
Dim card_bytes_free_unassgnd                                        'Free bytes of MicroSD were not asigned for more DataTables
Dim day_snc_0101_1990                                               'Days since Jan 01, 1990. 

'Time_Series Table whose size is pre-allocated.
Dim bytes_rcd_Time_Series                                           'Bytes used in MicroSD for each record of Time_Series table  
Dim bytes_tbl_Time_Series                                           'Bytes used in MicroSD for one Time_Series table whose size in days is defined by a user  
Dim days_actv_tbl_Time_Series                                       'Days of free bytes inside active Time_Series table 
Dim days_more_tbl_Time_Series                                       'Days of free bytes for more Time_Series table  
Dim days_totl_tbl_Time_Series                                       'Total days of free bytes possibly used Time_Series table 

Dim LastFileName_Time_Series      As String *36 = NaN               'Used to monitor the completion of Time_Series datatable                       
Dim LastFileName_Time_Series_prev As String *36 = NaN   

'Flux Table in AmeriFlux format (not pre-allocated)
Dim bytes_rcd_AmeriFluxFormat                                       'Bytes used in MicroSD for each record of flux table in AmeriFluxFormat   
Dim bytes_tbl_AmeriFluxFormat                                       'Bytes used in MicroSD for one AmeriFluxFormat table  

'Flux table in CS format whose size is pre-allocated. 
Dim bytes_rcd_flux_CSFormat                                         'Bytes used in MicroSD for each record of flux table in CSFormat  
Dim bytes_tbl_flux_CSFormat                                         'Bytes used in MicroSD for one Flux_CSFormat table whose size in days is defined by a user  
#If (ONE_FL_TABLE) Then
Dim days_actv_tbl_flux_CSFormat                                     'Days of free bytes inside active Flux_CSFormat table 
Dim days_more_tbl_flux_CSFormat                                     'Days of free bytes for more Flux_CSFormat table
Dim days_totl_tbl_flux_CSFormat                                     'Total days of free bytes possibly used for Flux_CSFormat table
#Else
'Flux notes table whose size is pre-allocated.   
Dim bytes_rcd_flux_notes                                            'Bytes used in MicroSD for each record of Flux_CSFormat table  
Dim bytes_tbl_flux_notes                                            'Bytes used in MicroSD for one Flux_CSFormat table whose size in days is defined by a user  
Dim days_actv_tbl_flux_CSFormat_notes                               'Days of free bytes inside active Flux_CSFormat and Flux_notes tables 
Dim days_more_tbl_flux_CSFormat_notes                               'Days of free bytes for more Flux_CSFormat and Flux_notes tables 
Dim days_totl_tbl_flux_CSFormat_notes                               'Total days of free bytes possibly used for Flux_CSFormat and Flux_notes tables 
#EndIf 
Dim LastFileName_flux_CSFormat       As String *36                  'Used to monitor the completion of Flux_in CSFormat table                       
Dim LastFileName_flux_CSFormat_prev  As String *36   

Public card_storage_available_days                                  'The number of extra days for MicroSD to store more data. This variable will be referenced by EasyFlux_web
Units  card_storage_available_days = days
'****************** END OF VARIABLES FOR MicroSD *************************


'*************************************************************************
'*****         BEGINNING OF STATION: VARIABLES AND CONSTANTS        ******
'*************************************************************************
'Variables for constructing time stamp in AmeriFlux format
Dim CR1000X_clock As String *22
Dim   TimeStamp_AmeriFluxFormat(2) As String *12
Alias TimeStamp_AmeriFluxFormat(1) = TIMESTAMP_START
Alias TimeStamp_AmeriFluxFormat(2) = TIMESTAMP_END  

Dim stn_conf_array_file      As Long             'Filehandle for the configuration data stored in the CPU.
Dim stn_conf_array_file_size As Long             'Size of the station configuration file stored on the CPU.

Const NMBR_STN_VAR       = (17 - 1*SENSOR_GPS - 3*SENSOR_FW - 3*((SENSOR_HFP) AND (SENSOR_SWC)))       'Number of station variables below
Public stn_conf_array(NMBR_STN_VAR)              'These station parameters are entered using the datalogger keypad while program is running after compiled.
Alias stn_conf_array(1)  = sonic_azimuth         'Azimuth angle of compass direction to which CSAT points (degrees) (see Section 3.1.1 CSAT3A Azimuth in the OPEC manual).
Alias stn_conf_array(2)  = latitude              'Latitude (degrees)
Alias stn_conf_array(3)  = hemisphere_NS         '"1" for north and "-1" for south, following GPS convention
Alias stn_conf_array(4)  = longitude             'Longitude (degrees)
Alias stn_conf_array(5)  = hemisphere_EW         '"1" for east and "-1" for west, following GPS convention
Alias stn_conf_array(6)  = altitude              'Altitude (m)
Alias stn_conf_array(7)  = height_measurement    'Measurement height (m)
Alias stn_conf_array(8)  = surface_type          'crop = 1, grass = 2, forest = 3, shrub = 4, bare land = 5, and water = 6
Alias stn_conf_array(9)  = height_canopy         'canopy height (m).
Alias stn_conf_array(10) = displacement_user     'User-entered displacement height (m) [If 0 (default), then auto calculate]
Alias stn_conf_array(11) = roughness_user        'User-entered roughness length (m) [If 0 (default), then auto calculate and continuously updated by recalculation when neutral stratification]
Alias stn_conf_array(12) = separation_x_irga     'x coordinate of IRGA optical path center along the CSAT x-coordinate axis (m)
Alias stn_conf_array(13) = separation_y_irga     'y coordinate of IRGA optical path center along the CSAT y-coordinate axis (m)
Alias stn_conf_array(14) = dist_intrst_60_300    'Distance of interest for wind directions 0~<=60 and >300~360 degrees in CSAT coordinate system (m)
Alias stn_conf_array(15) = dist_intrst_60_170    'Distance of interest for wind directions >60 and <=170 degrees in CSAT coordinate system (m)
Alias stn_conf_array(16) = dist_intrst_170_190   'Distance of interest for wind directions >170 and <=190 degrees in CSAT coordinate system (m)
Alias stn_conf_array(17) = dist_intrst_190_300   'Distance of interest for wind directions >190 and <=300 degree in CSAT coordinate system (m)

Units sonic_azimuth       = Decimal degrees
Units latitude            = Decimal degrees
Units hemisphere_NS       = adimensional         '"adimensional" indicates no units (i.e., dimensionless)
Units longitude           = Decimal degrees
Units hemisphere_EW       = adimensional         '"adimensional" indicates no units (i.e., dimensionless)
Units altitude            = m
Units height_measurement  = m
Units surface_type        = adimensional         '"adimensional" indicates no unit (i.e., dimensionless)
Units height_canopy       = m
Units displacement_user   = m
Units roughness_user      = m
Units separation_x_irga   = m
Units separation_y_irga   = m
Units dist_intrst_60_300  = m
Units dist_intrst_60_170  = m
Units dist_intrst_170_190 = m
Units dist_intrst_190_300 = m

#If (SENSOR_GPS) Then
Alias stn_conf_array(18) = height_GPS16X         'GPS installation height above the ground surface (m)
Units height_GPS16X      = m
#EndIf

#If (SENSOR_FW) Then
Alias stn_conf_array(18 - 1*SENSOR_GPS) = separation_x_FW   'Coordinate x of FW junction in the CSAT coordinate system (m)
Alias stn_conf_array(19 - 1*SENSOR_GPS) = separation_y_FW   'Coordinate y of FW junction in the CSAT coordinate system (m)
Alias stn_conf_array(20 - 1*SENSOR_GPS) = FW_diameter       'Diameter of fine wire (m)
Units separation_x_FW = m
Units separation_y_FW = m
Units FW_diameter     = m
#EndIf

#If (SENSOR_HFP AND SENSOR_SWC) Then
Alias stn_conf_array(18 - 1*SENSOR_GPS - 3*SENSOR_FW) = soil_bulk_density 'Soil bulk density (kg/m^3)
Alias stn_conf_array(19 - 1*SENSOR_GPS - 3*SENSOR_FW) = Cds               'Specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
Alias stn_conf_array(20 - 1*SENSOR_GPS - 3*SENSOR_FW) = thick_abv_SHFP    'Thickness of soil above soil heat flux plate (m)
Units soil_bulk_density  = kg m-3
Units Cds                = J kg-1 k-1
Units thick_abv_SHFP      = m
#EndIf

Dim stn_conf_array_prev(NMBR_STN_VAR)                                     'Hold previous station parameters to check for new user-entered values

'After a user inputs, used to assign a sign to latitude and longitude
Const NORTH =  1
Const SOUTH = -1
Const EAST  =  1
Const WEST  = -1

'Used to assign a value for surface_type
Const CROP     = 1
Const GRASS    = 2
Const FOREST   = 3
Const SHRUB    = 4
Const BARELAND = 5
Const WATER    = 6
Const ICE      = 7

Dim surface_type_array(7) As String * 9 = {"Crop", "Grass", "Forest", "Shrub", "Bare land", "Water", "Ice"}
Dim surface_type_text     As String * 9   'Used to record the surface type in data table

#If (SENSOR_FW) Then
Const FW05DIA  = 1.27e-5                  'Diameter of FW05 fine wire that is selected for FW diameter(m)
Const FW1_DIA  = 2.54e-5                  'Diameter of FW1 fine wire that is selected for FW diameter(m)
Const FW2_DIA  = 5.08e-5                  'Diameter of FW2 fine wire that is selected for FW diameter(m)
Const FW3_DIA  = 7.62e-5                  'Diameter of FW3 fine wire that is selected for FW diameter(m)
#EndIf
'*************** END OF STATION: CONSTANTS AND VARIABLES *****************


#If (SENSOR_GPS) Then
'*************************************************************************
'*** BEGINNING OF CONSTANTS AND VARIABLES FOR GPS AND SOLAR POSITION   ***
'*************************************************************************
'*** Variables for GPS  
Dim nmea_sentence(2) As String * 100         'Hold NMEA sentences: nmea_sentence(1) for GPRMC and nmea_sentence(2) for GPGGA.
Public gps_array(15)
Alias gps_array(1) = latitude_GPS_degree     'Degrees latitude (+ = North; - = South)
Alias gps_array(2) = latitude_GPS_minute     'Minutes latitude
Alias gps_array(3) = longitude_GPS_degree    'Degrees longitude (+ = East; - = West)
Alias gps_array(4) = longitude_GPS_minute    'Minutes longitude
Alias gps_array(5) = speed                   'Speed
Alias gps_array(6) = course                  'Course over ground
Alias gps_array(7) = magnetic_variation      'Magnetic variation from true north (+ = East; - = West)
Alias gps_array(8) = fix_quality             'GPS fix quality: 0 = invalid, 1 = GPS, 2 = differential GPS, 6 = estimated
Alias gps_array(9) = nmbr_satellites         'Number of satellites used for fix
Alias gps_array(10) = altitude_GPS           'Antenna altitude (m)
Alias gps_array(11) = pps                    'usec into sec of system clock when PPS rising edge occurs, typically 990,000 once synced
Alias gps_array(12) = dt_since_gprmc         'Time since last GPRMC string, normally less than 1 second
Alias gps_array(13) = gps_ready              'Counts from 0 to 10, 10 = ready
Alias gps_array(14) = max_clock_change       'Maximum value the clock was changed in msec
Alias gps_array(15) = nmbr_clock_change      'Number of times the clock was changed
Units latitude_GPS_degree  = degrees
Units latitude_GPS_minute  = minutes
Units longitude_GPS_degree = degrees
Units longitude_GPS_minute = minutes
Units speed                = m s-1
Units course               = decimal degrees
Units magnetic_variation   = decimal degrees
Units fix_quality          = adimensional
Units nmbr_satellites      = counts
Units altitude_GPS         = m
Units pps                  = us
Units dt_since_gprmc       = s
Units gps_ready            = adimensional
Units max_clock_change     = ms
Units nmbr_clock_change    = counts

Dim gps_ready_best As Long
#EndIf '(SENSOR_GPS)

'*** Variables for solar position   
Dim   solar_position_array(5)
Alias solar_position_array(1) = sun_azimuth
Alias solar_position_array(2) = sun_elevation
Alias solar_position_array(3) = hour_angle
Alias solar_position_array(4) = sun_declination
Alias solar_position_array(5) = air_mass_coeff
Units sun_azimuth     = decimal degrees
Units sun_elevation   = decimal degrees
Units hour_angle      = decimal degrees
Units sun_declination = decimal degrees
Units air_mass_coeff  = adimensional

Dim daytime As Long                       'Day = 1 and night = 0
Dim    daytime_frac_scan_intv             'To calculate the day time fraction in an output interval using Totalize instruction  
Units  daytime_frac_scan_intv = fraction  
 
'*** Real time variables    
 Dim realtime_array(9)                    'Hold real time data to calculated the time length of the 1st time averaging interval that starts anytime   

'******* END OF CONSTANTS AND VARIABLES FOR GPS AND SOLAR POSITION  ******
 

'*************************************************************************
'*****             BEGIN PROGRAM WORKING VARIABLES                   *****
'*************************************************************************
dim scan_count                As Long        'Number scans executed. Working variable used to judge the scan loop, from which data processing starts.

Dim slowsequence_finished_f   As Boolean     'Flag used to indicate that the slowSequence has finished its scan.
Dim slowsequence_disable_f    As Boolean     'Flag used to decimate statistics in main scan.

Dim i, i_slow, j_slow, k_slow As Long        'Index variables for iteration loop counts "i" in main scan and "i_slow", outmost; "j_slow", middle; "k_slow", inside. 
Dim array_index               As Long        'Used for array index that must be calculated using loop index (to simplify expression and reduce computation for array index)
Dim NaN_cnt                   As Long

Dim n As Long = 1                            'Used to count the number of samples for computation inside a data table
Units n = samples

Dim dly_data_out(8)                          'Array used to temporarily store the lagged record from the raw data table (hidden)

Dim x_tmp, T_tmp                             'Temporary variable used in intermediate calculations

Dim truefalse(2) As String * 5 = {"TRUE", "FALSE"} 'Use to store a Boolean variable to a string of TRUE or FALSE

Dim process_time                             'Used to monitor processing time and reported in flux_notes table
Units process_time = ms                      'Converted from us to ms that is easy to read

Dim buff_depth                               'Used to monitor buffer depth and reported in flux_notes table
Units buff_depth = scans
'******************* END OF PROGRAM WORKING VARIABLES ********************


'*************************************************************************
'*****           BEGIN DATALOGGER SELF-MEASUREMENT VARIABLES         *****
'*************************************************************************
'*** CR1000X temperature and voltage 
Public T_panel: Units T_panel = deg C         'CR1000X panel temperature
Public V_batt : Units V_batt  = V             'Voltage of power connected to CR1000X
Dim    V_batt_runng                           'Running average of V_batt

#If (CDM_VOLT_116) Then
'*** CDM-A/VOLT116 panel temperature
Const CDM_VOLT_1ST_TMPR_CHAN = 1              'Starting terminal group for CDM-A/VOLT panel temperature measurement (1, 2, 3, or 4)
Const NMBR_TMPR_CDM_VOLT     = 4              'Number of terminal groups (terminal panel temperature measurements). There are 4 panel temperature measurements.

Public T_cdm_volt(NMBR_TMPR_CDM_VOLT)
Alias  T_cdm_volt(1) = T_cdm_volt_1          'CDM-A/VOLT-116 panel temperature #1
#If (NMBR_TMPR_CDM_VOLT > 1) Then 
Alias  T_cdm_volt(2) = T_cdm_volt_2          'CDM-A/VOLT-116 panel temperature #2
#EndIf 
#If (NMBR_TMPR_CDM_VOLT > 2) Then 
Alias  T_cdm_volt(3) = T_cdm_volt_3          'CDM-A/VOLT-116 panel temperature #3
#EndIf
#If (NMBR_TMPR_CDM_VOLT > 3) Then 
Alias  T_cdm_volt(4) = T_cdm_volt_4          'CDM-A/VOLT-116 panel temperature #4
#EndIf
Units  T_cdm_volt    = deg C
#EndIf 
'************* END OF DATALOGGER SELF-MEASUREMENT VARIABLES **************
 

'*************************************************************************
'*****       BEGINNING OF CORRECTION: CONSTANTS AND VARIABLES *************
'*************************************************************************
'*** Rotation angles from the instrument to the natural flow coordinate system. Notations are consistent with Wilczak et al (2001)
Dim alpha                                  'Angle of counterclockwise rotation about y-axis (pitch)
Dim beta                                   'Angle of counterclockwise rotation about x-axis (roll)
Dim gamma                                  'Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha = Decimal degrees
Units  beta  = Decimal degrees
Units  gamma = Decimal degrees

Dim alpha_5min                             '5-minute data for data QC. Angle of counterclockwise rotation about y-axis (pich)
Dim beta_5min                              '5-minute data for data QC. Angle of counterclockwise rotation about x-axis (roll)
Dim gamma_5min                             '5-minute data for data QC. Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha_5min = Decimal degrees
Units  beta_5min  = Decimal degrees
Units  gamma_5min = Decimal degrees

'*** Rotation angles for planar fit rotations
'1) Program chooses planar fit rotation of Wilczak et al. (2001) if one of the eight angles in an array: planar_fit_angle_conf_array(4,2) is not zero.
'2) Program chooses conventional rotation of Tanner and Thurtell (1969) if the following eight angles are all zero.
Dim planar_fit_angle_conf_array_file      As Long           'Filehandle for the planar fit angle configuration data stored in the CPU.
Dim planar_fit_angle_conf_array_file_size As Long           'Size of the station configuration file stored on the CPU.
Dim planar_fit_angle_conf_array_prev(4,2)                   'Remembering variable: Hold previous angles for Planar Fit

Public planar_fit_angle_conf_array(4,2)                     'Hold angles for Planar Fit in the four sectors as described below
Units  planar_fit_angle_conf_array      = Decimal degrees

' Alpha_PF_xxx_xxx angle between instrument and natural flow z-axis in the instrument x-z plane.
Alias planar_fit_angle_conf_array (1,1) = alpha_PF_60_300   'for wind direction of 0~<=60 and >300~360 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (2,1) = alpha_PF_60_170   'for wind direction of >60  and <=170 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (3,1) = alpha_PF_170_190  'for wind direction of >170 and <=190 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (4,1) = alpha_PF_190_300  'for wind direction of >190 and <=300 degrees in the CSAT coordinate system [degrees]

' Betal_PF_xxx_xxx angle between instrument and natural flow z-axis in the instrument y-z plane.
Alias planar_fit_angle_conf_array (1,2) = beta_PF_60_300    'for wind direction of 0~<=60 and >300~360 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (2,2) = beta_PF_60_170    'for wind direction of >60  and <=170 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (3,2) = beta_PF_170_190   'for wind direction of >170 and <=190 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (4,2) = beta_PF_190_300   'for wind direction of >190 and <=300 degrees in the CSAT coordinate system [degrees]

Public Planar_Fit_flg As Boolean                            'TRUE if Planar Fit is used (e.g. any element of planar_fit_angle_conf_array() is not zero)

'*** Atmospheric stability
Dim    MO_LENGTH                        'Monin-Obukhov length (m)
Dim    PBLH                             'Planetary boundary layer height (m)  
Public d                                'Displacement height (m)
Public z0                               'Roughness length (m)
Public z                                'Aerodynamic height: z = measurement height - d  (m)
Dim    z_prev                           'Previous z, used to judge whether or not the distance of interest needs to be re-evaluated 
Dim    ZL                               'Atmospheric surface-layer stability (dimensionless)
Dim    ZL_prev                          'Previous ZL (dimensionless)
Units  MO_LENGTH  = m
Units  PBLH       = m 
Units  d          = m
Units  z0         = m
Units  z          = m
Units  ZL         = adimensional

'*** Constants used for numerical integration in calculating the freq correction factors
Const START_FREQ           = 10e-6     'Starting cyclic freq for numerical integration of cospectrum times transfer function
Const END_FREQ             = 10000.0   'Ending cyclic freq for numerical integration of cospectrum times transfer function
Const FREQ_BIN             = 100.0     'The number of bins for cyclic freq
Const STEP_BASE_FREQ       = EXP((LN(END_FREQ)- LN(START_FREQ))/FREQ_BIN)   'freq interval base for numerical integration of cospectra and transfer functions (e.g. 100 bins from 0.000001 to 10000 Hz).
Const ACCURACY_FREQ_FACTOR = 0.0001    'The accuracy target of freq factor to approach the "true" value (|current freq factor - previous freq factor|) [page 106: Foken et al. (2012)]
Const MAX_LAG              = 5         'Maximum number of lags in scans that is used to maximizing the covariance. This number of 2 is believed to be adequate for CSAT with EC150 and/or FW

' *** Frequency (freq) correction
Dim   iteration_FreqFactor As Long                             'Count iterations while correcting wu, wv, and wTs for accurate Monin-Obukhov length
Dim    FreqFactor_UW_VW         = 1                            'Freq correction factor for covariance of vertical with horizontal wind that are measured using CSAT
Dim    FreqFactor_UW_VW_Prev    = 1 - 2*ACCURACY_FREQ_FACTOR   'Previous FreqFactor_UW_VW
Dim    FreqFactor_WT_SONIC      = 1                            'freq correction factor for covariance of vertical wind with sonic temperature that are measured using CSAT
Dim    FreqFactor_WT_SONIC_Prev = 1 - 2*ACCURACY_FREQ_FACTOR   'Previous FreqFactor_WT_SONIC
Dim    FreqFactor_WCO2_WH2O     = 1                            'Freq correction factor for covariance of vertical wind with IRGA h2o or co2 that are measured using a CSI OPEC system 
Units FreqFactor_UW_VW     = adimensional
Units FreqFactor_WT_SONIC  = adimensional
Units FreqFactor_WCO2_WH2O = adimensional

#If (SENSOR_FW) Then
Dim    FreqFactor_WFW                                          'Freq correction factor for covariance of vertical wind with temperature that are measured using CSAT and FW
Units  FreqFactor_WFW = adimensional
#EndIf

' ------ Numerical wTs transfer function Dijk (2002): alternatively kl and transfer function value where k is wavenumber and l is path length ------
' Hold following numerical values of transfer function of line averaging for wTs of CSAT measurements from Table 1 in Dijk (2012)
Dim tran_func_LA_data_Dijk(2,35) = { _
0.00,0.01,0.10,0.20,0.50,1.00,1.20,1.40,1.60,1.80,2.00,2.20,2.40,2.60,2.80,3.00,4.00,5.00,6.00,7.00,8.00,9.00,10.0,14.0,20.0,30.0,40.0,50.0,60.0,70.0,80.0,90.0,100,300,10000, _
1.00000,1.00000,0.99920,0.99760,0.99000,0.96700,0.95500,0.94170,0.92740,0.91220,0.89620,0.87970,0.86260,0.84520,0.82740,0.80960,0.72010,0.63530, _
0.55880,0.49220,0.43550,0.38790,0.34810,0.24450,0.17000,0.11340,0.08503,0.06802,0.05668,0.04859,0.04251,0.03779,0.03401,1.89888e-2,1.6168e-4}  
' The data points were extended to kl= 300 and 10000 according to the numerical derivative of transfer function with respect to kl from kl= 70 to 100.
' ----------------------------------------- End of numerical wTs transfer function values from Dijk (2002) ------------------------------------------
'************* END OF CORRECTION CONSTANTS AND VARIABLES *****************


'*************************************************************************
'** BEGINNING OF CONSTANTS, VARIABLES, SUBROUTINES, AND TABLE FOR EC100 **
'*************************************************************************
'*** Constants and variables that are used to select options in data pad (e.g. CR1000KD)  
Const BB       = 0                    'BB = 0 for EC100 built-in Basic Barometer (EC100 built-in basic pressure transducer)
Const UB       = 1                    'UB = 1 for EC100 User-added Barometer (pressure transducer)
Const EB       = 2                    'EB = 2 for EC100 CS106, Enhanced Barometer (pressure transducer)
Const PWR_ON   = 0                    'IRGA power on 
Const PWR_OFF  = 1                    'IRGA power off
Const H_AUTO   = -2                   'Heater auto
Const H_MAX    = 0                      'Heater max at 4.5375 V. 
Const H_OFF    = -1                   'Heater off
Const FAST_ON  As Boolean = TRUE      'Use the alternative CO2 density that is computed from Ts and H2O for spectroscopic effects (see Helbig et al. 2016).
Const FAST_OFF As Boolean = FALSE     'Conventional CO2
Const CORR_ON  = 1                    'ON = apply shadow correction 
Const CORR_OFF = 0                    'OFF = do not apply shadow correction

'*** Variables for EC100 setting  
Public press_source                   'Hold current option of pressure tranducer
Public heater_actual                  'Hold current option of heater 
Public heater_user = H_AUTO           'Hold heater option from the user.            
Public irga_power                     'Hold current status of IRGA power
Dim    CO2_fast_tmpr        As Boolean = TRUE 'Hold current option of CO2 for computation 
Public select_CO2_fast_tmpr As Boolean = TRUE 'Used to change CO2_fast_tmpr after confirmation by set_CO2_fast_tmpr_flg as true   
Public shadow_corr                    'Hold current option of shadow correction

Public CO2_span_gas       = 420       'CO2 standard gas for CO2 span (umol/mol, read from the CO2 gas cylinder bottle)
Units  CO2_span_gas       = umol mol-1
Dim    CO2_span_gas_prev  = 420
Public T_DP_span_gas      = 20        'Dew point temperature for H2O span (C, read from the setting of dew point generator)
Units  T_DP_span_gas      = deg C
Dim    T_DP_span_gas_prev = 20
'*** Constants used to pre-configue EC100
Const DIFFERENTIAL_PRESS  = 0         '0 = disabled. Not applicable to an OPEC system. Should be disabled  
Const TEMPERATURE_SOURCE  = 0         '0 = defaut ambient temperature sensor that gas analyzer has

'*** Array used to configue EC100
Dim ec100_setting_array(11, 2) = {100, NaN, 102, NaN, 103, NaN, 107, NaN, 114, NaN, 115, NaN, 116, NaN, 117, NaN, 118, NaN, 121, NaN, 125, NaN}  'Used to get the EC100 current setting for notes
Dim ec100_reset_array  (11, 2) = {0,   NaN,   2, NaN,   3, NaN,   7, NaN,  14, NaN,  15, NaN,  16, NaN,  17, NaN,  18, NaN,  21, NaN,  25, NaN}  'Used to reset the EC100 configuration for notes
Dim config_ec100_array (6, 2)  = {0, BANDWIDTH, 3, DIFFERENTIAL_PRESS, 7, TEMPERATURE_SOURCE}
Dim press_source_array (1, 2)  = {2, NaN}          '1st col 2--> barometer set commend, 2nd col  pressure source, BB=0--> EC100 built-in Basic Barometer, EB=2 Enhanced Barometer.
Dim zro_array          (1, 2)  = {11, 1}           'Used for zeroing operation: 1st col 11--> Zero/Span command, 2nd col 0--> Inactive, 1--> Zero, 2--> SpanCO2, 3--> SpanH2O.
Dim spn_CO2_array      (2, 2)  = {12, 0, 11, 2}    'Used for CO2 span operation: 1st col 12->CO2 concentration span, 2nd col CO2 span concentration value (0 as default), 3rd and 4th cols are zro_array above.
Dim spn_H2O_array      (2, 2)  = {13, 0, 11, 3}    'Used for H2O span operation: 1st col 13->H2O dew point temperature span, 2nd col span dew point temperature (0 as default), 3rd and 4th cols are zro_array above.
Dim irga_pwr_array     (2, 2)  = {21, 0, 18, -2}   'Used for power off IRGA (not for EC100) and for controlling IRGA heating 
                                                   '1st row: 1st col 21 control power commend and 2nd col 0 --> power on and 1 --> power off IRGA
                                                   '2nd row: 1st col 18 control IRGA heating (lense) commend and 2nd col: -2 auto, 0 max at  4.5375 V, and -1 off. 
Dim shadow_corr_array  (1, 2)  = {25, NaN}         'Apply sonic shadow correction, value read from EC100 on compile.

'Zero/span coefficient array to hold current values which can be changed by user in CR1000KD or Public Table  
Public zro_spn_coef_array (4) = {NaN, NaN, NaN, NaN}           
Alias  zro_spn_coef_array (1) = CO2_zero_coeff
Alias  zro_spn_coef_array (2) = CO2_span_coeff  
Alias  zro_spn_coef_array (3) = H2O_zero_coeff 
Alias  zro_spn_coef_array (4) = H2O_span_coeff
                   

' Default CO2/H2O zero/span coefficients from Statistic of CO2/H2O Zero/Span Coefficients (Zhou, 04/23/2022).
' This array will be used for coefficient reset in case any element of zro_spn_coeffs (4) is out of range. 
' The range is defined as mean + 10xSTD for zero coefficient and 5xSTD for span coefcient.
' Data for IRGASON are used as default below. If EC150, the values below will be overwritten in program for EC150. 
Dim rst_zro_spn_coeff_array (4, 2) = {14, 1.000375, 15, 1.000386, 16, 0.999269, 17, 0.997258}  

Const NMBR_RCRDS_OPRTN_NOTES_CPU = Ceiling (3*7 + 3)      'The number of records in CPU for operation notes.
Const NMBR_RCRDS_OPRTN_NOTES_CRD = Ceiling (3*366+100)    'The number of records in CRD for operation notes.
 '(3 records for checking zero, CO2 span, and H2O span; 366 day a year, 100 for extra attendant checking).
 
Const NMBR_RCRDS_CONFIG_NOTES_CPU = Ceiling (3*7 + 3)    'The number of records in CPU for configuration notes.
Const NMBR_RCRDS_CONFIG_NOTES_CRD = Ceiling (3*366+100)  'The number of records in CRD for configuration notes.
 '(3 records if checking zero, CO2 span, and H2O span; 366 day a year, 100 for extra attendant checking).

'*** EC100 configuration variables and flags 
Dim    config_ec100_initial_f  As Boolean = TRUE   'Default: Configure EC100 as soon as this program starts.
Dim    get_ec100_config_f      As Boolean = TRUE   'Default: First read and record EC100 configuration as soon as program starts.    
Dim    config_ec100_f          As Boolean = TRUE   'Default: Configure EC100 as soon as this program starts.

Public set_press_source_flg  As Boolean
Public set_zero_flg          As Boolean
Public set_CO2_span_flg      As Boolean
Public set_H2O_span_flg      As Boolean
Public set_heater_flg        As Boolean
Public set_irga_power_flg    As Boolean
Public set_CO2_fast_tmpr_flg As Boolean
Public set_shadow_corr_flg   As Boolean 

Public rst_zro_spn_coef_flg_array (4) As Boolean = {FALSE, FALSE, FALSE, FALSE}  'Used to reset zero/span coefficients.  
Alias  rst_zro_spn_coef_flg_array (1) = rst_CO2_zro_coef_flg
Alias  rst_zro_spn_coef_flg_array (2) = rst_CO2_spn_coef_flg  
Alias  rst_zro_spn_coef_flg_array (3) = rst_H2O_zro_coef_flg 
Alias  rst_zro_spn_coef_flg_array (4) = rst_H2O_spn_coef_flg

'*** IRGA power control variables, constants, and flags  
Dim    irga_pwr_off_f        As Boolean = FALSE    'Flag for manually powering on/off IRGA. Used for DisplayMenu of System Control.  
Dim    irga_pwr_off_f_prev   As Boolean
Dim    irga_pwr_switch_f     As Boolean            'Flag to switch IRGA power on/off. Determined by irga_pwr_off_f, irga_pwr_off_f_prev, power supply voltage to set power_array(2, 2).  
Public irga_vlt_low_auto_off As Boolean            'Indicates that IRGA auto-off due to voltage lower than SYSTEM_PWR_OFF_SET_PT
Public irga_actual_pwr_on    As Boolean = TRUE     'Indicates the actual status of IRGA power (TRUE = on and FALSE = off)
Public irga_user_set_pwr_on  As Boolean = TRUE     'Indicates IRGA-on set by a user. Although it is on, irga_actual_pwr_on would be false if voltage lower than SYSTEM_PWR_OFF_SET_PT 
Dim    irga_off_bit          As Long               'From diag code 
Dim    irga_startup_bit      As Long               'From diag code
Public secs_snc_pwr_swtch                          'Seconds since last commend (or action)

'Power control constants and variable.
Const SYSTEM_PWR_OFF_SET_PT          = 10.5        'System power control threshold in volt. System power off if volt_batt < SYSTEM_PWR_OFF_SET_PT
Const SYSTEM_PWR_DEAD_BAND_WIDTH     = 1.5         'System power control threshold dead band in volt. System power on if volt_batt > (SYSTEM_PWR_OFF_SET_PT + SYSTEM_PWR_DEAD_BAND_WIDTH)
Dim   cnt_lwr_pwr_off_set_pt As Long = 0           'Scan count of IRGA power voltage continuously lower than SYSTEM_PWR_OFF_SET_PT.

'REcording variables 
Dim config_type        As String * 16 = NaN        'System configuration
Dim config_status      As String * 10 = NaN        'Status of system configuration 
Dim config_commend     As Long
Dim operatn_failed_cnt As Long 

Dim   value_str(5) As String * 40 = {NaN, NaN, NaN, NaN, NaN}
Alias value_str(1) = curr_value_str
Alias value_str(2) = prev_value_str
Alias value_str(3) = prev_value_str_CO2                  'An intermediate variable 
Alias value_str(4) = prev_value_str_H2O                  'An intermediate variable 
Alias value_str(5) = prev_value_str_pwr                  'An intermediate variable 


'*** EC100 Configuration setting subroutine
Sub Config (cmd_array(11, 2), num_cmd As Long, retry_config_f As Boolean)
  Dim i_cnfg           As Long
  Dim config_result    As Long
  Dim save_flash_f     As Boolean
  Dim SkippedScan_prev As Long

  save_flash_f      = FALSE
  SkippedScan_prev = status.SkippedScan
  
  For i_cnfg = 1 To num_cmd
    retry_config_f = TRUE               'Reset 
    save_flash_f   = FALSE              'Reset 

    EC100Configure (config_result, EC100SDM_ADR, cmd_array(i_cnfg, 1), cmd_array(i_cnfg, 2))
    
    If (config_result = NAN) Then
       ExitFor 
    EndIf 
          
    Select Case cmd_array(i_cnfg, 1)                      
       Case 0, 2, 3, 7, 11, 12, 13, 14, 15, 16, 17, 18, 21, 25  
           '0:Bandwidth, 2: pressure source, 3: Differential pressure, 11: zeroing, 12: CO2 span, 13: H2O span, 14: CO2 zero value
           '15:CO2 span value, 16: H2O zero value, 17: H2O span value, 18: heater control, 21: IRGA power, 25: shadow correction 

            save_flash_f = TRUE  
            
       Case 100, 102, 103, 107, 114, 115, 116, 117, 118, 121, 125
           retry_config_f = FALSE
           save_flash_f   = FALSE
   EndSelect 

  Next i_cnfg
  
  If (cmd_array(num_cmd, 1) = 11) Then 
    Delay (1, 3200, mSec)              '3000 ms for data processing during zero/span procedures 
  Else   
    Delay (1, 1000, mSec)
  EndIf 
  
  If ((i_cnfg = num_cmd + 1)  AND (save_flash_f) AND (config_result <> NAN)) Then
   
      EC100Configure (config_result, EC100SDM_ADR, 99, 2718)
      retry_config_f = FALSE
 
  EndIf

  SetStatus ("SkippedScan", SkippedScan_prev)
EndSub

'*** Table for EC100 setting notes
DataTable (Config_Setting_Notes, TRUE, NMBR_RCRDS_CONFIG_NOTES_CPU)
  CardOut(0, NMBR_RCRDS_CONFIG_NOTES_CRD)

  Sample (1, config_type,   String) 
  Sample (1, config_status, String) 
  Sample (1, ec100_setting_array(1, 2), IEEE4)
  FieldNames ("bandwidth_freq")
  Sample (1, ec100_setting_array(2, 2), IEEE4)
  FieldNames ("press_source")
  Sample (1, ec100_setting_array(3, 2), IEEE4)
  FieldNames ("diff_press")
  Sample (1, ec100_setting_array(4, 2), IEEE4)
  FieldNames ("tmpr_source")
  Sample (1, ec100_setting_array(5, 2), IEEE4)
  FieldNames ("CO2_zero_coeff")
  Sample (1, ec100_setting_array(6, 2), IEEE4)
  FieldNames ("CO2_span_coeff")
  Sample (1, ec100_setting_array(7, 2), IEEE4)
  FieldNames ("H2O_zero_coeff")
  Sample (1, ec100_setting_array(8, 2), IEEE4)
  FieldNames ("H2O_span_coeff")
  Sample (1, CO2_span_gas, IEEE4)
  FieldNames ("CO2_span_mixra")
  Sample (1, T_DP_span_gas, IEEE4)
  FieldNames ("H2O_span_T_DP")
  Sample (1, ec100_setting_array(9, 2), IEEE4)
  FieldNames ("IRGA_Heat_ctrl")
  Sample (1, ec100_setting_array(10, 2), IEEE4)
  FieldNames ("IRGA_power")
  Sample (1, truefalse (2 + CO2_fast_tmpr), String)        'TRUR: fast temperature used spectroscopic correction and FALSE: 107 temperature used
  FieldNames ("CO2_fast_tmpr")
  Sample (1, ec100_setting_array(11, 2), IEEE4)
  FieldNames ("shadow_corr")
  
  'CSAT3AH heating user setting  
  #If (CSAT3A_EC150) Then  
  #If (CSAT_TYP_3AH) Then  
  Sample (1, truefalse (2 + CSAT3H_user_ctrl_flg), String)
  FieldNames ("CSAT3AH_user_ctrl_on")
  #EndIf
  #EndIf 
  
EndTable
'***** END OF CONSTANTS, VARIABLES, SUBROUTINES, AND TABLE FOR EC100 *****
 
 
'*************************************************************************
'** BEGINNING OF CONSTANTS, VARIABLES, AND WORKING DATA TABLES FOR CSAT***
'*************************************************************************
'*** Constant used for freq correction 
Const PATH_LENGTH_CSAT = 0.1154701       'CSAT path length = 10 cm/sin(pi/3) (m)

'*** Variables and arrays for CSAT measurements and data processing 
Public sonic(5)                          'Hold CSAT data aligned in scan with data from IRGA and/or fine wire thermocouple
Alias  sonic(1) = Ts
Alias  sonic(2) = Ux
Alias  sonic(3) = Uy
Alias  sonic(4) = Uz
Alias  sonic(5) = diag_sonic
Units  Ts = deg C
Units  Ux      = m s-1
Units  Uy      = m s-1
Units  Uz      = m s-1
Units  diag_sonic = adimensional

Dim U_rslt                                 'Used to calculate Maximum resultant wind speed in an averaging period   

Dim   diag_bits_sonic(6) As Long           'Sonic warning flags
Alias diag_bits_sonic(1) = sonic_amp_l_f   'Amplitude low warning flag
Alias diag_bits_sonic(2) = sonic_amp_h_f   'Amplitude high warning flag
Alias diag_bits_sonic(3) = sonic_sig_lck_f 'Poor signal lock warning flag
Alias diag_bits_sonic(4) = sonic_del_T_f   'Delta temperature warning flag
Alias diag_bits_sonic(5) = sonic_aq_sig_f  'Sonic acquiring signals warning flag
Alias diag_bits_sonic(6) = sonic_cal_err_f 'Signature error in reading CSAT sonic head calibration data
Units diag_bits_sonic    = adimensional

Dim sonic_irga_raw(14)                     'Hold the data from EC100 (CSAT, IRGA, temperature sensor, and barometer raw data before applying instrument scan lag)

Dim diag_sonic_tmp  As Long                'Working variable used to break out the CSAT sonic head diagnostic bits
Dim sonic_disable_f As Boolean             'TRUE when any CSAT diagnostic warning flag is on, CSAT has not sent data, or an SDM signature error is reported

Dim   diag_sonic_aggregate As Long        'Aggregated diagnosis code within an output interval, indicating the occurrence of all flags.
Units diag_sonic_aggregate = adimensional

Dim mask As Long                           'Masking the diagnosis code
Dim Ts_K                                   'Sonic temperature in K

Dim cov_out_sonic(20)                      'CSAT sonic statistics
Alias cov_out_sonic(1)  = Ux_Avg               
Alias cov_out_sonic(2)  = Ux_SIGMA          
Alias cov_out_sonic(3)  = UxUy_Cov         
Alias cov_out_sonic(4)  = UxUz_Cov           
Alias cov_out_sonic(5)  = Uy_Avg                
Alias cov_out_sonic(6)  = Uy_SIGMA          
Alias cov_out_sonic(7)  = UyUz_Cov
Alias cov_out_sonic(8)  = Uz_Avg
Alias cov_out_sonic(9)  = Uz_SIGMA
Alias cov_out_sonic(10) = Ts_Avg          'Ts averaged over an averaging interval (AmeriFlux notation) 
Alias cov_out_sonic(11) = Ts_SIGMA        'Ts standard deviation is stored here. Unlike standard deviation of momentum variable, it is not related to coordinate rotation (AmeriFlux notation) 
Alias cov_out_sonic(12) = TsUx_Cov
Alias cov_out_sonic(13) = TsUy_Cov
Alias cov_out_sonic(14) = TsUz_Cov
Alias cov_out_sonic(15) = WS
Alias cov_out_sonic(16) = WS_RSLT         'Result wind speed (AmeriFlux notation) 
Alias cov_out_sonic(17) = WD_SONIC        'wind direction of 0 to 360 degree in the CSAT coordinate system, equal to Gamma in coordination rotation.
Alias cov_out_sonic(18) = WD_SIGMA
Alias cov_out_sonic(19) = WS_MAX          'Maximum wind speed over an averaging interval (AmeriFlux notation)
Alias cov_out_sonic(20) = WD              'wind direction in compass convention (AmeriFlux notation) 
Units Ux_Avg   = m s-1
Units Ux_SIGMA = m s-1
Units UxUy_Cov = m2 s-2
Units UxUz_Cov = m2 s-2
Units Uy_Avg   = m s-1
Units Uy_SIGMA = m s-1
Units UyUz_Cov = m2 s-2
Units Uz_Avg   = m s-1
Units Uz_SIGMA = m s-1
Units Ts_Avg   = deg C
Units Ts_SIGMA = deg C
Units TsUx_Cov = deg C m s-1
Units TsUy_Cov = deg C m s-1
Units TsUz_Cov = deg C m s-1
Units WS       = m s-1
Units WS_RSLT  = m s-1
Units WD_SONIC = decimal degrees
Units WD_SIGMA = decimal degrees
Units WS_MAX   = m s-1
Units WD       = decimal degrees

' *** Variables after coordinate rotations as indicated by the last letter of "R".
' 3D wind components before coordinate rotations are Ux, Uy, and Uz, and afterwards they are referred to as U, V, and W, respectively.
' Sonic temperature is denoted by Ts before coordinate rotations and by T_SONIC afterwards
Dim USTAR_R                                'Friction velocity after coordinate rotations
Dim U
Dim U_SIGMA
Dim UV_Cov
Dim UW_Cov
Dim V
Dim V_SIGMA
Dim VW_Cov
Dim W
Dim W_SIGMA
Dim T_SONIC        
Dim T_SONIC_SIGMA
Dim UT_SONIC_Cov
Dim VT_SONIC_Cov
Dim WT_SONIC_Cov

Units USTAR_R = m s-1
Units U       = m s-1
Units U_SIGMA = m s-1
Units UV_Cov  = m2 s-2
Units UW_Cov  = m2 s-2
Units V       = m s-1
Units V_SIGMA = m s-1
Units VW_Cov  = m2 s-2
Units W       = m s-1
Units W_SIGMA = m s-1
Units T_SONIC = deg C        
Units T_SONIC_SIGMA = deg C
Units UT_SONIC_Cov  = deg C m s-1
Units VT_SONIC_Cov  = deg C m s-1
Units WT_SONIC_Cov  = deg C m s-1

Dim    TKE                           'specific turbulent kinetic energy
Units  TKE = m2 s-2                  '[kg (m/s)^2]/kg

' *** Variables after frequency corrections have an "_fc" appended.
' Note, however, there are exceptions such as H for sensible heat flux and TAU for momentum flux, both of which are after freq corrections.
Dim TAU                              'Drag force (stress) at surface (momentum flux) after coordinate rotations and freq corrections
Dim USTAR                            'Friction velocity after coordinate rotations and freq corrections
Dim WT_SONIC_Cov_fc
Dim UW_Cov_fc
Dim VW_Cov_fc

Units TAU             = kg m-1 s-2  'Equivalent to (kg/m^3)(m/s)^2
Units USTAR           = m s-1
Units WT_SONIC_Cov_fc = deg C m s-1
Units UW_Cov_fc       = m2 s-2
Units VW_Cov_fc       = m2 s-2

Dim    WT_SONIC_Cov_fc_SND         'Covariance of sonic temperature with vertical velocity after rotation, freq, and SND corrections
Dim    TSTAR                       'Scaling temperature
Dim    H                           'Sensible heat flux: Derived from covariance of sonic temperature after rotation, freq, and SND corrections

Units  WT_SONIC_Cov_fc_SND = deg C m s-1
Units  TSTAR               = deg C
Units  H                   = W m-2

'*** Data quality classification: Constant and variables
Const OUTPUT_INTERVAL_SST = 5      'Sub-interval to calculate the statistics for Steady State Test (SST) [minutes]

' Steady State Test (SST)
Dim RN_UW_VW_cov                'Relative Non-Stationarity (RN) for momentum covariance (UW_Cov and VW_Cov)
Dim RN_UW_cov                   'Relative non-Stationarity for UW_Cov. It is also used for the sum of UxUz_Cov_SST below from 5-min sub-intervals.
Dim RN_VW_cov                   'Relative non-Stationarity for VW_Cov. It is also used for the sum of UyUz_Cov_SST below from 5-min sub-intervals.
Dim RN_WT_SONIC_cov             'Relative non-Stationarity for wTs_cov_R. It is also used for the sum of TsUz_Cov_SST below from 5-min sub-intervals.
Dim nmbr_interval_qc_csat       'Number of sub-intervals = (OUTPUT_INTV)/(OUTPUT_INTERVAL_SST)

Dim cov_out_sonic_SST(17)          'CSAT sonic head statistics for Steady State Test (SST)
Alias cov_out_sonic_SST(1)  = Ux_Avg_SST
Alias cov_out_sonic_SST(2)  = Ux_Var_SST
Alias cov_out_sonic_SST(3)  = UxUy_Cov_SST
Alias cov_out_sonic_SST(4)  = UxUz_Cov_SST
Alias cov_out_sonic_SST(5)  = Uy_Avg_SST
Alias cov_out_sonic_SST(6)  = Uy_Var_SST
Alias cov_out_sonic_SST(7)  = UyUz_Cov_SST
Alias cov_out_sonic_SST(8)  = Uz_Avg_SST
Alias cov_out_sonic_SST(9)  = Uz_Var_SST
Alias cov_out_sonic_SST(10) = T_SONIC_Var_SST
Alias cov_out_sonic_SST(11) = TsUx_Cov_SST
Alias cov_out_sonic_SST(12) = TsUy_Cov_SST
Alias cov_out_sonic_SST(13) = TsUz_Cov_SST
Alias cov_out_sonic_SST(14) = WS_SST
Alias cov_out_sonic_SST(15) = WS_RSLT_SST
Alias cov_out_sonic_SST(16) = WD_SONIC_SST   'Wind direction in CSAT coordinate system (0 to 360 degree)
Alias cov_out_sonic_SST(17) = WD_SIGMA_SST

' Variables for steady State Test after coordinate rotations
Dim U_SST
Dim U_Var_SST
Dim UV_Cov_SST
Dim UW_Cov_SST
Dim V_SST
Dim V_Var_SST
Dim VW_Cov_SST
Dim W_SST
Dim W_Var_SST
Dim UT_SONIC_Cov_SST
Dim VT_SONIC_Cov_SST
Dim WT_SONIC_Cov_SST

' Data quality grading
Dim    TAU_SSITC_TEST                 'Results of the Steady State and Integral Turbulence Characteristics for TAU according to Foken et al (2004)
Dim    H_SSITC_TEST                   'Results of the Steady State and Integral Turbulence Characteristics for H according to Foken et al (2004)
Units  TAU_SSITC_TEST = adimensional
Units  H_SSITC_TEST   = adimensional

Dim   TAU_QC                         'Overall grade of data QC for momentum flux (i.e., for variable: TAU) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
Dim   H_QC                           'Overall grade of data QC for sensible heat flux (i.e., for variable: H) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
Units TAU_QC = grade
Units H_QC   = grade

'*** Footprint characteristics: Constant and variables 
' Footprint characteristics
Const  NMBR_INT_INTERV_SEGMENT = 20       'Base number of numerical integration intervals for footprint characteristics in each integration segment
 
Dim FETCH_MAX                             'Upwind location of source/sink that contributes most to the measured flux
Dim FETCH_90                              'Upwind range within which the source/sink contributes 90% to the measured flux
Dim FETCH_55                              'Upwind range within which the source/sink contributes 55% to the measured flux
Dim FETCH_40                              'Upwind range within which the source/sink contributes 40% to the measured flux
Dim UPWND_DIST_INTRST                     'Upwind distant of interest
Public FP_DIST_INTRST                     'Cumulative footprint of measured scalar flux within upwind range of interest

Units FETCH_MAX = m
Units FETCH_90  = m
Units FETCH_55  = m
Units FETCH_40  = m
Units UPWND_DIST_INTRST  = m
Units FP_DIST_INTRST = %

Dim    FP_EQUATION As String * 14         '"Kljun et al" or "KormannMeixner"
Units  FP_EQUATION = authors

'*** Raw data table
DataTable (delay_3d, TRUE, OFFSET)
  TableHide
  Sample (4, sonic_irga_raw(1), IEEE4)   'Sonic data: Ux, Uy, Uz, and Ts 
  Sample (1, sonic_irga_raw(5), IEEE4)   'Sonic data: diag_sonic 
EndTable

'*** 5-minute covariance of CSAT data for steady state tests
DataTable (comp_cov_3d_5min, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL_SST, Min, 0)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
  Average    (1, Ux, IEEE4, sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4, sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
  Average    (1, Uy, IEEE4, sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4, sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz from CSAT data.
  Average    (1,Uz, IEEE4, sonic_disable_f)       'Using sonic(4)
  Covariance (1,Uz, IEEE4, sonic_disable_f, 1)    'Using sonic(4)

  'Compute covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
  Covariance (4, Ts, IEEE4, sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)
EndTable

' *** 30-minute covariance of CSAT data
DataTable (comp_cov_3d, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
  Average    (1, Ux, IEEE4,sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4,sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
  Average    (1, Uy, IEEE4,sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4,sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz (i.e., variance) from CSAT data.
  Average    (1, Uz, IEEE4,sonic_disable_f)      'Using sonic(4)
  Covariance (1, Uz, IEEE4,sonic_disable_f, 1)   'Using sonic(4)

  'Compute Ts mean and covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
  Average    (1, Ts, IEEE4,sonic_disable_f)      'Using sonic(1)
  Covariance (4, Ts, IEEE4,sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)
  
  'Compute the maximum of wind speed in an averaging interval 
  Maximum (1, U_rslt, IEEE4, sonic_disable_f, FALSE)

EndTable

#If (CSAT3A_EC150) Then 
#If (CSAT_TYP_3AH) Then 
'*** Variables from heater controller
Public com_rslt_get As Long                              'Result code for communication to get variables 
Units  com_rslt_get = adimensional

Public com_rslt_snt As Long                              'Result code for communication to send variables  
Units  com_rslt_snt = adimensional

Dim array_frm_heating_ctrl(17)                           'Variable array output from CSAT3AH heater controller 
Alias array_frm_heating_ctrl(1) = T_trnsd_uppr           'Upper transducer temperature          
Alias array_frm_heating_ctrl(2) = T_trnsd_lwr            'Lower transducer temperature 
Alias array_frm_heating_ctrl(3) = T_arm_uppr             'Upper arm temperature
Alias array_frm_heating_ctrl(4) = T_arm_lwr              'Lower arm temperature
Alias array_frm_heating_ctrl(5) = T_amb_ctrl             'Average ambient air temperature (controller) 
Alias array_frm_heating_ctrl(6) = RH_amb_ctrl            'Average ambient RH (controller)
Alias array_frm_heating_ctrl(7) = T_DP_amb_ctrl          'Average ambient dew point (controller)    
Alias array_frm_heating_ctrl(8) = pwr_trnsds             'Power through transducers for heating
Alias array_frm_heating_ctrl(9) = pwr_arms               'power through arms for heating
Alias array_frm_heating_ctrl(10)= pwr_trnsds_arms        'Heater power       
Alias array_frm_heating_ctrl(11)= trnsd_heater_on        'Transducer heater on (-1)/off (0)
Alias array_frm_heating_ctrl(12)= arm_heater_on          'Arm heater on (-1)/off (0)
Alias array_frm_heating_ctrl(13)= trnsd_heater_fail      'Transducer heater fail (-1)/normal (0)  
Alias array_frm_heating_ctrl(14)= arm_heater_fail        'Arm heater fail (-1)/normal (0)
Alias array_frm_heating_ctrl(15)= trnsd_ice_wet_lck      'Seconds after sonic_amp_l_f, _sig_lck_f, and/or _aq_sig_f are high while (T_amb_ctrl - T_DP_amb_ctrl) < T_OFFST_TRNSDS
Alias array_frm_heating_ctrl(16)= heating_inaplcbl_f     'flag to indicate sonic heating would be inapplicable to improve the measurements  
Alias array_frm_heating_ctrl(17)= CSAT3H_ctrl_on         'Control status of CR300 in controller is if "-1 and off if "0"

Units T_trnsd_uppr       = deg C
Units T_trnsd_lwr        = deg C
Units T_arm_uppr         = deg C
Units T_arm_lwr          = deg C
Units T_amb_ctrl         = deg C
Units RH_amb_ctrl        = %
Units T_DP_amb_ctrl      = deg C
Units pwr_arms           = W
Units pwr_trnsds         = W
Units pwr_trnsds_arms    = W
Units arm_heater_on      = adimensional 
Units trnsd_heater_on    = adimensional
Units arm_heater_fail    = adimensional
Units trnsd_heater_fail  = adimensional
Units trnsd_ice_wet_lck  = s
Units heating_inaplcbl_f = adimensional
Units CSAT3H_ctrl_on     = adimensional

Dim pwr_hr_trnsds_arms
Units pwr_hr_trnsds_arms= WH

Dim arm_heater_secs     = SLW_SCN_INTV/1000             'Totalize the seconds Flux_Notes during which pump heater was on
Dim trnsd_heater_secs   = SLW_SCN_INTV/1000             'Totalize the seconds Flux_Notes during which pump fan was on
Units arm_heater_secs   = s 
Units trnsd_heater_secs = s

Dim   array_to_heating_ctrl(7) = {NaN, NaN, 0, 86, (SLW_SCN_INTV/1000), FALSE, 0} 'Variable array from sonic measurements to CSAT3_H heater controller 
Alias array_to_heating_ctrl(1) = U_total_rung_mean      'Total wind velocity of running mean over a slow scan interval 
Alias array_to_heating_ctrl(2) = Ts_rung_mean           'Ts running mean over a slow scan interval 
Alias array_to_heating_ctrl(3) = diag_sonic_slwintv     'Aggregated diagnosis code over a slow scan interval 
Alias array_to_heating_ctrl(4) = press_rung_mean        'press running mean over a slow scan interval
Alias array_to_heating_ctrl(5) = com_intv               'Interval of communication between main Datalogger and CR300 inside the heating controller   
Alias array_to_heating_ctrl(6) = CSAT3H_user_ctrl_on    'Control heating for CSAT3AH by user from main Datalogger (CSAT3H_user_ctrl_on = - CSAT3H_user_ctrl_flg)   
Alias array_to_heating_ctrl(7) = rst_secs_snc_last_com  'Used to reset secs_snc_last_com as zero in the heating controller every communication    
Units U_total_rung_mean     = m s-1
Units Ts_rung_mean          = Deg C
Units diag_sonic_slwintv    = adimensional
Units press_rung_mean       = kPa
Units com_intv              = s
Units CSAT3H_user_ctrl_on   = adimensional   
Units rst_secs_snc_last_com = s

Public CSAT3H_user_ctrl_flg      As Boolean = FALSE    'Used to change CSAT3H_user_ctrl_on while program is running 
Dim    CSAT3H_user_ctrl_flg_prev As Boolean = FALSE

#EndIf '(CSAT_TYP_3AH) 
#EndIf '(CSAT3A_EC150)
'***** END OF CONSTANTS, VARIABLES, AND WORKING DATA TABLES FOR CSAT *****


'*************************************************************************
'**** BEGINNING OF IRGA CONSTANTS, VARIABLES, AND WORKING DATA TABLES ****
'*************************************************************************
'*** Constants used in field measurements and data processing  
Const DELAY_EC100               = INT ((4000/BANDWIDTH)/SCN_INTV)      'Automatically compute the electronic instrument lag of EC100 data in scan number
Const EC100_REC_BCK             = OFFSET - DELAY_EC100                 'Number of records back for aligning EC100 data with other sensor data in scan
Const PATH_LENGTH_IRGA          = 0.1531                               'IRGA path length (m).
Const CO2_SIG_STRGTH_THRESHOLD  = 0.70                                 'CO2 signal strength threshold below which the CO2 data are not used in instructions of AVERAGE and COVARIANCE, but kept in time series data table
Const H2O_SIG_STRGTH_THRESHOLD  = 0.70                                 'H2O signal strength threshold below which the H2O data are not used in instructions of AVERAGE and COVARIANCE, but kept in time series data table
Const CO2_RNG_TOP_LIMIT         = 1527.0                               'CO2 top range in mg/m^3. given IRGA calibrated in range of 0 ~ 1000 ppm CO2 in dry air at 25 C of air temperature in lab and at 86 kPa of pressure in Logan 
Const H2O_RNG_TOP_LIMIT         = 45.8                                 'H2O top range in g/m^3. given IRGA calibrated in range to dew point temperature at 25 C of air temperature in lab and at 86 kPa of pressure in Logan 

'*** Variables for separation corrections
Dim separation_lat_dist_irga        'Effective separation distance (m) in direction normal to wind direction. Used for separation correction
Dim separation_lag_dist_irga        'Effective separation distance (m) along wind direction. Used for lag maximization of covariance
Dim separation_lag_scan_irga        'Lag of wind passing over IRGA (scans) after (+ lag) or before (- lag) passing CSAT. Its unit is a scan number, but not necessary to use an integer

Units  separation_lat_dist_irga  =  m
Units  separation_lag_dist_irga  =  m
Units  separation_lag_scan_irga  =  scans

'*** Array to hold data from IRGA and related computation 
Public irga(22)                     'Hold IRGA data
Alias irga(1)  = CO2_density        'Conventional CO2 if CO2_fast_tmpr = FALSE or alternative CO2 from fast air temperature for spectroscopic effects if CO2_fast_tmpr = TRUE. 
Alias irga(2)  = H2O_density
Alias irga(3)  = diag_irga
Alias irga(4)  = T_amb              'Air temperature measured by temperature probe connected to EC100
Alias irga(5)  = press_amb          'Pressure measured by a barometer connected to EC100
Alias irga(6)  = CO2_sig_strgth
Alias irga(7)  = H2O_sig_strgth
Alias irga(8)  = RH_amb             'Relative humidity (%): derived from T_amb, H2O, and press_amb
Alias irga(9)  = T_DP_amb           'Dew point temperature (C): derived from T_amb, H2O, and press_amb
Alias irga(10) = e_sat_amb          'Saturation vapor pressure (kPa): derived from T_amb, H2O, and press_amb
Alias irga(11) = e_amb              'Vapor pressure (kPa): derived from T_amb, H2O, and press_amb
Alias irga(12) = rho_d_amb          'Dry air density (g/m^3): derived from T_amb, H2O, and press_amb
Alias irga(13) = rho_a_amb          'Moist air density (kg/m^3): derived from T_amb, H2O, and press_amb
Alias irga(14) = Tc                 'Air temperature (C), found from IRGASON Ts, H2O, and press_amb
Alias irga(15) = RH                 'Relative humidity (%): derived from Tc, H2O, and press_amb
Alias irga(16) = T_DP               'Dew point temperature (C): derived from Tc, H2O, and press_amb
Alias irga(17) = e_sat              'Saturation vapor pressure (kPa): derived from Tc, H2O, and press_amb
Alias irga(18) = e                  'Vapor pressure (kPa): derived from Tc, H2O, and press_amb
Alias irga(19) = rho_d              'Dry air density (g/m^3): derived from Tc, H2O, and press_amb
Alias irga(20) = rho_a              'Moist air density (g/m^3): derived from Tc, H2O, and press_amb
Alias irga(21) = CO2_mixratio       'CO2 mixing ratio calculated from CO2 and rho_d
Alias irga(22) = H2O_mixratio       'H2O mixing ratio
Units CO2_density     = mg m-3
Units H2O_density     = g m-3
Units diag_irga       = adimensional
Units T_amb           = deg C
Units press_amb       = kPa
Units CO2_sig_strgth  = fraction
Units H2O_sig_strgth  = fraction
Units RH_amb          = %
Units T_DP_amb        = deg C
Units e_sat_amb       = kPa
Units e_amb           = kPa
Units rho_d_amb       = g m-3
Units rho_a_amb       = kg m-3
Units Tc              = deg C
Units RH              = %
Units T_DP            = deg C
Units e_sat           = kPa
Units e               = kPa
Units rho_d           = g m-3
Units rho_a           = kg m-3
Units CO2_mixratio    = umol/mol
Units H2O_mixratio    = mmol/mol

Dim   Mixratio_kd(2)                             'For CR1000KD display, the 107 temperature is used to compute both mixing ratio 
Alias Mixratio_kd(1)  = CO2_mixratio_kd
Alias Mixratio_kd(2)  = H2O_mixratio_kd
Units CO2_mixratio_kd = umol/mol
Units H2O_mixratio_kd = mmol/mol

Dim CO2_density_slow_tmpr                        'Used for conventional CO2 density in Time_series table 
Dim CO2_density_fast_tmpr                        'Used for alternative CO2 from fast air temperature for spectroscopic effects [see Helbig el al (2016)] 

Dim   diag_irga_aggregate As Long                'Aggregated diagnosis code within an output interval, indicating the occurrence   of all flags.
Units diag_irga_aggregate = adimensional

Dim diag_bits_irga(22) As Boolean                'Gas analyzer warning flags
Alias diag_bits_irga(1)  = irga_bad_data_f       'Gas analyzer bad data warning flag
Alias diag_bits_irga(2)  = irga_gen_fault_f      'General fault warning flag
Alias diag_bits_irga(3)  = irga_startup_f        'Gas analyzer starting up warning flag
Alias diag_bits_irga(4)  = irga_motor_spd_f      'Gas analyzer motor speed out of bounds warning flag
Alias diag_bits_irga(5)  = irga_tec_tmpr_f       'Thermoelectric cooler temperature out of bounds warning flag
Alias diag_bits_irga(6)  = irga_src_pwr_f        'Gas analyzer source power out of bounds warning flag
Alias diag_bits_irga(7)  = irga_src_tmpr_f       'Gas analyzer source temperature out of bounds warning flag
Alias diag_bits_irga(8)  = irga_src_curr_f       'Gas analyzer source current out of bounds warning flag
Alias diag_bits_irga(9)  = irga_off_f            'Gas analyzer head is powered down
Alias diag_bits_irga(10) = irga_sync_f           'Gas analyzer not synchronized with home pulse warning flag
Alias diag_bits_irga(11) = irga_amb_tmpr_f       'Invalid ambient temperature warning flag
Alias diag_bits_irga(12) = irga_amb_press_f      'Invalid ambient pressure warning flag
Alias diag_bits_irga(13) = irga_CO2_I_f          'CO2 I out of bounds warning flag
Alias diag_bits_irga(14) = irga_CO2_Io_f         'CO2 Io out of bounds warning flag
Alias diag_bits_irga(15) = irga_H2O_I_f          'H2O I out of bounds warning flag
Alias diag_bits_irga(16) = irga_H2O_Io_f         'H2O Io out of bounds warning flag
Alias diag_bits_irga(17) = irga_CO2_Io_var_f     'CO2 Io moving variation out of bounds warning flag
Alias diag_bits_irga(18) = irga_H2O_Io_var_f     'H2O Io moving variation out of bounds warning flag
Alias diag_bits_irga(19) = irga_CO2_sig_strgth_f 'CO2 signal strength warning flag
Alias diag_bits_irga(20) = irga_H2O_sig_strgth_f 'H2O signal strength warning flag
Alias diag_bits_irga(21) = irga_cal_err_f        'Gas analyzer calibration data signature error
Alias diag_bits_irga(22) = irga_htr_ctrl_off_f   'Gas analyzer heater control disabled by EC100
Units diag_bits_irga     = adimensional

'*** Working variables
Dim divisor                                      'Temporary variable used to find molar mixing ratio.
Dim diag_irga_tmp  As Long                       'Temporary variable used to break out the EC150 diagnostic bits.
Dim irga_disable_f As Boolean                    'TRUE when Gas analyzer sends bad data.

Dim sigma_wpl                                    'Webb et al. sigma = density of water vapor/density of dry air.
Dim Td_gp, Tc_K                                  'Working variables: Dew point temperature for general use (gu) and Tc in K.
Dim Enhance_Factor1, Enhance_Factor2             'Enhancement factors, both used for calculations of dew point temperature

' *** CO2: Lag maximization
Dim cov_array_CO2(2* MAX_LAG + 1, 5)          'Arrays used to hold the CO2 data with -MAX_LAG,..., -1, 0, 1, ..., MAX_LAG scan lags relative to CSAT data in order to find
'the lag that maximizes the covariance of CO2 with w. Once the optimum lag is found, it is also applied to
'H2O to find the maximum covariance of H2O with w because CO2 and H2O are measured using the same IRGA.
'Data are held in an array for more convenient calculation of covariances.
'Row used for lag of -MAX_LAG,..., -1, 0, 1, ..., MAX_LAG scans. Columns used for CO2_density, Ux, Uy, Uz, and CO2 (umolCO2 mol-1).

Dim irga_bad_data_flg_array (2* MAX_LAG + 1) As Boolean
Dim CO2_bad_rng_sig_array (2* MAX_LAG + 1)   As Boolean    'Set high if CO2 out of range or CO2 signal strength below the CO2 signal strength threshold
Dim H2O_bad_rng_sig_array (2* MAX_LAG + 1)   As Boolean    'Set high if H2O out of range or H2O signal strength below the H2O signal strength threshold

Dim Cov_out_CO2(7*(2*MAX_LAG + 1))                     'CO2 variable and CO2-related covariance variables
'b5 indicates backward 5 scans.
Alias Cov_out_CO2(1)  = CO2_Avg_lag_b5                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(2)  = CO2_Var_lag_b5                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(3)  = CO2_density_Avg_lag_b5         'CO2 in mg m-3  
Alias Cov_out_CO2(4)  = CO2_density_Var_lag_b5         'CO2 in mg m-3  
Alias Cov_out_CO2(5)  = UxCO2_Cov_lag_b5               'CO2 in mg m-3  
Alias Cov_out_CO2(6)  = UyCO2_Cov_lag_b5               'CO2 in mg m-3   
Alias Cov_out_CO2(7)  = UzCO2_Cov_lag_b5               'CO2 in mg m-3  

'b4 indicates backward 4 scans.
Alias Cov_out_CO2(8)  = CO2_Avg_lag_b4                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(9)  = CO2_Var_lag_b4                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(10) = CO2_density_Avg_lag_b4         'CO2 in mg m-3  
Alias Cov_out_CO2(11) = CO2_density_Var_lag_b4         'CO2 in mg m-3  
Alias Cov_out_CO2(12) = UxCO2_Cov_lag_b4               'CO2 in mg m-3  
Alias Cov_out_CO2(13) = UyCO2_Cov_lag_b4               'CO2 in mg m-3   
Alias Cov_out_CO2(14) = UzCO2_Cov_lag_b4               'CO2 in mg m-3  

'b3 indicates backward 3 scans.
Alias Cov_out_CO2(15)  = CO2_Avg_lag_b3                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(16)  = CO2_Var_lag_b3                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(17)  = CO2_density_Avg_lag_b3        'CO2 in mg m-3  
Alias Cov_out_CO2(18)  = CO2_density_Var_lag_b3        'CO2 in mg m-3  
Alias Cov_out_CO2(19)  = UxCO2_Cov_lag_b3              'CO2 in mg m-3  
Alias Cov_out_CO2(20)  = UyCO2_Cov_lag_b3              'CO2 in mg m-3   
Alias Cov_out_CO2(21)  = UzCO2_Cov_lag_b3              'CO2 in mg m-3  

'b2 indicates backward 2 scans.
Alias Cov_out_CO2(22)  = CO2_Avg_lag_b2                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(23)  = CO2_Var_lag_b2                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(24)  = CO2_density_Avg_lag_b2        'CO2 in mg m-3  
Alias Cov_out_CO2(25)  = CO2_density_Var_lag_b2        'CO2 in mg m-3  
Alias Cov_out_CO2(26)  = UxCO2_Cov_lag_b2              'CO2 in mg m-3  
Alias Cov_out_CO2(27)  = UyCO2_Cov_lag_b2              'CO2 in mg m-3   
Alias Cov_out_CO2(28)  = UzCO2_Cov_lag_b2              'CO2 in mg m-3  

'b1 indicates backward 1 scan
Alias Cov_out_CO2(29)  = CO2_Avg_lag_b1                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(30)  = CO2_Var_lag_b1                'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(31) = CO2_density_Avg_lag_b1         'CO2 in mg m-3                
Alias Cov_out_CO2(32) = CO2_density_Var_lag_b1         'CO2 in mg m-3  
Alias Cov_out_CO2(33) = UxCO2_Cov_lag_b1               'CO2 in mg m-3  
Alias Cov_out_CO2(34) = UyCO2_Cov_lag_b1               'CO2 in mg m-3  
Alias Cov_out_CO2(35) = UzCO2_Cov_lag_b1               'CO2 in mg m-3  

'0 indicates neither backward nor forward. 
Alias Cov_out_CO2(36) = CO2_Avg_lag_0                  'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(37) = CO2_Var_Lag_0                  'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(38) = CO2_density_Avg_lag_0          'CO2 in mg m-3      
Alias Cov_out_CO2(39) = CO2_density_Var_lag_0          'CO2 in mg m-3
Alias Cov_out_CO2(40) = UxCO2_Cov_lag_0                'CO2 in mg m-3
Alias Cov_out_CO2(41) = UyCO2_Cov_lag_0                'CO2 in mg m-3
Alias Cov_out_CO2(42) = UzCO2_Cov_lag_0                'CO2 in mg m-3

'f1 indicates forward 1 scan. 
Alias Cov_out_CO2(43) = CO2_Avg_lag_f1                 'CO2 in umolCO2 mol-1 
Alias Cov_out_CO2(44) = CO2_Var_lag_f1                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(45) = CO2_density_Avg_lag_f1         'CO2 in mg m-3            
Alias Cov_out_CO2(46) = CO2_density_Var_lag_f1         'CO2 in mg m-3
Alias Cov_out_CO2(47) = UxCO2_Cov_lag_f1               'CO2 in mg m-3
Alias Cov_out_CO2(48) = UyCO2_Cov_lag_f1               'CO2 in mg m-3
Alias Cov_out_CO2(49) = UzCO2_Cov_lag_f1               'CO2 in mg m-3

'f2 indicates forward 2 scans
Alias Cov_out_CO2(50) = CO2_Avg_lag_f2                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(51) = CO2_Var_lag_f2                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(52) = CO2_density_Avg_f2             'CO2 in mg m-3              
Alias Cov_out_CO2(53) = CO2_density_Var_lag_f2         'CO2 in mg m-3
Alias Cov_out_CO2(54) = UxCO2_Cov_lag_f2               'CO2 in mg m-3
Alias Cov_out_CO2(55) = UyCO2_Cov_lag_f2               'CO2 in mg m-3
Alias Cov_out_CO2(56) = UzCO2_Cov_lag_f2               'CO2 in mg m-3

'f3 indicates forward 3 scans
Alias Cov_out_CO2(57) = CO2_Avg_lag_f3                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(58) = CO2_Var_lag_f3                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(59) = CO2_density_Avg_f3             'CO2 in mg m-3              
Alias Cov_out_CO2(60) = CO2_density_Var_lag_f3         'CO2 in mg m-3
Alias Cov_out_CO2(61) = UxCO2_Cov_lag_f3               'CO2 in mg m-3
Alias Cov_out_CO2(62) = UyCO2_Cov_lag_f3               'CO2 in mg m-3
Alias Cov_out_CO2(63) = UzCO2_Cov_lag_f3               'CO2 in mg m-3

'f4 indicates forward 4 scans
Alias Cov_out_CO2(64) = CO2_Avg_lag_f4                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(65) = CO2_Var_lag_f4                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(66) = CO2_density_Avg_f4             'CO2 in mg m-3              
Alias Cov_out_CO2(67) = CO2_density_Var_lag_f4         'CO2 in mg m-3
Alias Cov_out_CO2(68) = UxCO2_Cov_lag_f4               'CO2 in mg m-3
Alias Cov_out_CO2(69) = UyCO2_Cov_lag_f4               'CO2 in mg m-3
Alias Cov_out_CO2(70) = UzCO2_Cov_lag_f4               'CO2 in mg m-3

'f5 indicates forward 5 scans
Alias Cov_out_CO2(71) = CO2_Avg_lag_f5                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(72) = CO2_Var_lag_f5                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(73) = CO2_density_Avg_f5             'CO2 in mg m-3              
Alias Cov_out_CO2(74) = CO2_density_Var_lag_f5         'CO2 in mg m-3
Alias Cov_out_CO2(75) = UxCO2_Cov_lag_f5               'CO2 in mg m-3
Alias Cov_out_CO2(76) = UyCO2_Cov_lag_f5               'CO2 in mg m-3
Alias Cov_out_CO2(77) = UzCO2_Cov_lag_f5               'CO2 in mg m-3

'*** Variables after coordinate rotations as indicated by W for Uz
Dim   WCO2_Cov_lag (2*MAX_LAG + 1)                     'Hold covariance of scan-lagged CO2 with W after coordinate rotation. Used for MaxSpa instruction
Alias WCO2_Cov_lag (1)  = WCO2_Cov_lag_b5              'b5 indicates backward 5 scans.
Alias WCO2_Cov_lag (2)  = WCO2_Cov_lag_b4              'b4 indicates backward 4 scans.
Alias WCO2_Cov_lag (3)  = WCO2_Cov_lag_b3              'b3 indicates backward 3 scans.
Alias WCO2_Cov_lag (4)  = WCO2_Cov_lag_b2              'b2 indicates backward 2 scans.
Alias WCO2_Cov_lag (5)  = WCO2_Cov_lag_b1              'b1 indicates backward 1 scans.
Alias WCO2_Cov_lag (6)  = WCO2_Cov_lag_0               '0 indicates 0 lag in scans.
Alias WCO2_Cov_lag (7)  = WCO2_Cov_lag_f1              'f1 indicates forward 1 scans.
Alias WCO2_Cov_lag (8)  = WCO2_Cov_lag_f2              'f2 indicates forward 2 scans.
Alias WCO2_Cov_lag (9)  = WCO2_Cov_lag_f3              'f2 indicates forward 3 scans.
Alias WCO2_Cov_lag (10) = WCO2_Cov_lag_f4              'f2 indicates forward 4 scans.
Alias WCO2_Cov_lag (11) = WCO2_Cov_lag_f5              'f2 indicates forward 5 scans.

Dim WCO2_Cov_major_sign                                'Summarize the direction of CO2 flux (positive: up and negative: down)

'*** Variables after coordinate rotations as indicated by U for Ux and by V for Uy
Dim   UCO2_VCO2_Cov_lag(2*MAX_LAG + 1, 2)              'Hold the covariance of scan-lagged CO2 with U or V after coordinate rotation
Alias UCO2_VCO2_Cov_lag(1, 1)  = UCO2_Cov_lag_b5       'b5 indicates backward 5 scans. 
Alias UCO2_VCO2_Cov_lag(1, 2)  = VCO2_Cov_lag_b5
Alias UCO2_VCO2_Cov_lag(2, 1)  = UCO2_Cov_lag_b4       'b4 indicates backward 4 scans. 
Alias UCO2_VCO2_Cov_lag(2, 2)  = VCO2_Cov_lag_b4
Alias UCO2_VCO2_Cov_lag(3, 1)  = UCO2_Cov_lag_b3       'b3 indicates backward 3 scans. 
Alias UCO2_VCO2_Cov_lag(3, 2)  = VCO2_Cov_lag_b3
Alias UCO2_VCO2_Cov_lag(4, 1)  = UCO2_Cov_lag_b2       'b2 indicates backward 2 scans. 
Alias UCO2_VCO2_Cov_lag(4, 2)  = VCO2_Cov_lag_b2
Alias UCO2_VCO2_Cov_lag(5, 1)  = UCO2_Cov_lag_b1       'b1 indicates backward 1 scans.
Alias UCO2_VCO2_Cov_lag(5, 2)  = VCO2_Cov_lag_b1
Alias UCO2_VCO2_Cov_lag(6, 1)  = UCO2_Cov_lag_0        '0  indicates 0 lag in scans.
Alias UCO2_VCO2_Cov_lag(6, 2)  = VCO2_Cov_lag_0
Alias UCO2_VCO2_Cov_lag(7, 1)  = UCO2_Cov_lag_f1       'f1 indicates forward 1 scans.
Alias UCO2_VCO2_Cov_lag(7, 2)  = VCO2_Cov_lag_f1
Alias UCO2_VCO2_Cov_lag(8, 1)  = UCO2_Cov_lag_f2       'f2 indicates forward 2 scans.
Alias UCO2_VCO2_Cov_lag(8, 2)  = VCO2_Cov_lag_f2
Alias UCO2_VCO2_Cov_lag(9, 1)  = UCO2_Cov_lag_f3       'f3 indicates forward 3 scans.
Alias UCO2_VCO2_Cov_lag(9, 2)  = VCO2_Cov_lag_f3
Alias UCO2_VCO2_Cov_lag(10, 1) = UCO2_Cov_lag_f4       'f4 indicates forward 4 scans.
Alias UCO2_VCO2_Cov_lag(10, 2) = VCO2_Cov_lag_f4
Alias UCO2_VCO2_Cov_lag(11, 1) = UCO2_Cov_lag_f5       'f5 indicates forward 5 scans.
Alias UCO2_VCO2_Cov_lag(11, 2) = VCO2_Cov_lag_f5
Units UCO2_VCO2_Cov_lag        = mg m-2 s-1

Dim   WCO2_Cov_lag_max (2)                            'Array used in MaxSpa instruction to hold the max covariance and the location of the max covariance in array: WCO2_Cov_lag_R()
Alias WCO2_Cov_lag_max (1) = WCO2_Cov                 'Max covariance found from lagged covariance array [i.e., wCO2_cov_lag_R()] and will be used for CO2 flux after freq correction
Alias WCO2_Cov_lag_max (2) = lag_irga                 'Lag in number of scans, also used for sequential number in array index of lag in UCO2_UCO2_Cov_lag_R()
Units WCO2_Cov             = mg m-2 s-1
Units lag_irga             = scans

'*** H2O: Lag maximization
Dim cov_array_H2O(2*MAX_LAG+1, 5)  'Arrays used to hold the H2O data with -MAX_LAG, ... -1, 0, 1, ..., MAX_LAG scan lags relative to CSAT data. The optimum lag_irga found during maximization
'of covariance of CO2 with W is assumed to also be the optimum lag for H2O data since the same IRGA measures both CO2 and H2O in an open measurement volume.
'Data are held in an array for more convenient calculation of covariances.
'Row used for lag of -MAX_LAG, ... -1, 0, 1, ..., MAX_LAG scans. Columns used for H2O_density, Ux, Uy, and Uz, H2O (mmolH2O mol-1).

Dim Cov_out_H2O(7*(2*MAX_LAG + 1))                     'H2O variables and H2O-related covariances
'b5 indicates backward 5 scans
Alias Cov_out_H2O(1)  = H2O_Avg_lag_b5                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(2)  = H2O_Var_lag_b5                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(3)  = H2O_density_Avg_lag_b5         'H2O in g m-3
Alias Cov_out_H2O(4)  = H2O_density_Var_lag_b5         'H2O in g m-3
Alias Cov_out_H2O(5)  = UxH2O_Cov_lag_b5               'H2O in g m-3
Alias Cov_out_H2O(6)  = UyH2O_Cov_lag_b5               'H2O in g m-3
Alias Cov_out_H2O(7)  = UzH2O_Cov_lag_b5               'H2O in g m-3

'b4 indicates backward 4 scans
Alias Cov_out_H2O(8)  = H2O_Avg_lag_b4                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(9)  = H2O_Var_lag_b4                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(10) = H2O_density_Avg_lag_b4         'H2O in g m-3
Alias Cov_out_H2O(11) = H2O_density_Var_lag_b4         'H2O in g m-3
Alias Cov_out_H2O(12) = UxH2O_Cov_lag_b4               'H2O in g m-3
Alias Cov_out_H2O(13) = UyH2O_Cov_lag_b4               'H2O in g m-3
Alias Cov_out_H2O(14) = UzH2O_Cov_lag_b4               'H2O in g m-3

'b3 indicates backward 3 scans
Alias Cov_out_H2O(15)  = H2O_Avg_lag_b3                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(16)  = H2O_Var_lag_b3                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(17)  = H2O_density_Avg_lag_b3         'H2O in g m-3
Alias Cov_out_H2O(18)  = H2O_density_Var_lag_b3         'H2O in g m-3
Alias Cov_out_H2O(19)  = UxH2O_Cov_lag_b3               'H2O in g m-3
Alias Cov_out_H2O(20)  = UyH2O_Cov_lag_b3               'H2O in g m-3
Alias Cov_out_H2O(21)  = UzH2O_Cov_lag_b3               'H2O in g m-3

'b2 indicates backward 2 scans
Alias Cov_out_H2O(22)  = H2O_Avg_lag_b2                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(23)  = H2O_Var_lag_b2                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(24)  = H2O_density_Avg_lag_b2         'H2O in g m-3
Alias Cov_out_H2O(25)  = H2O_density_Var_lag_b2         'H2O in g m-3
Alias Cov_out_H2O(26)  = UxH2O_Cov_lag_b2               'H2O in g m-3
Alias Cov_out_H2O(27)  = UyH2O_Cov_lag_b2               'H2O in g m-3
Alias Cov_out_H2O(28)  = UzH2O_Cov_lag_b2               'H2O in g m-3

'b1 indicates backward 1 scan
Alias Cov_out_H2O(29) = H2O_Avg_lag_b1                  'H2O in mmolH2O mol-1
Alias Cov_out_H2O(30) = H2O_Var_lag_b1                  'H2O in mmolH2O mol-1
Alias Cov_out_H2O(31) = H2O_density_Avg_lag_b1          'H2O in g m-3    
Alias Cov_out_H2O(32) = H2O_density_Var_lag_b1          'H2O in g m-3
Alias Cov_out_H2O(33) = UxH2O_Cov_lag_b1                'H2O in g m-3
Alias Cov_out_H2O(34) = UyH2O_Cov_lag_b1                'H2O in g m-3
Alias Cov_out_H2O(35) = UzH2O_Cov_lag_b1                'H2O in g m-3

'0 indicates neither backward nor forward
Alias Cov_out_H2O(36) = H2O_Avg_lag_0                  'H2O in mmolH2O mol-1
Alias Cov_out_H2O(37) = H2O_Var_lag_0                  'H2O in mmolH2O mol-1
Alias Cov_out_H2O(38) = H2O_density_Avg_lag_0          'H2O in g m-3    
Alias Cov_out_H2O(39) = H2O_density_Var_lag_0          'H2O in g m-3
Alias Cov_out_H2O(40) = UxH2O_Cov_lag_0                'H2O in g m-3
Alias Cov_out_H2O(41) = UyH2O_Cov_lag_0                'H2O in g m-3
Alias Cov_out_H2O(42) = UzH2O_Cov_lag_0                'H2O in g m-3

'f1 indicates forward 1 scan
Alias Cov_out_H2O(43) = H2O_Avg_lag_f1                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(44) = H2O_Var_lag_f1                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(45) = H2O_density_Avg_lag_f1         'H2O in g m-3    
Alias Cov_out_H2O(46) = H2O_density_Var_lag_f1         'H2O in g m-3
Alias Cov_out_H2O(47) = UxH2O_Cov_lag_f1               'H2O in g m-3
Alias Cov_out_H2O(48) = UyH2O_Cov_lag_f1               'H2O in g m-3
Alias Cov_out_H2O(49) = UzH2O_Cov_lag_f1               'H2O in g m-3

'f2 indicates forward 2 scans
Alias Cov_out_H2O(50) = H2O_Avg_lag_f2                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(51) = H2O_Var_lag_f2                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(52) = H2O_density_Avg_lag_f2         'H2O in g m-3    
Alias Cov_out_H2O(53) = H2O_density_Var_lag_f2         'H2O in g m-3
Alias Cov_out_H2O(54) = UxH2O_Cov_lag_f2               'H2O in g m-3
Alias Cov_out_H2O(55) = UyH2O_Cov_lag_f2               'H2O in g m-3
Alias Cov_out_H2O(56) = UzH2O_Cov_lag_f2               'H2O in g m-3

'f3 indicates forward 3 scans
Alias Cov_out_H2O(57) = H2O_Avg_lag_f3                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(58) = H2O_Var_lag_f3                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(59) = H2O_density_Avg_lag_f3         'H2O in g m-3    
Alias Cov_out_H2O(60) = H2O_density_Var_lag_f3         'H2O in g m-3
Alias Cov_out_H2O(61) = UxH2O_Cov_lag_f3               'H2O in g m-3
Alias Cov_out_H2O(62) = UyH2O_Cov_lag_f3               'H2O in g m-3
Alias Cov_out_H2O(63) = UzH2O_Cov_lag_f3               'H2O in g m-3

'f4 indicates forward 4 scans
Alias Cov_out_H2O(64) = H2O_Avg_lag_f4                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(65) = H2O_Var_lag_f4                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(66) = H2O_density_Avg_lag_f4         'H2O in g m-3    
Alias Cov_out_H2O(67) = H2O_density_Var_lag_f4         'H2O in g m-3
Alias Cov_out_H2O(68) = UxH2O_Cov_lag_f4               'H2O in g m-3
Alias Cov_out_H2O(69) = UyH2O_Cov_lag_f4               'H2O in g m-3
Alias Cov_out_H2O(70) = UzH2O_Cov_lag_f4               'H2O in g m-3

'f5 indicates forward 5 scans
Alias Cov_out_H2O(71) = H2O_Avg_lag_f5                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(72) = H2O_Var_lag_f5                 'H2O in mmolH2O mol-1
Alias Cov_out_H2O(73) = H2O_density_Avg_lag_f5         'H2O in g m-3    
Alias Cov_out_H2O(74) = H2O_density_Var_lag_f5         'H2O in g m-3
Alias Cov_out_H2O(75) = UxH2O_Cov_lag_f5               'H2O in g m-3
Alias Cov_out_H2O(76) = UyH2O_Cov_lag_f5               'H2O in g m-3
Alias Cov_out_H2O(77) = UzH2O_Cov_lag_f5               'H2O in g m-3

'*** Before coordinate rotation (If measured by EC150+CSAT3A, lag due to separation is used to locate the covariance although it was found after coordinate rotation).  
Dim Cov_out_cs(29)                                     'IRGA statistics.
Alias Cov_out_cs(1)  = CO2                             'Average CO2 mixing ratio in umolCO2 mol-1
Alias Cov_out_cs(2)  = CO2_SIGMA                       'CO2 mixing ratio standard deviation in umolCO2 mol-1
Alias Cov_out_cs(3)  = CO2_density_Avg                 'Average CO2 mass density in mg m-3
Alias Cov_out_cs(4)  = CO2_density_SIGMA               'CO2 mass density standard deviation in mg m-3
Alias Cov_out_cs(5)  = UxCO2_Cov                       'Covariance of CO2 mass density with Ux in mg m-2 s-1
Alias Cov_out_cs(6)  = UyCO2_Cov                       'Covariance of CO2 mass density with Uy in mg m-2 s-1
Alias Cov_out_cs(7)  = UzCO2_Cov                       'Covariance of CO2 mass density with Uz in mg m-2 s-1
Alias Cov_out_cs(8)  = H2O                             'Average H2O mixing ratio in mmolH2O mol-1
Alias Cov_out_cs(9)  = H2O_SIGMA                       'H2O mixing ratio standard deviation in mmolH2O mol-1
Alias Cov_out_cs(10) = H2O_density_Avg                 'Average H2O mass density in g m-3
Alias Cov_out_cs(11) = H2O_density_SIGMA               'H2O mass density standard deviation in g m-3
Alias Cov_out_cs(12) = UxH2O_Cov                       'Covariance of H2O mass density with Ux in g m-2 s-1
Alias Cov_out_cs(13) = UyH2O_Cov                       'Covariance of H2O mass density with Uy in g m-2 s-1
Alias Cov_out_cs(14) = UzH2O_Cov                       'Covariance of H2O mass density with Uz in g m-2 s-1
Alias Cov_out_cs(15) = TA_1_1_1                        'Average temperature from 107-probe connected to EC100
Alias Cov_out_cs(16) = RH_1_1_1                        'Average relative humidity (%): derived from 107 probe temperature (T_amb), H2O, and press_amb
Alias Cov_out_cs(17) = T_DP_1_1_1                      'Average dew point temperature (C): derived from 107 probe temperature (T_amb), H2O, and press_amb
Alias Cov_out_cs(18) = e_sat_amb_Avg                   'Average saturation vapor pressure (kPa): derived from T_amb, H2O, and press_amb
Alias Cov_out_cs(19) = e_amb_Avg                       'Average vapor pressure (kPa): derived from T_amb, H2O, and press_amb
Alias Cov_out_cs(20) = rho_d_amb_Avg                   'Density of dry air (g/m^3). calculated using the average data of T_amb, H2O, and press_amb
Alias Cov_out_cs(21) = rho_a_amb_Avg                   'Density of moist air (kg/m^3). calculated using the average data of T_amb, H2O, and press_amb
Alias Cov_out_cs(22) = TA_1_1_2                        'Average air temperature (C), found from IRGASON sonic temperature, H2O, and press_amb
Alias Cov_out_cs(23) = RH_1_1_2                        'Average relative humidity (%): derived from IRGASON sonic temperature, H2O, and press_amb
Alias Cov_out_cs(24) = T_DP_1_1_2                      'Average dew point temperature (C): derived from IRGASON sonic temperature, H2O, and press_amb
Alias Cov_out_cs(25) = e_sat_Avg                       'Average saturation vapor pressure (kPa): derived from Tc, H2O, and press_amb
Alias Cov_out_cs(26) = e_Avg                           'Average vapor pressure (kPa): derived from Tc, H2O, and press_amb
Alias Cov_out_cs(27) = rho_d_Avg                       'Density of dry air (g/m^3). calculated using the average data of Tc, H2O, and press_amb
Alias Cov_out_cs(28) = rho_a_Avg                       'Density of moist air (kg/m^3). calculated using the average data of Tc, H2O, and press_amb
Alias Cov_out_cs(29) = PA                              'Average atmospheric pressure 
Units CO2               = umolCO2 mol-1
Units CO2_SIGMA         = umolCO2 mol-1
Units CO2_density_Avg   = mg m-3
Units CO2_density_SIGMA = mg m-3
Units UxCO2_Cov         = mg m-2 s-1
Units UyCO2_Cov         = mg m-2 s-1
Units UzCO2_Cov         = mg m-2 s-1
Units H2O               = mmolH2O mol-1
Units H2O_SIGMA         = mmolH2O mol-1
Units H2O_density_Avg   = g m-3
Units H2O_density_SIGMA = g m-3
Units UxH2O_Cov         = g m-2 s-1
Units UyH2O_Cov         = g m-2 s-1
Units UzH2O_Cov         = g m-2 s-1
Units TA_1_1_1          = deg C
Units RH_1_1_1          = %
Units T_DP_1_1_1        = deg C
Units e_sat_amb_Avg     = kPa
Units e_amb_Avg         = kPa
Units rho_d_amb_Avg     = g m-3
Units rho_a_amb_Avg     = kg m-3
Units TA_1_1_2          = deg C
Units RH_1_1_2          = %
Units T_DP_1_1_2        = deg C
Units e_sat_Avg         = kPa
Units e_Avg             = kPa
Units rho_d_Avg         = g m-3
Units rho_a_Avg         = kg m-3
Units PA                = kPa

Dim    VPD                                               'ambient water vapor pressure deficit
Units  VPD = hPa

'*** After coordinate rotations as indicated by U for Ux, V for Uy and W for Uz
Dim UCO2_Cov
Dim VCO2_Cov
'For WCO2_Cov, see WCO2_Cov_lag_max (1)
Units UCO2_Cov  = mg m-2 s-1
Units VCO2_Cov  = mg m-2 s-1

Dim UH2O_Cov
Dim VH2O_Cov
Dim WH2O_Cov                        'Found using lag_irga that was found while WCO2_cov was found
Units UH2O_Cov  = g m-2 s-1
Units VH2O_Cov  = g m-2 s-1
Units WH2O_Cov  = g m-2 s-1

' *** After coordinate rotations and freq corrections as indicated by "fc"
Dim WCO2_Cov_fc
Dim WH2O_Cov_fc
Units WCO2_Cov_fc = mg m-2 s-1
Units WH2O_Cov_fc = g m-2 s-1

' *** WPL correction terms after coordinate rotations and freq corrections as indicated by "WPL_fc"
Dim CO2_E_WPL_fc                    'Carbon dioxide flux, WPL term due to water vapor flux (covariance of water vapor with vertical velocity)
Dim CO2_T_WPL_fc                    'Carbon dioxide flux, WPL term due to temperature flux (covariance of temperature with vertical velocity)
Dim H2O_E_WPL_fc                    'Water vapor flux, WPL term due to water vapor flux (covariance of water vapor with vertical velocity)
Dim H2O_T_WPL_fc                    'Water vapor flux, WPL term due to temperature flux (covariance of temperature with vertical velocity)
Units CO2_E_WPL_fc = mg m-2 s-1
Units CO2_T_WPL_fc = mg m-2 s-1
Units H2O_E_WPL_fc = g m-2 s-1
Units H2O_T_WPL_fc = g m-2 s-1

' *** After coordinate rotations, freq corrections, and WPL correction
Dim FC                             'Carbon dioxide flux after coordinate rotation, freq, and WPL corrections in umol/(m^2 s)
Dim FC_mass                        'Carbon dioxide flux after coordinate rotation, freq, and WPL corrections in mg/(m^2 s)
Dim LE                             'Latent heat flux after coordinate rotation, freq, and WPL corrections
Dim ET                             'Evapotranspiration 
Units FC      = umolCO2 m-2 s-1
Units FC_mass = mg m-2 s-1
Units LE      = W m-2
Units ET      = mm hour-1

Dim    Bowen_ratio
Units  Bowen_ratio = fraction

'*** Variables for data QC
' Steady State Test
Dim RN_WCO2_Cov                   'Relative Non-stationarity (RN) for wCO2_cov_R.
Dim RN_WH2O_Cov                   'Relative non-stationarity for wH2O_cov_R.
Dim nmbr_interval_qc_irga         'Number of sub-intervals = (OUTPUT_INTV in min)/(5 min)

Dim cov_out_irga_SST(8)             'IRGA statistics for Steady State Test (SST)
Alias cov_out_irga_SST(1) = CO2_density_var_SST
Alias cov_out_irga_SST(2) = UxCO2_Cov_SST
Alias cov_out_irga_SST(3) = UyCO2_Cov_SST
Alias cov_out_irga_SST(4) = UzCO2_Cov_SST
Alias cov_out_irga_SST(5) = H2O_density_var_SST
Alias cov_out_irga_SST(6) = UxH2O_Cov_SST
Alias cov_out_irga_SST(7) = UyH2O_Cov_SST
Alias cov_out_irga_SST(8) = UzH2O_Cov_SST

' After coordinate rotations
Dim UCO2_Cov_SST
Dim VCO2_Cov_SST
Dim WCO2_Cov_SST
Dim UH2O_Cov_SST
Dim VH2O_Cov_SST
Dim WH2O_Cov_SST

' Overall grade of data quality for CO2 and H2O fluxes
Dim    FC_SSITC_TEST                 'Results of the Steady State and Integral Turbulence Characteristics for FC according to Foken et al (2004)
Dim    LE_SSITC_TEST                 'Results of the Steady State and Integral Turbulence Characteristics for LE according to Foken et al (2004)
Units  FC_SSITC_TEST = adimensional
Units  LE_SSITC_TEST = adimensional

Dim    FC_QC                         'Overall grade of data quality for CO2 flux (i.e., for variable: FC and FC_mass) [1 (highest) to 9 (lowest)]
Dim    LE_QC                         'Overall grade of data quality for latent heat flux (LE) and evapotranspiration (ET) [1 (highest) to 9 (lowest)]
Units  FC_QC = Grade
Units  LE_QC = Grade

'*** Data table for delayed data from IRGA
DataTable (delay_cs, TRUE, (OFFSET + MAX_LAG))
  TableHide
  Sample (1,sonic_irga_raw(6), IEEE4)   'conventional CO2 if CO2_fast_T is false; otherwise, Helbig et al. (2016) CO2 density
  Sample (1,sonic_irga_raw(7), IEEE4)   'H2O
  Sample (1,sonic_irga_raw(8), IEEE4)   'diag_irga
  Sample (4,sonic_irga_raw(9), IEEE4)   'T_amb, press_amb, CO2_sig_strgth, and H2O_sig_strgth
  Sample (1,sonic_irga_raw(13),IEEE4)   'conventional CO2 if CO2_fast_T is true; otherwise, Helbig et al. (2016) CO2 density
EndTable


'*** 5-minute statistics
DataTable (comp_cov_cs_5min, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL_SST, Min, 0)
  
  Covariance (4, cov_array_CO2((MAX_LAG + 1), 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(MAX_LAG + 1) OR CO2_bad_rng_sig_array(MAX_LAG+1)),4)
  Covariance (4, cov_array_H2O((MAX_LAG + 1), 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(MAX_LAG + 1) OR H2O_bad_rng_sig_array(MAX_LAG+1)),4)

EndTable

'*** Compute covariance of CO2 against CSAT wind data.
DataTable (comp_cov_CO2, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average    (1, cov_array_CO2(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(1, 1), IEEE4, (irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)))
  Covariance (4, cov_array_CO2(1, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)),4)

  Average    (1, cov_array_CO2(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(2, 1), IEEE4, (irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)))
  Covariance (4, cov_array_CO2(2, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)),4)

  Average    (1, cov_array_CO2(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(3, 1), IEEE4, (irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)))
  Covariance (4, cov_array_CO2(3, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)),4)

  Average    (1, cov_array_CO2(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(4, 1), IEEE4, (irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)))
  Covariance (4, cov_array_CO2(4, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)),4)

  Average    (1, cov_array_CO2(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(5, 1), IEEE4, (irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)))
  Covariance (4, cov_array_CO2(5, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)),4)

  Average    (1, cov_array_CO2(6, 5), IEEE4, (irga_bad_data_flg_array(6) OR CO2_bad_rng_sig_array(6)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(6, 5), IEEE4, (irga_bad_data_flg_array(6) OR CO2_bad_rng_sig_array(6)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(6, 1), IEEE4, (irga_bad_data_flg_array(6) OR CO2_bad_rng_sig_array(6)))
  Covariance (4, cov_array_CO2(6, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(6) OR CO2_bad_rng_sig_array(6)),4)
  
  Average    (1, cov_array_CO2(7, 5), IEEE4, (irga_bad_data_flg_array(7) OR CO2_bad_rng_sig_array(7)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(7, 5), IEEE4, (irga_bad_data_flg_array(7) OR CO2_bad_rng_sig_array(7)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(7, 1), IEEE4, (irga_bad_data_flg_array(7) OR CO2_bad_rng_sig_array(7)))
  Covariance (4, cov_array_CO2(7, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(7) OR CO2_bad_rng_sig_array(7)),4)
  
  Average    (1, cov_array_CO2(8, 5), IEEE4, (irga_bad_data_flg_array(8) OR CO2_bad_rng_sig_array(8)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(8, 5), IEEE4, (irga_bad_data_flg_array(8) OR CO2_bad_rng_sig_array(8)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(8, 1), IEEE4, (irga_bad_data_flg_array(8) OR CO2_bad_rng_sig_array(8)))
  Covariance (4, cov_array_CO2(8, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(8) OR CO2_bad_rng_sig_array(8)),4)

  Average    (1, cov_array_CO2(9, 5), IEEE4, (irga_bad_data_flg_array(9) OR CO2_bad_rng_sig_array(9)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(9, 5), IEEE4, (irga_bad_data_flg_array(9) OR CO2_bad_rng_sig_array(9)),1)                      'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(9, 1), IEEE4, (irga_bad_data_flg_array(9) OR CO2_bad_rng_sig_array(9)))
  Covariance (4, cov_array_CO2(9, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(9) OR CO2_bad_rng_sig_array(9)),4)

  Average    (1, cov_array_CO2(10, 5), IEEE4, (irga_bad_data_flg_array(10) OR CO2_bad_rng_sig_array(10)))                     'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(10, 5), IEEE4, (irga_bad_data_flg_array(10) OR CO2_bad_rng_sig_array(10)),1)                   'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(10, 1), IEEE4, (irga_bad_data_flg_array(10) OR CO2_bad_rng_sig_array(10)))
  Covariance (4, cov_array_CO2(10, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(10) OR CO2_bad_rng_sig_array(10)),4)

  Average    (1, cov_array_CO2(11, 5), IEEE4, (irga_bad_data_flg_array(11) OR CO2_bad_rng_sig_array(11)))                     'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(11, 5), IEEE4, (irga_bad_data_flg_array(11) OR CO2_bad_rng_sig_array(11)),1)                   'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(11, 1), IEEE4, (irga_bad_data_flg_array(11) OR CO2_bad_rng_sig_array(11)))
  Covariance (4, cov_array_CO2(11, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(11) OR CO2_bad_rng_sig_array(11)),4)

EndTable

'*** Compute covariance of H2O against CSAT wind data.
DataTable (comp_cov_H2O, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average    (1, cov_array_H2O(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(1, 1), IEEE4, (irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)))
  Covariance (4, cov_array_H2O(1, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)),4)

  Average    (1, cov_array_H2O(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(2, 1), IEEE4, (irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)))
  Covariance (4, cov_array_H2O(2, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)),4)

  Average    (1, cov_array_H2O(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(3, 1), IEEE4, (irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)))
  Covariance (4, cov_array_H2O(3, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)),4)

  Average    (1, cov_array_H2O(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(4, 1), IEEE4, (irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)))
  Covariance (4, cov_array_H2O(4, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)),4)

  Average    (1, cov_array_H2O(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(5, 1), IEEE4, (irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)))
  Covariance (4, cov_array_H2O(5, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)),4)

  Average    (1, cov_array_H2O(6, 5), IEEE4, (irga_bad_data_flg_array(6) OR H2O_bad_rng_sig_array(6)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(6, 5), IEEE4, (irga_bad_data_flg_array(6) OR H2O_bad_rng_sig_array(6)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(6, 1), IEEE4, (irga_bad_data_flg_array(6) OR H2O_bad_rng_sig_array(6)))
  Covariance (4, cov_array_H2O(6, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(6) OR H2O_bad_rng_sig_array(6)),4)

  Average    (1, cov_array_H2O(7, 5), IEEE4, (irga_bad_data_flg_array(7) OR H2O_bad_rng_sig_array(7)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(7, 5), IEEE4, (irga_bad_data_flg_array(7) OR H2O_bad_rng_sig_array(7)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(7, 1), IEEE4, (irga_bad_data_flg_array(7) OR H2O_bad_rng_sig_array(7)))
  Covariance (4, cov_array_H2O(7, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(7) OR H2O_bad_rng_sig_array(7)),4)
  
  Average    (1, cov_array_H2O(8, 5), IEEE4, (irga_bad_data_flg_array(8) OR H2O_bad_rng_sig_array(8)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(8, 5), IEEE4, (irga_bad_data_flg_array(8) OR H2O_bad_rng_sig_array(8)),1)                      'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(8, 1), IEEE4, (irga_bad_data_flg_array(8) OR H2O_bad_rng_sig_array(8)))
  Covariance (4, cov_array_H2O(8, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(8) OR H2O_bad_rng_sig_array(8)),4)
  
  Average    (1, cov_array_H2O(9, 5), IEEE4, (irga_bad_data_flg_array(9) OR H2O_bad_rng_sig_array(9)))                       'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(9, 5), IEEE4, (irga_bad_data_flg_array(9) OR H2O_bad_rng_sig_array(9)),1)                     'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(9, 1), IEEE4, (irga_bad_data_flg_array(9) OR H2O_bad_rng_sig_array(9))
  Covariance (4, cov_array_H2O(9, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(9) OR H2O_bad_rng_sig_array(9)),4)
  
  Average    (1, cov_array_H2O(10, 5), IEEE4, (irga_bad_data_flg_array(10) OR H2O_bad_rng_sig_array(10)))                    'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(10, 5), IEEE4, (irga_bad_data_flg_array(10) OR H2O_bad_rng_sig_array(10)),1)                  'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(10, 1), IEEE4, (irga_bad_data_flg_array(10) OR H2O_bad_rng_sig_array(10)))
  Covariance (4, cov_array_H2O(10, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(10) OR H2O_bad_rng_sig_array(10)),4)
  
  Average    (1, cov_array_H2O(11, 5), IEEE4, (irga_bad_data_flg_array(11) OR H2O_bad_rng_sig_array(11)))                    'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(11, 5), IEEE4, (irga_bad_data_flg_array(11) OR H2O_bad_rng_sig_array(11)),1)                  'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(11, 1), IEEE4, (irga_bad_data_flg_array(11) OR H2O_bad_rng_sig_array(11)))
  Covariance (4, cov_array_H2O(11, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(11) OR H2O_bad_rng_sig_array(11)),4)
EndTable

'*** Compute Tc-related data.
DataTable (comp_mean, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)
  Average (1, T_amb, IEEE4, irga_amb_tmpr_f)
  Average (1, RH_amb,   IEEE4, (irga_disable_f OR (RH_amb > 102) OR H2O_bad_rng_sig_array(MAX_LAG +1))
  Average (5, T_DP_amb, IEEE4, (irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1))                                         'T_DP_amb, e_sat_amb, e_amb, rho_d_amb, rho_a_amb
  
  Average (1, Tc,       IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1))
  Average (1, RH,       IEEE4, (irga_disable_f OR sonic_disable_f OR (RH > 102) OR H2O_bad_rng_sig_array(MAX_LAG +1))
  Average (5, T_DP,     IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1))                      'T_DP, e_sat, e, rho_d, rho_a

  Average (1, press_amb, IEEE4, irga_amb_press_f)

EndTable
'******* END OF IRGA CONSTANTS, VARIABLES, AND WORKING DATA TABLES *******


#If (SENSOR_FW) Then  
'*************************************************************************
'***** BEGINNING OF FW: CONSTANTS, VARIABLES, AND WORKING DATA TABLE *****
'*************************************************************************
'*** Variables 
Dim    time_const_FW = 0.001            'Default value (seconds). It will be recalculated inside the program
Units  time_const_FW = s

Public FW                               'Air temperature measured using a fine wire thermocouple of FW05, FW1, FW2, or FW3
Units  FW = deg C

'Raw and not lagged FW data.
Dim FW_raw                              'Air temperature measured using a fine wire thermocouple of FW05, FW1, FW2, or FW3
Dim diag_FW_raw                         'Boolean type is not used because this variable is an element of numerical array: dly_data_out() 
Dim dly_data_FW_out(2)                  'Array used to temporarily store the lagged record from the raw data table for FW measurements (hidden)

Dim    separation_lat_dist_FW           'Effective separation distance in direction normal to wind direction. Used for separation correction.    
Dim    separation_lag_dist_FW           'Effective separation distance along wind direction. Used for time lag maximization.  
Dim    separation_lag_scan_FW           'Lag in scan number. Wind passing FW after (+) or before (-) passing CSAT. Not necessary to use an integer.
Units  separation_lat_dist_FW = m 
Units  separation_lag_dist_FW = m
Units  separation_lag_scan_FW = scans

Dim Cov_array_FW(2* MAX_LAG + 1, 4)      'Arrays used to hold the FW data with -MAX_LAG,..., -1, 0, 1, ..., MAX_LAG in scan lags relative to CSAT data in order 
                                         'to find the max covariance of FW with Uz using lag_FW found in maximization for covariance of FW with Uz
                                         'In form of array for use in the COVARIANCE instructions. 
                                         'Row for lag -MAX_LAG,..., -1, 0, 1, ..., MAX_LAG scans, column: FW, Ux, Uy, and Uz.   
Dim FW_bad_data_flg (2* MAX_LAG + 1) As Boolean

Dim Cov_out_FW(6*(2*MAX_LAG + 1))                'FW statistics and FW-related covariance
'b5 indicates backward 5 scans 
Alias Cov_out_FW(1)  = FW_Avg_lag_b5                 
Alias Cov_out_FW(2)  = FW_Var_lag_b5   
Alias Cov_out_FW(3)  = UxFW_Cov_lag_b5
Alias Cov_out_FW(4)  = UyFW_Cov_lag_b5
Alias Cov_out_FW(5)  = UzFW_Cov_lag_b5
Alias Cov_out_FW(6)  = nmbr_smpl_FW_lag_b5

'b4 indicates backward 4 scans 
Alias Cov_out_FW(7)  = FW_Avg_lag_b4                 
Alias Cov_out_FW(8)  = FW_Var_lag_b4   
Alias Cov_out_FW(9)  = UxFW_Cov_lag_b4
Alias Cov_out_FW(10)  = UyFW_Cov_lag_b4
Alias Cov_out_FW(11)  = UzFW_Cov_lag_b4
Alias Cov_out_FW(12)  = nmbr_smpl_FW_lag_b4

'b3 indicates backward 3 scans 
Alias Cov_out_FW(13)  = FW_Avg_lag_b3                 
Alias Cov_out_FW(14)  = FW_Var_lag_b3   
Alias Cov_out_FW(15)  = UxFW_Cov_lag_b3
Alias Cov_out_FW(16)  = UyFW_Cov_lag_b3
Alias Cov_out_FW(17)  = UzFW_Cov_lag_b3
Alias Cov_out_FW(18)  = nmbr_smpl_FW_lag_b3

'b2 indicates backward 2 scans 
Alias Cov_out_FW(19)  = FW_Avg_lag_b2                 
Alias Cov_out_FW(20)  = FW_Var_lag_b2   
Alias Cov_out_FW(21)  = UxFW_Cov_lag_b2
Alias Cov_out_FW(22)  = UyFW_Cov_lag_b2
Alias Cov_out_FW(23)  = UzFW_Cov_lag_b2
Alias Cov_out_FW(24)  = nmbr_smpl_FW_lag_b2

'b1 indicates backward 1 scan 
Alias Cov_out_FW(25)  = FW_Avg_lag_b1                
Alias Cov_out_FW(26)  = FW_Var_lag_b1   
Alias Cov_out_FW(27)  = UxFW_Cov_lag_b1
Alias Cov_out_FW(28) = UyFW_Cov_lag_b1
Alias Cov_out_FW(29) = UzFW_Cov_lag_b1
Alias Cov_out_FW(30) = nmbr_smpl_FW_lag_b1

'0 indicates neither backward nor forward 
Alias Cov_out_FW(31) = FW_Avg_lag_0                 
Alias Cov_out_FW(32) = FW_Var_lag_0    
Alias Cov_out_FW(33) = UxFW_Cov_lag_0
Alias Cov_out_FW(34) = UyFW_Cov_lag_0
Alias Cov_out_FW(35) = UzFW_Cov_lag_0
Alias Cov_out_FW(36) = nmbr_smpl_FW_lag_0

'f1 indicates forward 1 scan lag
Alias Cov_out_FW(37) = FW_Avg_lag_f1                 
Alias Cov_out_FW(38) = FW_Var_lag_f1   
Alias Cov_out_FW(39) = UxFW_Cov_lag_f1
Alias Cov_out_FW(40) = UyFW_Cov_lag_f1
Alias Cov_out_FW(41) = UzFW_cov_lag_f1
Alias Cov_out_FW(42) = nmbr_smpl_FW_lag_f1

'f2 indicates forward 2 scans
Alias Cov_out_FW(43) = FW_Avg_lag_f2                 
Alias Cov_out_FW(44) = FW_Var_lag_f2   
Alias Cov_out_FW(45) = UxFW_Cov_lag_f2
Alias Cov_out_FW(46) = UyFW_Cov_lag_f2
Alias Cov_out_FW(47) = UzFW_Cov_lag_f2
Alias Cov_out_FW(48) = nmbr_smpl_FW_lag_f2

'f3 indicates forward 3 scans
Alias Cov_out_FW(49) = FW_Avg_lag_f3                 
Alias Cov_out_FW(50) = FW_Var_lag_f3   
Alias Cov_out_FW(51) = UxFW_Cov_lag_f3
Alias Cov_out_FW(52) = UyFW_Cov_lag_f3
Alias Cov_out_FW(53) = UzFW_Cov_lag_f3
Alias Cov_out_FW(54) = nmbr_smpl_FW_lag_f3

'f4 indicates forward 4 scans
Alias Cov_out_FW(55) = FW_Avg_lag_f4                 
Alias Cov_out_FW(56) = FW_Var_lag_f4   
Alias Cov_out_FW(57) = UxFW_Cov_lag_f4
Alias Cov_out_FW(58) = UyFW_Cov_lag_f4
Alias Cov_out_FW(59) = UzFW_Cov_lag_f4
Alias Cov_out_FW(60) = nmbr_smpl_FW_lag_f4

'f5 indicates forward 5 scans
Alias Cov_out_FW(61) = FW_Avg_lag_f5                 
Alias Cov_out_FW(62) = FW_Var_lag_f5   
Alias Cov_out_FW(63) = UxFW_Cov_lag_f5
Alias Cov_out_FW(64) = UyFW_Cov_lag_f5
Alias Cov_out_FW(65) = UzFW_Cov_lag_f5
Alias Cov_out_FW(66) = nmbr_smpl_FW_lag_f5

'*** Variables after coordinate rotations as indicated by U for Ux, V for Uy, and W for Uz 
Dim   WFW_Cov_lag (2*MAX_LAG + 1)                'Used for instruction of MaxSpa
Alias WFW_Cov_lag (1)  = WFW_Cov_lag_b5          'b5 indicates backward 5 scans   
Alias WFW_Cov_lag (2)  = WFW_Cov_lag_b4          'b4 indicates backward 4 scans  
Alias WFW_Cov_lag (3)  = WFW_Cov_lag_b3          'b3 indicates backward 3 scans 
Alias WFW_Cov_lag (4)  = WFW_Cov_lag_b2          'b2 indicates backward 2 scans   
Alias WFW_Cov_lag (5)  = WFW_Cov_lag_b1          'b1 indicates backward 1 scan  
Alias WFW_Cov_lag (6)  = WFW_Cov_lag_0           '0 indicates neither backward nor forward   
Alias WFW_Cov_lag (7)  = WFW_Cov_lag_f1          'f1 indicates forward 1 scan    
Alias WFW_Cov_lag (8)  = WFW_Cov_lag_f2          'f2 indicates forward 2 scans  
Alias WFW_Cov_lag (9)  = WFW_Cov_lag_f3          'f3 indicates forward 3 scans    
Alias WFW_Cov_lag (10) = WFW_Cov_lag_f4          'f4 indicates forward 4 scans 
Alias WFW_Cov_lag (11) = WFW_Cov_lag_f5          'f5 indicates forward 5 scans    
Units WFW_Cov_lag     = deg C m s-1

Dim   WFW_cov_major_sign                        'Summarize the sign of wFW1_cov: From above array, chose max if positive (up) and min if negative (down)  

Dim   UFW_VFW_Cov_lag(2*MAX_LAG + 1, 2)         'Hold the covariance of lagged FW with U or V after coordinate rotation  
Alias UFW_VFW_Cov_lag(1, 1)  = UFW_Cov_lag_b5   'b5 indicates backward 5 scans  
Alias UFW_VFW_Cov_lag(1, 2)  = VFW_Cov_lag_b5
Alias UFW_VFW_Cov_lag(2, 1)  = UFW_Cov_lag_b4   'b4 indicates backward 4 scans  
Alias UFW_VFW_Cov_lag(2, 2)  = VFW_Cov_lag_b4
Alias UFW_VFW_Cov_lag(3, 1)  = UFW_Cov_lag_b3   'b3 indicates backward 3 scans  
Alias UFW_VFW_Cov_lag(3, 2)  = VFW_Cov_lag_b3
Alias UFW_VFW_Cov_lag(4, 1)  = UFW_Cov_lag_b2   'b2 indicates backward 2 scans  
Alias UFW_VFW_Cov_lag(4, 2)  = VFW_Cov_lag_b2
Alias UFW_VFW_Cov_lag(5, 1)  = UFW_Cov_lag_b1   'b1 indicates backward 1 scan  
Alias UFW_VFW_Cov_lag(5, 2)  = VFW_Cov_lag_b1
Alias UFW_VFW_Cov_lag(6, 1)  = UFW_Cov_lag_0    '0 indicates neither backward nor forward   
Alias UFW_VFW_Cov_lag(6, 2)  = VFW_Cov_lag_0
Alias UFW_VFW_Cov_lag(7, 1)  = UFW_Cov_lag_f1   'f1 indicates forward 1 scan    
Alias UFW_VFW_Cov_lag(7, 2)  = VFW_Cov_lag_f1
Alias UFW_VFW_Cov_lag(8, 1)  = UFW_Cov_lag_f2   'f2 indicates forward 2 scans  
Alias UFW_VFW_Cov_lag(8, 2)  = VFW_Cov_lag_f2
Alias UFW_VFW_Cov_lag(9, 1)  = UFW_Cov_lag_f3   'f3 indicates forward 3 scans    
Alias UFW_VFW_Cov_lag(9, 2)  = VFW_Cov_lag_f3
Alias UFW_VFW_Cov_lag(10, 1) = UFW_Cov_lag_f4   'f4 indicates forward 4 scans  
Alias UFW_VFW_Cov_lag(10, 2) = VFW_Cov_lag_f4
Alias UFW_VFW_Cov_lag(11, 1) = UFW_Cov_lag_f5   'f5 indicates forward 5 scans  
Alias UFW_VFW_Cov_lag(11, 2) = VFW_Cov_lag_f5
Units UFW_VFW_Cov_lag       = deg C m s-1

'*** Variables found from Cov_out_FW(), WFW_Cov_lag_R(), and UFW_VFW_Cov_lag_R() according to the lag  
Dim   WFW_Cov_lag_max (2)
Alias WFW_Cov_lag_max (1) = WFW_Cov             'Max covariance among lagged covariance values and will be used for sensible heat flux after freq correction    
Alias WFW_Cov_lag_max (2) = lag_FW              'Lag number in scans, also used for sequential number in an array index for lag Cov_out_FW(), WFW_Cov_lag() and UFW_VFW_cov_lag()    
Units WFW_Cov             = deg C m s-1
Units lag_FW              = scans 

Dim   FW_Avg                                    'Selected from cov_out_FW() according to lag maximization using lag_FW    
Dim   FW_SIGMA                                  'Selected from cov_out_FW() according to lag maximization using lag_FW   
Units FW_Avg   = deg C  
Units FW_SIGMA = deg C

Dim   UxFW_Cov                                  'Selected from cov_out_FW() using lag_FW  
Dim   UyFW_Cov                                  'Selected from cov_out_FW() using lag_FW   
Dim   UzFW_Cov                                  'Selected from cov_out_FW() using lag_FW  
Units UxFW_Cov  = deg C m s-1
Units UyFW_Cov  = deg C m s-1
Units UzFW_Cov  = deg C m s-1

Dim nmbr_smpl_FW                                'Number of samples used for flux statistics related to FW 
Units nmbr_smpl_FW = Samples

Dim   UFW_Cov                                   'Selected from UFW_VFW_cov_lag() according to lag maximization using lag_FW  
Dim   VFW_Cov                                   'Selected from UFW_VFW_cov_lag() according to lag maximization using lag_FW
'For "WFW_Cov", see "wFW_Cov_lag_max (1)"  
Units UFW_Cov = deg C m s-1
Units VFW_Cov = deg C m s-1

'*** Variables after coordinate rotations and freq corrections as indicated by "fc"
Dim   WFW_Cov_fc
Units WFW_Cov_fc = deg C m s-1
 
'*** Sensible heat flux 
Dim   H_FW
Units H_FW = W m-2

'*** Delay table for high frequency data
DataTable (delay_fw, TRUE, (OFFSET + MAX_LAG))   ' + MAX_LAG. Add more records of MAX_LAG for use in finding a lag for FW 
  TableHide
  Sample (1, FW_raw,      IEEE4)
  Sample (1, diag_FW_raw, IEEE4)
EndTable

'*** Compute covariance of FW against CSAT wind data over an output interval
DataTable (comp_cov_fw, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average    (1, Cov_array_FW(1, 1), IEEE4, FW_bad_data_flg(1))
  Covariance (4, Cov_array_FW(1, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(1)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(1)))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b5")
  
  Average    (1, Cov_array_FW(2, 1), IEEE4, FW_bad_data_flg(2))
  Covariance (4, Cov_array_FW(2, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(2)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(2)))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b4")
   
  Average    (1, Cov_array_FW(3, 1), IEEE4, FW_bad_data_flg(3))
  Covariance (4, Cov_array_FW(3, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(3)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(3))))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b3")  

  Average    (1, Cov_array_FW(4, 1), IEEE4, FW_bad_data_flg(4))
  Covariance (4, Cov_array_FW(4, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(4)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(4)))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b2")

  Average    (1, Cov_array_FW(5, 1), IEEE4, FW_bad_data_flg(5))
  Covariance (4, Cov_array_FW(5, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(5)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(5)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b1")
  
  Average    (1, Cov_array_FW(6, 1), IEEE4, FW_bad_data_flg(6))
  Covariance (4, Cov_array_FW(6, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(6)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(6)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_0")
  
  Average    (1, Cov_array_FW(7, 1), IEEE4, FW_bad_data_flg(7))
  Covariance (4, Cov_array_FW(7, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(7)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(7)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f1")
  
  Average    (1, Cov_array_FW(8, 1), IEEE4, FW_bad_data_flg(8))
  Covariance (4, Cov_array_FW(8, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(8)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(8)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f2")
  
  Average    (1, Cov_array_FW(9, 1), IEEE4, FW_bad_data_flg(9))
  Covariance (4, Cov_array_FW(9, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(9)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(9)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f3")
  
  Average    (1, Cov_array_FW(10, 1), IEEE4, FW_bad_data_flg(10))
  Covariance (4, Cov_array_FW(10, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(10)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(10)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f4")
  
  Average    (1, Cov_array_FW(11, 1), IEEE4, FW_bad_data_flg(11))
  Covariance (4, Cov_array_FW(11, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(11)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(11)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f5")
EndTable
'******* END OF FW: CONSTANTS, VARIABLES, AND WORKING DATA TABLE ********* 
#EndIf  

  
#If (SENSOR_T_RH OR SENSOR_HYGRO) Then
'*************************************************************************
'*** BEGINNING OF TEMPERATURE/HUMIDITY PROBE: VARIABLES, AND DATA TABLE **
'*************************************************************************
Public tmpr_rh(7)
Alias tmpr_rh(1) = T_probe                         'Temperature/humidity probe: Temperature
Alias tmpr_rh(2) = RH_probe                        'Temperature/humidity probe: Relative humidity
Alias tmpr_rh(3) = T_DP_Probe                      'Temperature/humidity probe: Dew point temperature 
Alias tmpr_rh(4) = e_probe                         'Temperature/humidity probe: vapor pressure
Alias tmpr_rh(5) = e_sat_probe                     'Temperature/humidity probe: Saturate vapor pressure
Alias tmpr_rh(6) = H2O_density_probe               'Temperature/humidity probe: Water vapor density 
Alias tmpr_rh(7) = rho_d_probe                     'Temperature/humidity probe: Dry air density 
Units T_probe             = deg C
Units RH_probe            = %
Units T_DP_Probe          = deg C
Units e_probe             = kPa
Units e_sat_probe         = kPa  
Units H2O_density_probe   = g/m^3
Units rho_d_probe         = g/m^3
    
Dim stats_out_tmpr_rh(8)                           'Temperature/humidity probe: statistics
Alias stats_out_tmpr_rh(1) = TA_1_1_3              'Average temperature measured using temperature/humidity probe
Alias stats_out_tmpr_rh(2) = RH_1_1_3              'Average temperature measured using temperature/humidity probe
Alias stats_out_tmpr_rh(3) = T_DP_1_1_3            'Average dew point temperature measured using temperature/humidity probe 
Alias stats_out_tmpr_rh(4) = e_probe_Avg           'Average vapor pressure measured using temperature/humidity probe
Alias stats_out_tmpr_rh(5) = e_sat_probe_Avg       'Average saturation vapor pressure measured using temperature/humidity probe
Alias stats_out_tmpr_rh(6) = H2O_density_probe_Avg 'Average vapor density measured using temperature/humidity probe
Alias stats_out_tmpr_rh(7) = rho_d_probe_Avg       'Average dry air density measured using temperature/humidity probe
Alias stats_out_tmpr_rh(8) = rho_a_probe_Avg       'Average moist air density measured using Temperature/humidity probe
Units TA_1_1_3             = deg C
Units RH_1_1_3             = %
Units T_DP_1_1_3           = deg C
Units e_probe_Avg          = kPa
Units e_sat_probe_Avg      = kPa
Units H2O_density_probe_Avg = g m-3
Units rho_d_probe_Avg       = g m-3
Units rho_a_probe_Avg       = kg m-3

DataTable (stats_tmpr_rh, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)
  
  #If (SENSOR_T_RH)      Then
  Average (7, T_probe, IEEE4, FALSE)  
  #ElseIf (SENSOR_HYGRO) Then
  Average (7, T_probe, IEEE4, slowsequence_disable_f)
  #EndIf 
  
EndTable


'***** END OF TEMPERATURE/HUMIDITY PROBE: VARIABLES, AND DATA TABLE ******
#EndIf '(SENSOR_T_RH OR SENSOR_HYGRO) 


#If (SENSOR_TE525) Then
'*************************************************************************
'*****         BEGINNING OF TE525MM: CONSTANTS AND VARIABLES         *****
'*************************************************************************
Public P
Units  P = mm

Dim P_cumul_win_interval            'Use to indicate the rain within current interval to judge poor_energy_closure_flg 
Units P_cumul_win_interval = mm
'**************** END OF TE525MM: CONSTANTS AND VARIABLES ****************
#EndIf

#If (SENSOR_Rn) Then
'*************************************************************************
'*****  BEGINNING OF NET RADIOMETER: CONSTANTS, VARIABLES AND TABLE  *****
'*************************************************************************

'*** Array to hold data averaged over an output interval for all models of net radiometer
Dim   nr_mean(7 - 1*SENSOR_SN500)    'Radiation components measured from one net radiometer or one 4-way net radiometer.
Alias nr_mean(1) = NETRAD                              'Net radiation: mean over an averaging interval
Alias nr_mean(2) = ALB                                 'Albedo in AmeriFlux format
Alias nr_mean(3) = SW_IN_net_rdmtr                     'Incoming (downwelling) short wave radiation (This variable should be SW_IN in the final storage
'being name this way for the eventual use of SW_IN if other sensor (e.g., CS301) is used for incoming SW radiation)
Alias nr_mean(4) = SW_OUT                              'Outgoing (upwelling) short wave radiation
Alias nr_mean(5) = LW_IN                               'Incoming (downwelling) long wave radiation
Alias nr_mean(6) = LW_OUT                              'Outgoing (upwelling) long wave radiation
Alias nr_mean(7) = T_nr_Avg                            'Sensor body temperature. 
#If (SENSOR_SN500) Then
Alias nr_mean(8) = T_nr_out_Avg                        'Sensor body temperature of SN500 for long-wave outgoing 
#EndIf 
Units NETRAD          = W m-2
Units ALB             = %
Units SW_IN_net_rdmtr = W m-2
Units SW_OUT          = W m-2
Units LW_IN           = W m-2
Units LW_OUT          = W m-2
Units T_nr_Avg        = Klvin
#If (SENSOR_SN500) Then
Units T_nr_out_Avg    = Klvin
#EndIf 


#If (SENSOR_CNR4 AND SENSOR_CNF4) Then
'*** Calculate the wind speed within last 3 seconds for CNF4  
Const NMBR_WND_SAMPLES = 3000/SCN_INTV         'Number of measurements to compute a three-second mean of horizontal wind to correct measured NETRAD_meas as NETRAD_raw  
Dim hor_wind_raw                               'Resultant wind at the frequency of scans. This data will be used in AvgRun instruction to calculate hor_wind
Dim hor_wind                                   'Running average from hor_wind_raw over three seconds
#EndIf '(SENSOR_CNR4 AND SENSOR_CNF4)

'*** Array to whole instantaneous data 4-way net radiometer
Public nr(8 - 1*(SENSOR_NR01 OR SENSOR_CNR4)) 'Radiation components measured from a 4-way net radiometer.
Alias nr(1) = NETRAD_raw                      'Net radiation: Measured time series data
Alias nr(2) = albedo
Alias nr(3) = R_SW_in                         'Incoming (downwelling) short wave radiation
Alias nr(4) = R_SW_out                        'Outgoing (upwelling) short wave radiation
Alias nr(5) = R_LW_in                         'Incoming (downwelling) long wave radiation
Alias nr(6) = R_LW_out                        'Outgoing (upwelling) long wave radiation
Alias nr(7) = T_nr                            'Sensor body temperature
#If (SENSOR_SN500) Then 
Alias nr(8) = T_nr_out                        'Sensor body temperature of SN500 for outgoing long-wave radiation
#EndIf 
#If (SENSOR_NR01 OR SENSOR_CNR4) Then
Alias nr(8) = R_LW_in_meas                    'Measured signal of incoming (downwelling) long wave radiation
Alias nr(9) = R_LW_out_meas                   'Measured signal of outgoing (upwelling) long wave radiation
#EndIf
Units NETRAD_raw = W m-2 
Units albedo     = %
Units R_SW_in    = W m-2
Units R_SW_out   = W m-2
Units R_LW_in    = W m-2
Units R_LW_out   = W m-2
Units T_nr       = Klvin
#If (SENSOR_SN500) Then 
Units T_nr_out   = Klvin                      'Sensor body temperature
#EndIf 
#If (SENSOR_NR01 OR SENSOR_CNR4) Then
Units R_LW_in_meas  = W m-2
Units R_LW_out_meas = W m-2
#EndIf

#If (SENSOR_CNR4) Then
'*** YSI 44031 Steinhart-Hart coefficients fit through -40 degrees C (239800 ohms), 20 degrees C (12260 ohms), and 80 degrees C (1458 ohms).
Const A_SHH = 1.0295e-3                      'Steinhart-Hart A coefficient (from Kipp & Zonen through email April 16 2015).
Const B_SHH = 2.3910e-4                      'Steinhart-Hart B coefficient (from Kipp & Zonen through email April 16 2015).
Const C_SHH = 1.5680e-7                      'Steinhart-Hart C coefficient (from Kipp & Zonen through email April 16 2015).
Dim X_cnr4
Dim ln_R
#EndIf

#If (SENSOR_NR01 OR SENSOR_CNF4) Then
'*** Constant and variables to control heating NR01/CNR4 
Const NETRAD_HEATER_T_TD_THRSHLD  = 2   'Threshold of difference between air temperature and dew point temperature
#If (SENSOR_NR01) Then 
Dim NR01_heater_secs = SCN_INTV/1000    'Totalize the seconds Flux_Notes during which NR01 heater on
Dim NR01_heater_on_f As Boolean
#EndIf 

#If (SENSOR_CNF4) Then 
Const CNR4_FAN_WND_THRSHLD  = 8         'Wind threshold to turn on/off CNR4 fan 

Dim cnr4_fan_heater_on(3)  As Boolean 
Alias cnr4_fan_heater_on(1) = cnr4_fan_on_f   
Alias cnr4_fan_heater_on(2) = cnr4_heater_1_on_f   
Alias cnr4_fan_heater_on(3) = cnr4_heater_2_on_f 
 
Dim cnr4_fan_heater_array(3) = {SCN_INTV/1000, SCN_INTV/1000, SCN_INTV/1000} 
Alias cnr4_fan_heater_array(1) = cnr4_fan_secs            'Totalize the seconds in Flux_Notes during which CNR4 fan was on
Alias cnr4_fan_heater_array(2) = cnr4_heater_1_secs       'Totalize the seconds in Flux_Notes during which CNR4 heater #1 was on
Alias cnr4_fan_heater_array(3) = cnr4_heater_2_secs       'Totalize the seconds in Flux_Notes during which CNR4 heater #2 was on
Units cnr4_fan_heater_array = s 
      
Public cnr4_fan_freq
Units  cnr4_fan_freq = Hz      
#EndIf '(SENSOR_CNF4)  
#EndIf '(SENSOR_NR01 OR SENSOR_CNF4)

#If (SENSOR_SN500) Then 
'SN500: Constants and variables
Dim body_tmpr_SN500(4) 
Alias  body_tmpr_SN500(1) = LW_in_sgnl_mV
Alias  body_tmpr_SN500(2) = LW_in_tmpr
Alias  body_tmpr_SN500(3) = LW_out_sgnl_mV
Alias  body_tmpr_SN500(4) = LW_out_tmpr      
        
Const SN500_HEATER_T_TD_THRSHLD  = 2                       'Threshold of difference between air temperature and dew point temperature   
     
Dim sn500_heater_set_dummy                                 'Dummy variable 
Dim sn500_heater_on_f As Boolean
Dim sn500_heater_secs = SCN_INTV/1000  
#EndIf '(SENSOR_SN500)

DataTable (stats_net_radiation, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average (7, NETRAD_raw, IEEE4, slowsequence_disable_f)
  #If (SENSOR_SN500) Then
  Average (1, T_nr_out,   IEEE4, slowsequence_disable_f)  
  #EndIf

EndTable
'*********  END OF NET RADIOMETER: CONSTANTS, VARIABLES AND TABLE  *******
#EndIf '(SENSOR_Rn)


#If (SENSOR_HFP) Then
'*************************************************************************
'** BEGINNING OF HFP01 OR HFP01SC: CONSTANTS, VARIABLES, AND DATATABLE  **
'*************************************************************************
Dim shf_plate_cal(NMBR_HFP)             'Hold calibration of soil heat flux plates

Public shf_plate(NMBR_HFP)              'Soil heat flux through soil heat flux plates
Units shf_plate = W m-2

Dim   shf_plate_avg(NMBR_HFP)          'Mean soil heat flux through soil heat flux plates
Alias shf_plate_avg(1) = G_plate_1_1_1
#If (NMBR_HFP > 1) Then 
Alias shf_plate_avg(2) = G_plate_1_1_2
#EndIf 
#If (NMBR_HFP > 2) Then 
Alias shf_plate_avg(3) = G_plate_1_1_3
#EndIf   
Units shf_plate_avg = W m-2

#If (SENSOR_HFPSC) Then
'*** Beginning of HFP01SC constants and variables ***
Const END_CAL = OUTPUT_INTV - 1          'End HFP01SC insitu calibration one minute before the next output.
Dim shf_mV(NMBR_HFP)                     'Voltage measured from soil heat flux plates
Dim shf_mV_run(NMBR_HFP)                 'Running mean of shf_mV
Dim shf_mV_0(NMBR_HFP)                   'Running mean of shf_mV at the beginning of calibration
Dim shf_mV_180(NMBR_HFP)                 'Running mean of shf_mV after 180 seconds since the beginning of calibration
Dim shf_mV_end(NMBR_HFP)                 'Running mean of shf_mV at the end of calibration
Dim shf_htr_resstnc(NMBR_HFP)            'Array to load heater resistance in ohms
Dim V_rf(NMBR_HFP)                       'Reference voltage
Dim V_rf_run(NMBR_HFP)                   'Running mean of reference voltage
Dim V_rf_180(NMBR_HFP)                   'Running mean of reference voltage after 180 seconds since the beginning of calibration
Dim shf_mfct_cal(NMBR_HFP)               'Hold manufacture calibrations of self-calibrated soil heat flux plates
Dim shf_cal_on_f As Boolean              'Set true while calibration is on
Dim shf_cal_fail_f(NMBR_HFP) As Boolean  'HFP01SC self-calibration warning   
'*** End of HFP01SC constants and variables ***
#EndIf

DataTable (stats_SHF, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)
  #If (SENSOR_HFP01) Then
  Average (NMBR_HFP, shf_plate(1), IEEE4, slowsequence_disable_f)
  #EndIf

  #If (SENSOR_HFPSC) Then
  Average (NMBR_HFP, shf_plate(1), IEEE4, (shf_cal_on_f OR slowsequence_disable_f))
  #EndIf
EndTable
'****** END OF HFP01 OR HFP01SC: CONSTANTS, VARIABLES, AND DATATABLE *****
#EndIf


#If (SENSOR_TCAV) Then
'*************************************************************************
'*****                 BEGINNING OF TCAV VARIABLES                   *****
'*************************************************************************
Public Tsoil(NMBR_TCAV)                 'TCAV soil temperature.
Units Tsoil = deg C
'***********************  END OF TCAV VARIABLES  *************************
#EndIf


#If (SENSOR_CS65X) Then 
'*************************************************************************
'*****               BEGINNING OF CS6xx VARIABLES                    *****
'*************************************************************************
'*** Beginning of CS65X constants and variables 
Public cs65x_wc(NMBR_CS65x)             'Volumetric soil water content.
Public cs65x_ec(NMBR_CS65x)             'Electrical conductivity.
Public cs65x_tmpr(NMBR_CS65x)           'CS65X probe temperature.
Dim cs65x_raw(3)                        'Hold CS65X raw variables
Units cs65x_wc = %
Units cs65x_ec = dS m-1
Units cs65x_tmpr = deg C
'********************* END OF CS6xx VARIABLES ****************************
#EndIf '(SENSOR_CS65X)

#If (SENSOR_TDR) Then 
'*************************************************************************
'*****               BEGINNING OF TDR VARIABLES                      *****
'*************************************************************************
'*** Beginning of TDR constants and variables
Public tdr_wc(NMBR_CS65x)             'Volumetric soil water content.
Public tdr_tmpr(NMBR_CS65x)           'Soil temperature.
Public tdr_E(NMBR_CS65x)              'Electrical permittivity.
Public tdr_bulkEC(NMBR_CS65x)         'Bulk electrical conductivity.
Public tdr_poreEC(NMBR_CS65x)         'Pore water electrical conductivity.
Dim tdr_raw(5)                        'Hold TDR raw variables
Units tdr_wc = %
Units tdr_tmpr = deg C
Units tdr_E = unitless
Units tdr_bulkEC = dS m-1
Units tdr_poreEC = dS m-1
'********************* END OF TDR VARIABLES   ****************************
#EndIf '(SENSOR_TDR)

'*************************************************************************
'*****               BEGINNING OF SWC VARIABLES                      *****
'*************************************************************************
#If (SENSOR_SWC) Then
'Soil water contents measured using CS655 w/ or w/o soil temperature correction will be moved to this array  
Dim SWC_array(NMBR_CS65x)              'Soil water contents measured from                
Alias SWC_array(1) = SWC_1_1_1
#If (NMBR_CS65x > 1) Then 
Alias SWC_array(2) = SWC_1_1_2
#EndIf 
#If (NMBR_CS65x > 2) Then 
Alias SWC_array(3) = SWC_1_1_3
#EndIf 

Units SWC_array = % 
'********************* END OF SWC VARIABLES ******************************
#EndIf '(SENSOR_SWC)


#If (SENSOR_SWC OR SENSOR_TCAV) Then 
'*************************************************************************
'*****      BEGINNING OF ADDITIONAL VARIABLES FOR CS65X AND TCAV     *****
'*************************************************************************
Dim TS_array(3)                           'Soil Temperature measured from TCAV or CS655                
Alias TS_array(1) = TS_1_1_1
Alias TS_array(2) = TS_1_1_2              'The use of this variable depends on the NUMBR_TCAV or NUMBR_CS6xx
Alias TS_array(3) = TS_1_1_3              'The use of this variable depends on the NUMBR_TCAV or NUMBR_CS6xx
Units TS_array = deg C   
'************ END OF ADDITIONAL VARIABLES FOR CS65X AND TCAV *************
#EndIf '(SENSOR_SWC OR SENSOR_TCAV)


#If (SENSOR_HFP AND SENSOR_SWC) Then
'*************************************************************************
'BEGINNING OF VARIABLES FOR CALCULATION OF SOIL HEAT FLUX AT SOIL SURFACE 
'*************************************************************************
Const NMBR_SOIL_T_WTR_DEL_SAMPLES = INT((60*1000)/SLW_SCN_INTV +1) 'Number of measurements to compute a one-minute mean of soil temperature and water
                                                                   'If SLW_SCN_INTV < 1 min, the most recent one measurement is used. 
Dim    G_surface_rep(NMBR_HFP)            'Soil heat flux at the ground surface from individual replications
Alias  G_surface_rep(1) = G_1_1_1
#If (NMBR_HFP > 1) Then 
Alias  G_surface_rep(2) = G_1_1_2
#EndIf 
#If (NMBR_HFP > 2) Then   
Alias  G_surface_rep(3) = G_1_1_3
#EndIf 
Units  G_surface_rep = W m-2

Dim    G_surface                          'Soil heat flux at the ground surface (In the final storage, this variable was renamed as G, using FieldNames, consistent with AmeriFlux notation)
Units  G_surface = W m-2

Dim Tsoil_current(3)                      'Indididual Tsoil means of last one-minute measurements in the current averaging interval from TCAV or cs65x_tmpr(NMBR_CS65x) if TCAV unavailable, but CS65x available
Dim Tsoil_prev(3) = {NaN, NaN, NaN}       'Individual Tsiol means of Tsoil_current () at the end of previous averaging interval 
    
Dim soil_wtr_current(NMBR_CS65x)          'One-minute running mean of cs65x_wc
Dim soil_wtr_prev (3) = {NaN, NaN, NaN}   'Average of soil_wtr_current() at the end of previous averaging interval
    ' Notes for NaN: Tsoil_prev(3) and soil_wtr_prev (3) are assigned as NaN indicating just after compiling and previous values unavailable, then are replaced with the current
    ' measured values. On subsequent averaging intervals, *_prev_Avg will be taken from the running mean of the last minute of the previous averaging interval.
    
Dim    SG_rep (NMBR_HFP)                  'The soil heat flux into or out of soil as heat storage above soil heat flux plates over an averaging interval for individual replications
Alias  SG_rep (1) = SG_1_1_1
#If (NMBR_HFP > 1) Then 
Alias  SG_rep (2) = SG_1_1_2
#EndIf
#If (NMBR_HFP > 2) Then 
Alias  SG_rep (3) = SG_1_1_3
#EndIf 

Dim    SG                                 'The soil heat flux into soil as heat storage above soil heat flux plates over an averaging interval
Units  SG = W m-2

' Variables used to calculate the number of seconds from the beginning of the program to the end of the first averaging interval (time interval offset)
Dim Offset_intv_delta_ht_storage          'time interval offset
'** END OF VARIABLES FOR CALCULATION OF SOIL HEAT FLUX AT SOIL SURFACE ***
#EndIf '(SENSOR_HFP AND SENSOR_SWC))


#If (SENSOR_Rn AND SENSOR_HFP AND SENSOR_SWC) Then
'*************************************************************************
'*****            BEGINNING OF ENERGY BALANCE VARIABLES              *****
'*************************************************************************
Dim    energy_closure                  '(LE + H)/(Rn-G_surface)
Units  energy_closure = fraction

#If (SENSOR_TE525) Then 
Public poor_energy_closure_flg As Boolean 
#EndIf
'****************** END OF ENERGY BALANCE VARIABLES **********************
#EndIf


#If (SENSOR_CS301 OR SENSOR_CS320 OR SENSOR_Rn) Then 
'*************************************************************************
'*****           BEGINNING OF PYRANOMETER VARIABLES                  *****
'*************************************************************************  

#If (SENSOR_CS301) Then
'*** CS301 variable 
Dim    SW_IN_pyran
Units  SW_IN_pyran = mV
#EndIf

#If (SENSOR_CS320) Then
'*** CS320 varaibles 
  Public pyran(6)
  Alias pyran(1) = SW_IN_CS320    
  Alias pyran(2) = V_CS320                   'Voltage
  Alias pyran(3) = T_CS320                   'Temperature  
 'Defined in the right-handed coordinate system (x-axis along the wire in the direction pointed by cable pins)  
  Alias pyran(4) = x_incline                 'Positive if above the reference plane and negative if below the reference plane
  Alias pyran(5) = y_incline                 'Positive if above the reference plane and negative if below the reference plane 
  Alias pyran(6) = z_incline                 'Positive in a positive quadrat in the x-y plane and vice versa (author understanding)   
  Units SW_IN_CS320  = W m-2
  Units V_CS320      = mV
  Units T_CS320      = deg C
  Units x_incline    = decimal degrees
  Units y_incline    = decimal degrees
  Units z_incline    = decimal degrees 
  
  Const CS320_HEATER_T_TD_THRSHLD = 2
  Dim CS320_heater_set_dummy                 'Dummy variable 
  Dim CS320_heater_on_f As Boolean
  Dim CS320_heater_secs = SCN_INTV/1000  

#EndIf '(SENSOR_CS320)

'*** Additional variable for short wave radiation 
Dim   SW_IN
Units SW_IN = W m-2

'******************* END OF PYRANOMETER VARIABLES ************************
#EndIf '(SENSOR_CS301 OR SENSOR_CS320 OR SENSOR_Rn)


#If (SENSOR_CS310) Then
'*************************************************************************
'*****          BEGINNING OF QUANTUM CONSTANTS AND VARIABLES         *****
'*************************************************************************
Public PPFD_IN
Units  PPFD_IN = umolPhoton m-2 s-1
'**************** END OF QUANTUM CONSTANTS AND VARIABLES *****************
#EndIf '(SENSOR_CS310)


#If (CDM_VOLT_116) Then 
#If (SENSOR_SI111) Then
'*************************************************************************
'*****            BEGINNING OF INFRARED RADIOMETER VARIABLES         *****
'*************************************************************************
Public T_CANOPY              'Temperature of surface that SI111 targets. we consider it as canopy temperature 
Public T_SI111_body          'Temperature of SI111 sensor body
Units  T_CANOPY      = deg C
Units  T_SI111_body  = deg C

Dim m_SI111, b_SI111         'Multiplier and offset in equation to calculate temperature of targeted surface using measured voltage and SI111 body temperature
'****************** END OF INFRARED RADIOMETER VARIABLES ****************
#EndIf '(SENSOR_SI111)
#EndIf '(CDM_VOLT_116)


'*************************************************************************
'*****                    BEGINNING DISPLAY MENU                     *****
'*************************************************************************
DisplayMenu ("System Control", TRUE)
  SubMenu ("Site Var Settings")
    MenuItem ("Meas Height",   height_measurement)
    MenuItem ("Surface Type",  surface_type)
      MenuPick (CROP, GRASS, FOREST, SHRUB, BARELAND, WATER, ICE)
    MenuItem ("Canopy Height", height_canopy)
    MenuItem ("d, 0 = auto",   displacement_user)         'if 0, zero displacement is automatically calculated in the program
    MenuItem ("z0,0 = auto",   roughness_user)            'if 0, roughness length is automatically calculated in the program
    #If (SENSOR_GPS) Then 
    MenuItem ("GPS Height",    height_GPS16X)   
    #EndIf 

    #If (SENSOR_HFP AND SENSOR_SWC) Then
    MenuItem ("Bulk Density", soil_bulk_density)
    MenuItem ("C_dry_soil",   Cds)
    MenuItem ("HFP Depth",    thick_abv_SHFP)
    #EndIf

    #If (CSAT3A_EC150) Then 
    MenuItem ("IRGA Coord x", separation_x_irga)
    MenuItem ("IRGA Coord y", separation_y_irga)
    #EndIf

    #If (SENSOR_FW) Then
    MenuItem ("FW Coord x",  separation_x_FW)
    MenuItem ("FW Coord y",  separation_y_FW)
    MenuItem ("FW Dim",      FW_diameter)
      MenuPick (FW05DIA, FW1_DIA, FW2_DIA, FW3_DIA)
    #EndIf

    MenuItem ("Sonic Azmth", sonic_azimuth)
    MenuItem ("Latitude",    latitude)
    MenuItem ("Hemisph_NS",  hemisphere_NS)
      MenuPick (NORTH, SOUTH)
    MenuItem ("Longitude",   longitude)
    MenuItem ("Hemisph_EW",  hemisphere_EW)
      MenuPick (EAST, WEST)
    MenuItem ("Altitude",    altitude)
    
    SubMenu ("Planar Fit Alpha")
      MenuItem ("<=60or>=300",  alpha_PF_60_300)           'Angle in CSAT coordinate system
      MenuItem (">60 & <=170",  alpha_PF_60_170)
      MenuItem (">170 & <190",  alpha_PF_170_190)
      MenuItem (">=190 & <300", alpha_PF_190_300)
    EndSubMenu

    SubMenu ("Planar Fit Beta")
      MenuItem ("<=60or>=300",  beta_PF_60_300)            'Angle in CSAT coordinate system
      MenuItem (">60 & <=170",  beta_PF_60_170)
      MenuItem (">170 & <190",  beta_PF_170_190)
      MenuItem (">=190 & <300", beta_PF_190_300)
    EndSubMenu

    SubMenu ("Footprt Dist Intrst")
      MenuItem ("<=60or>=300",  dist_intrst_60_300)        'Angle in CSAT coordinate system
      MenuItem (">60 & <=170",  dist_intrst_60_170)
      MenuItem (">170 & <190",  dist_intrst_170_190)
      MenuItem (">=190 & <300", dist_intrst_190_300)
    EndSubMenu
  EndSubMenu '("Site Var Settings")
  
  SubMenu ("Instrument Settings")
    'Barometer
    SubMenu ("Change Press Source")
      MenuItem ("Select Source", press_source)
        MenuPick (BB, UB, EB)
      MenuItem ("Set Source",  set_press_source_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    'Infrared analyzer
    SubMenu ("Switch IRGA Power")
      DisplayValue ("IRGA PW on", irga_actual_pwr_on) 
      DisplayValue ("Message",    message) 
      
      MenuItem ("IRGA ON/OFF", irga_power)
        MenuPick (PWR_ON, PWR_OFF)
      MenuItem ("Set IRGA Pwr", set_irga_power_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    SubMenu ("Select IRGA Heater")
        MenuItem ("Selct Heater", heater_user)
        MenuPick (H_AUTO, H_MAX, H_OFF)
      MenuItem ("Set Selcted", set_heater_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    SubMenu ("Select T for CO2")
      MenuItem ("Fast-T OnOff", select_CO2_fast_tmpr)
        MenuPick (FAST_ON, FAST_OFF)
      MenuItem ("Set Selcted", set_CO2_fast_tmpr_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu

    'Sonic anemometer 
    SubMenu ("Shadow Correction")
      MenuItem ("Selct Crrctn", shadow_corr)
        MenuPick (CORR_ON, CORR_OFF)
      MenuItem ("Set Selcted", set_shadow_corr_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    #If (CSAT3A_EC150) Then 
    #If (CSAT_TYP_3AH) Then 
    SubMenu ("CSAT3AH Heating Ctrl")
    MenuItem ("User Ctrl On", CSAT3H_user_ctrl_flg)
       MenuPick (TRUE, FALSE)
    EndSubMenu
   #EndIf '(CSAT_TYP_3AH) 
   #EndIf '(CSAT3A_EC150)   
    
 EndSubMenu '("Instrument Settings")

 SubMenu ("On-Site Zero/Span")
    SubMenu ("CO2/H2O Zero")
      DisplayValue ("CO2_mixratio", CO2_mixratio_kd)
      DisplayValue ("H2O_mixratio", H2O_mixratio_kd)
      MenuItem ("Set Zero", set_zero_flg)
      MenuPick (TRUE, FALSE)
    EndSubMenu '("CO2/H2O Zero")
            
    SubMenu ("CO2 Span")
      MenuItem ("Spn CO2 umol", CO2_span_gas)
      MenuItem ("Set CO2 Span", set_CO2_span_flg)
        MenuPick (TRUE, FALSE)
        
      DisplayValue ("CO2_mixratio", CO2_mixratio_kd)
    EndSubMenu '("CO2 Span")
   
    SubMenu ("H2O Span")
      MenuItem ("Spn H2O T_DP", T_DP_span_gas)
      MenuItem ("Set H2O Span", set_H2O_span_flg)
        MenuPick (TRUE, FALSE)
              
      DisplayValue ("H2O_mixratio", H2O_mixratio_kd)
      DisplayValue ("Msurd T_DP C", T_DP_amb)
      
      #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
      DisplayValue ("T_DP_Probe C", T_DP_Probe)
      #EndIf
    EndSubMenu '("H2O Span")
    
    SubMenu ("Reset zro/spn coefs")
      
      SubMenu ("Reset CO2 zro coef")
        MenuItem ("Change coef", CO2_zero_coeff)
        MenuItem ("Set change",  rst_CO2_zro_coef_flg)
            MenuPick (TRUE, FALSE)
        DisplayValue ("Status",  config_status)
      EndSubMenu
      
      SubMenu ("Reset CO2 spn coef")
        MenuItem ("Change coef", CO2_span_coeff)
        MenuItem ("Set change",  rst_CO2_spn_coef_flg)
            MenuPick (TRUE, FALSE)
        DisplayValue ("Status",  config_status)
      EndSubMenu
        
      SubMenu ("Reset H2O zro coef")
        MenuItem ("Change coef", H2O_zero_coeff)
        MenuItem ("Set change",  rst_H2O_zro_coef_flg)
            MenuPick (TRUE, FALSE)
        DisplayValue ("Status",  config_status)
      EndSubMenu
      
      SubMenu ("Reset H2O spn coef")
        MenuItem ("Change coef", H2O_span_coeff)
        MenuItem ("Set change",  rst_H2O_spn_coef_flg)
            MenuPick (TRUE, FALSE)
        DisplayValue ("Status",  config_status)            
      EndSubMenu

    EndSubMenu '("Reset zro/span coefs")
    
  EndSubMenu '("On-Site Zero/Span")
EndMenu
'**************************** END DISPLAY MENU ***************************
  

'*************************************************************************
'*****           FLUX TABLE IN AmeriFlux VARIABLE FORMAT             *****
'*************************************************************************
DataTable (Flux_AmeriFluxFormat, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTV, Min, 0)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&"_Flux_AmeriFluxFormat_", -259, -1, 0, DAY_FLUX_CRD, day, 0, 0)
  
 'Time stamp
  Sample (2, TIMESTAMP_START, IEEE8)   
  
  '***GASES
  Sample (2, CO2,           IEEE4)  'CO2 and CO2_SIGMA
  Sample (2, H2O,           IEEE4)  'H2O and H2O_SIGMA     
  Sample (1, FC,            IEEE4)  'CO2 flux in umol/(m^2 s) after coordinate rotations, freq corrections, and WPL correction
  Sample (1, FC_SSITC_TEST, IEEE4)   'Results of the Steady State and Integral Turbulence Characteristics for FC according to Foken et al (2004)
  
  '***HEAT  
  Sample (1, LE,            IEEE4)  'Latent heat flux after coordinate rotations, freq corrections, and WPL correction
  Sample (1, LE_SSITC_TEST, IEEE4)   'Results of the Steady State and Integral Turbulence Characteristics for LE and ET according to Foken et al (2004)
  Sample (1, ET,            IEEE4)  'Evapotranspiration after coordinate rotations, freq corrections, and WPL correction
  Sample (1, LE_SSITC_TEST, IEEE4)   'Results of the Steady State and Integral Turbulence Characteristics for LE used for ET according to Foken et al (2004)
  FieldNames ("ET_SSITC_TEST") 
  Sample (1, H,             IEEE4)  'Sensible heat flux (derived from sonic temperature flux with SND correction after coordinate rotations and freq corrections)
  Sample (1, H_SSITC_TEST,  IEEE4)   'Results of the Steady State and Integral Turbulence Characteristics for LE according to Foken et al (2004)   
  
  #If (SENSOR_HFP AND SENSOR_SWC)  Then
  Sample (1, G_surface,     IEEE4)  'Soil heat flux at the ground surface
  FieldNames ("G")  
  Sample (1, SG,            IEEE4)  'Heat storage in the soil above the soil heat flux plates between the beginning and end of average interval 
  #EndIf

  '***FOOTPRINT 
  Sample (1, FETCH_MAX,     IEEE4)  'Upwind location of source/sink that contributes most to the measured flux
  Sample (1, FETCH_90,      IEEE4)  'Upwind range within which sources/sinks contributes 90% the measured flux
  Sample (1, FETCH_55,      IEEE4)  'Upwind range within which sources/sinks contributes 55% the measured flux
  Sample (1, FETCH_40,      IEEE4)  'Upwind range within which sources/sinks contributes 40% the measured flux  
  
  '***MET_WIND
  Sample (1, WD,             IEEE4)  'Wind direction in compass convention.
  Sample (1, WS,             IEEE4)  'Mean wind speed.
  Sample (1, WS_MAX,         IEEE4)  'Maximum wind speed.
  Sample (1, USTAR,          IEEE4)  'Friction velocity after coordinate rotations and freq corrections
  Sample (1, ZL,             IEEE4)  'Atmospheric boundary-layer stability.  
  Sample (1, TAU,            IEEE4)  'Momentum flux after coordinate rotations and freq corrections,
  Sample (1, TAU_SSITC_TEST, IEEE4)   'Results of the Steady State and Integral Turbulence Characteristics for TAU according to Foken et al (2004)    
  Sample (1, MO_LENGTH,      IEEE4)  'Monin-Obukhov length
  Sample (1, U,              IEEE4)  'Average wind speed in stream-wise direction after coordinate rotation   
  Sample (1, U_SIGMA,        IEEE4)  'Standard deviation of wind speed in stream-wise wind direction after coordinate rotation   
  Sample (1, V,              IEEE4)  'Average wind speed in cross-stream direction after coordinate rotation  
  Sample (1, V_SIGMA,        IEEE4)  'Standard deviation of wind speed in cross-stream direction after coordinate rotation  
  Sample (1, W,              IEEE4)  'Average vertical wind speed after coordinate rotation  
  Sample (1, W_SIGMA,        IEEE4)  'Standard deviation of vertical wind after coordinate rotation 
 
  '*** MET_ATM
  Sample (1, PA,             IEEE4)  'Atmospheric pressure 
  Sample (1, TA_1_1_1,       IEEE4)  'Air temperature from EC100 107 temperature probe
  Sample (2, RH_1_1_1,       IEEE4)  'RH_1_1_1 and T_DP_1_1_1. Calculated from 107 temperature, H2O, and pressure. 

  Sample (1, TA_1_1_2,       IEEE4)  'Air temperature calculated from sonic temperature, water vapor density, and pressure
  Sample (2, RH_1_1_2,       IEEE4)  'RH_1_1_2 and T_DP_1_1_2. Calculated from sonic temperature, H2O, and pressure. 
     
  #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
  Sample  (3, TA_1_1_3,      IEEE4)  'Measured from temperature and humidity probe: TA_1_1_3, RH_1_1_3, and T_DP_1_1_3
  #EndIf

  Sample (1, VPD,            IEEE4)  'Air vapor pressure deficit
  Sample (1, T_SONIC,        IEEE4)  'Average sonic temperature (Ts_Avg)  
  Sample (1, T_SONIC_SIGMA,  IEEE4)  'Standard deviation of sonic temperature.
  Sample (1, PBLH,           IEEE4)  'Planetary boundary layer height.

  #If (SENSOR_SWC OR SENSOR_TCAV) Then 
   'MET_SOIL
  #EndIf 
  
  #If (SENSOR_TCAV) Then
  Average (1, TS_1_1_1, IEEE4, slowsequence_disable_f)          'Soil temperature from TCAV
  FieldNames("TS_1_1_1")
  #If (NMBR_TCAV > 1) Then
  Average (1, TS_1_1_2, IEEE4, slowsequence_disable_f) 
  FieldNames("TS_1_1_2")
  #EndIf
  #If (NMBR_TCAV > 2) Then
  Average (1, TS_1_1_3, IEEE4, slowsequence_disable_f)
  FieldNames("TS_1_1_3")
  #EndIf
  #EndIf
  
  #If ((NOT SENSOR_TCAV) AND SENSOR_SWC)  Then
  Average (1, TS_1_1_1, IEEE4, slowsequence_disable_f)           'Soil temperature from CS65x or TDR
  FieldNames("TS_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, TS_1_1_2, IEEE4, slowsequence_disable_f) 
  FieldNames("TS_1_1_2")
  #EndIf
  #If (NMBR_CS65x > 2) Then
  Average (1, TS_1_1_3, IEEE4, slowsequence_disable_f)
  FieldNames("TS_1_1_3")
  #EndIf
  #EndIf
  
  #If (SENSOR_SWC) Then
  Average (1, SWC_1_1_1, IEEE4, slowsequence_disable_f)         'Measured using CS65x or TDR. Volumetric soil water w/ temperature correction
  FieldNames ("SWC_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, SWC_1_1_2, IEEE4, slowsequence_disable_f)
  FieldNames ("SWC_1_1_2")
  #EndIf 
  #If (NMBR_CS65x > 2) Then
  Average (1, SWC_1_1_3, IEEE4, slowsequence_disable_f)
  FieldNames ("SWC_1_1_3")
  #EndIf   
  #EndIf '(SENSOR_SWC)

  #If (SENSOR_Rn OR SENSOR_CS301 OR SENSOR_CS310 OR SENSOR_CS320) Then 
  'MET_RAD
  #EndIf 
  #If (SENSOR_Rn) Then
  Sample (1, ALB,    IEEE4)                                     'Albedo
  Sample (1, NETRAD, IEEE4)
  #EndIf

  #If (SENSOR_CS310) Then
  Average  (1, PPFD_IN, IEEE4, slowsequence_disable_f)
  FieldNames("PPFD_IN")
  #EndIf    

  #If (SENSOR_CS301 OR SENSOR_CS320 OR SENSOR_Rn) Then
  Average  (1, SW_IN, IEEE4, slowsequence_disable_f)             'For use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
  FieldNames("SW_IN")
  #EndIf

  #If (SENSOR_Rn) Then
  Sample  (3, SW_OUT, IEEE4)                                     'SW_OUT, LW_IN, and LW_OUT
  #EndIf
   
  #If (SENSOR_TE525) Then
  'MET_PRECIP  
  Totalize (1, P, IEEE4, 0)
  FieldNames("P")
  #EndIf
  
  #If (CDM_VOLT_116) Then 
  #If (SENSOR_SI111) Then
  'BIOLOGY  
  Average  (1, T_CANOPY, IEEE4, slowsequence_disable_f)         'Measured using SI111
  FieldNames("T_CANOPY")
  #EndIf
  #EndIf
  
EndTable 'Flux_AmeriFluxFormat
'************ END OF FLUX TABLE IN AmeriFlux VARIABLE FORMAT  ************ 


'*************************************************************************
'*****              FLUX TABLE IN CSI VARIABLE FORMAT                *****
'*************************************************************************
DataTable (Flux_CSFormat, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTV, Min, 0)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&"_Flux_CSFormat_", 64, -1, 0, DAY_FLUX_CRD, day, 0, LastFileName_flux_CSFormat)
    
  '*** flux and quality classification data 
  Sample (1, FC_mass, IEEE4)    'Carbon dioxide flux in mg/(m^2 s) after coordinate rotations, freq corrections, and WPL correction
  Sample (1, FC_QC,   IEEE4)    'Overall grade of data quality for carbon dioxide flux (i.e., for variables: Fc and Fc_mass ) according to Foken et al. (2012)
  Totalize (1, n, Long, (sonic_disable_f OR irga_disable_f OR CO2_bad_rng_sig_array(MAX_LAG +1)))    'Totalize the number of samples for CO2 flux
  FieldNames ("FC_samples")

  Sample (1, LE,      IEEE4)    'Latent heat flux after coordinate rotations, freq corrections, and WPL correction
  Sample (1, LE_QC,   IEEE4)    'Overall grade of data quality for latent heat flux (i.e., for variable: LE) according to Foken et al. (2012)
  Totalize (1, n, Long, (sonic_disable_f OR irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))    'Totalize the number of samples for latent heat flux
  FieldNames ("LE_samples")
          
  Sample (1, H,       IEEE4)    'Sensible heat flux (derived from sonic heat flux with SND correction after coordinate rotations and freq corrections)
  Sample (1, H_QC,    IEEE4)    'Overall grade of data quality for sensible heat flux (i.e., for variable: H) according to Foken et al. (2012)
  Totalize (1, n, Long, (sonic_disable_f OR irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))  'Totalize the number of samples for sensible heat flux
  FieldNames ("H_samples")

  #If (SENSOR_FW) Then
  Sample (1, H_FW, IEEE4)                                      'Sensible heat flux measured using fine wire thermocouple (FW) after coordinate rotations and freq corrections
  Totalize (1, n, Long, (sonic_disable_f OR FW_bad_data_flg))  'Totalize the number of samples for FW-measured sensible heat flux
  FieldNames ("H_FW_samples")
  #EndIf
      
  #If (SENSOR_Rn) Then
  Sample (1, NETRAD, IEEE4)
  #EndIf

  #If (SENSOR_HFP AND SENSOR_SWC)  Then
  Sample (1, G_surface, IEEE4)                                'Soil heat flux at the ground surface
  FieldNames ("G")
  Sample (1, SG, IEEE4)                                       'The change in heat storage above soil heat flux plates over the averaging interval 
  #EndIf
   
  #If (SENSOR_Rn AND SENSOR_HFP AND SENSOR_SWC) Then
  Sample (1, energy_closure, IEEE4)                           'Energy closure
  #If (SENSOR_TE525) Then  
  Sample (1, truefalse (2 + poor_energy_closure_flg), String) 'Flag indicates the drift of zero and span
  FieldNames ("poor_enrg_clsur") 
  #EndIf  
  #EndIf

  Sample (1, Bowen_ratio,   IEEE4)

  Sample (1, TAU,           IEEE4)       'Momentum flux after coordinate rotations and freq corrections,
  Sample (1, TAU_QC,        IEEE4)       'Overall grade of data quality for momentum flux (i.e., for variable: TAU) according to Foken et al. (2012)

  '*** Turbulence characteristic variables
  Sample (1, USTAR,         IEEE4)      'Friction velocity after coordinate rotations and freq corrections
  Sample (1, TSTAR,         IEEE4)      'Scaling temperature after coordinate rotations and freq corrections
  Sample (1, TKE,           IEEE4)      'Specific turbulence kinetic energy after coordinate rotations

  '*** Air temperature and humidity 
  Sample (1, TA_1_1_1,      IEEE4)      'Air temperature from EC100 107 temperature probe
  Sample (2, RH_1_1_1,      IEEE4)      'RH_1_1_1, T_DP_1_1_1. Calculated from 107 temperature(TA_1_1_1), H2O, and pressure.
  Sample (1, e_amb_Avg,     IEEE4)      'Water vapor pressure calculated from 107 temperature(TA_1_1_1), H2O, and pressure.
  FieldNames("e_amb")
  Sample (1, e_sat_amb_Avg, IEEE4)      'Saturated water vapor pressure calculated from 107 temperature(TA_1_1_1), H2O, and pressure.
  FieldNames("e_sat_amb")

  Sample (1, TA_1_1_2,      IEEE4)      'Air temperature calculated from sonic temperature, H2O, and pressure
  Sample (2, RH_1_1_2,      IEEE4)      'RH_1_1_2, T_DP_1_1_2. Calculated from sonic temperature, H2O, and pressure.
  Sample (1, e_Avg,         IEEE4)      'Water vapor pressure calculated from sonic temperature, H2O, and pressure.
  FieldNames("e")
  Sample (1, e_sat_Avg,     IEEE4)      'Saturated water vapor pressure calculated from sonic temperature, H2O, and pressure.
  FieldNames("e_sat")  

  #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
  '*** Temperature and humidity probe data   
  Sample (1, TA_1_1_3,      IEEE4)      'Air temperature from temperature and humidity probe
  Sample (2, RH_1_1_3,      IEEE4)      'Measured from temperature and humidity probe: RH_1_1_3, T_DP_1_1_3
  Sample (3, e_probe_Avg,   IEEE4)      'Measured from temperature and humidity probe: e_probe_Avg, e_sat_probe_Avg, H2O_density_probe_Avg
  FieldNames("e_probe,e_sat_probe,H2O_density_probe")
  #EndIf
 
  Sample (1, PA,            IEEE4)      'Atmospheric pressure 
  Sample (1, VPD,           IEEE4)      'Air vapor pressure deficit

  '*** CSAT sonic head data 
  Sample (2, Ux_Avg,        IEEE4)      'Ux_avg and Ux_SIGMA before coordinate rotations
  FieldNames ("Ux,Ux_SIGMA")
  Sample (2, Uy_Avg,        IEEE4)      'Uy_avg and Uy_SIGMA before coordinate rotations
  FieldNames ("Uy,Uy_SIGMA")
  Sample (2, Uz_Avg,        IEEE4)      'Uz_avg and Uz_SIGMA before coordinate rotations
  FieldNames ("Uz,Uz_SIGMA")
  Sample (1, T_SONIC,       IEEE4)      'Average sonic temperature  
  Sample (1, T_SONIC_SIGMA, IEEE4)      'Standard deviation of sonic temperature. 
  Sample (1, sonic_azimuth, IEEE4)      'Sonic_azimuth, (see Section 3.2.1 CSAT3A Azimuth in the OPEC manual).
  Sample (4, WS,            IEEE4)      'WS, WS_RSLT, WD_SONIC, and WD_SIGMA.
  Sample (1, WD,            IEEE4)      'wind direction in compass convention.
  Sample (1, WS_MAX,        IEEE4)      'WS_MAX. 
  '*** Gas data 
  Sample (2, CO2_density_Avg, IEEE4)    'CO2_density_Avg and CO2_density_SIGMA
  FieldNames("CO2_density,CO2_density_SIGMA")
    
  Sample (2, H2O_density_Avg, IEEE4)    'H2O_density_Avg, and H2O_density_SIGMA
  FieldNames("H2O_density,H2O_density_SIGMA")
 
  Minimum (1, CO2_sig_strgth, IEEE4, irga_disable_f, FALSE)
  FieldNames ("CO2_sig_strgth_Min")
  Minimum (1, H2O_sig_strgth, IEEE4, irga_disable_f, FALSE)
  FieldNames ("H2O_sig_strgth_Min")

  #If (SENSOR_FW) Then
  '*** Fine wire thermocouple data
  Sample (1, FW_Avg,     IEEE4)
  FieldNames ("FW")
  Sample (1, FW_SIGMA,   IEEE4)
  #EndIf
   
  #If (SENSOR_TE525) Then
  '*** Rain gauge data
  Totalize (1, P, IEEE4, 0)                 'Precipitation
  FieldNames("P")
  #EndIf
  
  #If (SENSOR_Rn OR SENSOR_CS301 OR SENSOR_CS310 OR SENSOR_CS320) Then 
  '*** Radiometer data 
  #EndIf 
 
  #If (SENSOR_Rn) Then
  Sample  (1, ALB, IEEE4)                                                 'Albedo
  #EndIf

  #If (SENSOR_Rn OR SENSOR_CS301 OR SENSOR_CS320) Then
  Average  (1, SW_IN, IEEE4, slowsequence_disable_f)                      'For use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
  FieldNames("SW_IN")
  #EndIf
  
  #If (SENSOR_Rn) Then
  Sample  (3, SW_OUT, IEEE4)                                              'SW_OUT, LW_IN, and LW_OUT
  #If (SENSOR_NR01 OR SENSOR_CNR4) Then
  Sample  (1, T_nr_Avg,       IEEE4)                                      'Average body temperature of net radiation sensor (T_nr_Avg)
  FieldNames ("T_nr")
  #EndIf
  #If (SENSOR_SN500) Then
  Sample  (2, T_nr_Avg,       IEEE4)                                      'Average body temperature of net radiation sensor SN500
  FieldNames ("T_nr_in,T_nr_out")                                         'T_nr_in and T_nr_out for incoming and outgoing long-wave components, respectively
  #EndIf
  #EndIf '(SENSOR_Rn)

  #If (SENSOR_NR01 OR SENSOR_CNR4) Then
  Average (2, R_LW_in_meas,   IEEE4, slowsequence_disable_f)              'Average raw long-wave incoming radiation (R_LW_in_meas) and outgoing radiation (R_LW_out_meas) w/o temperature correction
  FieldNames ("R_LW_in_meas,R_LW_out_meas")
  #EndIf
  
  #If (SENSOR_CS310) Then
  Average  (1, PPFD_IN, IEEE4, slowsequence_disable_f)
  FieldNames("PPFD_IN")
  #EndIf
    
  Average  (5, sun_azimuth, IEEE4, slowsequence_disable_f)
  FieldNames("sun_azimuth,sun_elevation,hour_angle,sun_declination,air_mass_coeff")
  Totalize (1, daytime_frac_scan_intv, IEEE4, slowsequence_disable_f)
  FieldNames("daytime")
   
  #If (CDM_VOLT_116) Then 
  #If (SENSOR_SI111) Then
  '*** Surface temperature (i.e., canopy temperature) 
  Average  (1, T_CANOPY,     IEEE4, slowsequence_disable_f)
  FieldNames ("T_CANOPY")
  Average  (1, T_SI111_body, IEEE4, slowsequence_disable_f)
  FieldNames ("T_SI111_body")
  #EndIf
  #EndIf '(CDM_VOLT_116)

  #If(SENSOR_TCAV OR SENSOR_SWC)  Then
  '*** Soil temperature
  #EndIf      
  #If (SENSOR_TCAV) Then
  Average (1, TS_1_1_1, IEEE4, slowsequence_disable_f)       'Soil temperature from TCAV
  FieldNames ("TS_1_1_1")
  #If (NMBR_TCAV > 1) Then
  Average (1, TS_1_1_2, IEEE4, slowsequence_disable_f)
  FieldNames ("TS_1_1_2")
  #EndIf
  #If (NMBR_TCAV > 2) Then
  Average (1, TS_1_1_3, IEEE4, slowsequence_disable_f)
  FieldNames ("TS_1_1_3")
  #EndIf
  #EndIf '(SENSOR_TCAV)
  
  #If ((NOT SENSOR_TCAV) AND SENSOR_SWC)  Then
  Average (1, TS_1_1_1, IEEE4, slowsequence_disable_f)       'Soil temperature from CS65x or TDR
  FieldNames ("TS_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, TS_1_1_2, IEEE4, slowsequence_disable_f)
  FieldNames ("TS_1_1_2")
  #EndIf
  #If (NMBR_CS65x > 2) Then
  Average (1, TS_1_1_3, IEEE4, slowsequence_disable_f)
  FieldNames ("TS_1_1_3")
  #EndIf
  #EndIf '((NOT SENSOR_TCAV) AND SENSOR_SWC) 
  
  #If (SENSOR_SWC) Then
  'Soil moisture 
  Average (1, SWC_1_1_1, IEEE4, slowsequence_disable_f)     'CS65x or TDR volumetric soil water content.  
  FieldNames ("SWC_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, SWC_1_1_2, IEEE4, slowsequence_disable_f)
  FieldNames ("SWC_1_1_2")
  #EndIf  
  #If (NMBR_CS65x > 2) Then
  Average (1, SWC_1_1_3, IEEE4, slowsequence_disable_f)
  FieldNames ("SWC_1_1_3")
  #EndIf  
  #EndIf '(SENSOR_SWC)
        
  #If (SENSOR_TCAV AND SENSOR_CS65X)  Then
  Average (1, cs65x_tmpr(1), IEEE4, slowsequence_disable_f)  'Soil temperature from CS65x
  FieldNames ("TS_CS65X_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, cs65x_tmpr(2), IEEE4, slowsequence_disable_f)
  FieldNames ("TS_CS65X_1_1_2")
  #EndIf
  #If (NMBR_CS65x > 2) Then
  Average (1, cs65x_tmpr(3), IEEE4, slowsequence_disable_f)
  FieldNames ("TS_CS65X_1_1_3")
  #EndIf
  #EndIf '(SENSOR_TCAV AND SENSOR_CS65X) 
  
  #If (SENSOR_CS65X) Then
  Average (1, cs65x_ec(1), IEEE4, slowsequence_disable_f)     'Electrical conductivity from CS65x.
  FieldNames ("cs65x_ec_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, cs65x_ec(2), IEEE4, slowsequence_disable_f)
  FieldNames ("cs65x_ec_1_1_2")
  #EndIf
  #If (NMBR_CS65x > 2) Then
  Average (1, cs65x_ec(3), IEEE4, slowsequence_disable_f)
  FieldNames ("cs65x_ec_1_1_3")
  #EndIf
  #EndIf '(SENSOR_CS65X)

  #If (SENSOR_TCAV AND SENSOR_TDR)  Then
  Average (1, tdr_tmpr(1), IEEE4, slowsequence_disable_f)  'Soil temperature from TDR
  FieldNames ("TS_TDR_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, tdr_tmpr(2), IEEE4, slowsequence_disable_f)
  FieldNames ("TS_TDR_1_1_2")
  #EndIf
  #If (NMBR_CS65x > 2) Then
  Average (1, tdr_tmpr(3), IEEE4, slowsequence_disable_f)
  FieldNames ("TS_TDR_1_1_3")
  #EndIf
  #EndIf '(SENSOR_TCAV AND SENSOR_TDR) 
  
  #If (SENSOR_TDR) Then
  Average (1, tdr_E(1), IEEE4, slowsequence_disable_f)  'Soil permittivity from TDR
  FieldNames ("TDR_E_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, tdr_E(2), IEEE4, slowsequence_disable_f)
  FieldNames ("TDR_E_1_1_2")
  #EndIf
  #If (NMBR_CS65x > 2) Then
  Average (1, tdr_E(3), IEEE4, slowsequence_disable_f)
  FieldNames ("TDR_E_1_1_3")
  #EndIf
  
  Average (1, tdr_bulkEC(1), IEEE4, slowsequence_disable_f)  'Soil bulk electrical conductivity
  FieldNames ("TDR_bulkEC_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, tdr_bulkEC(2), IEEE4, slowsequence_disable_f)
  FieldNames ("TDR_bulkEC_1_1_2")
  #EndIf
  #If (NMBR_CS65x > 2) Then
  Average (1, tdr_bulkEC(3), IEEE4, slowsequence_disable_f)
  FieldNames ("TDR_bulkEC_1_1_3")
  #EndIf

  Average (1, tdr_poreEC(1), IEEE4, slowsequence_disable_f)  'Pore water electrical conductivity
  FieldNames ("TDR_poreEC_1_1_1")
  #If (NMBR_CS65x > 1) Then
  Average (1, tdr_poreEC(2), IEEE4, slowsequence_disable_f)
  FieldNames ("TDR_poreEC_1_1_2")
  #EndIf
  #If (NMBR_CS65x > 2) Then
  Average (1, tdr_poreEC(3), IEEE4, slowsequence_disable_f)
  FieldNames ("TDR_poreEC_1_1_3")
  #EndIf
  #EndIf '(SENSOR_TCAV AND SENSOR_TDR) 

  #If (SENSOR_HFP) Then
  '*** soil heat flux plat data 
  Sample (NMBR_HFP, G_plate_1_1_1, IEEE4)                     'Heat flux through a soil heat flux plate
  #EndIf

  #If (SENSOR_HFP AND SENSOR_SWC) Then
  Sample (NMBR_HFP, G_1_1_1,  IEEE4)       'Soil heat flux at the ground surface
  Sample (NMBR_HFP, SG_1_1_1, IEEE4)       'The soil heat flux into soil as heat storage above soil heat flux plates over an averaging interval
  #EndIf

  '*** Footprint characteristics 
  Sample (1, FETCH_MAX,         IEEE4)  'Upwind location of source/sink that contributes most to the measured flux
  Sample (1, FETCH_90,          IEEE4)  'Upwind range within which sources/sinks contributes 90% the measured flux
  Sample (1, FETCH_55,          IEEE4)  'Upwind range within which sources/sinks contributes 55% the measured flux
  Sample (1, FETCH_40,          IEEE4)  'Upwind range within which sources/sinks contributes 40% the measured flux
  Sample (1, UPWND_DIST_INTRST, IEEE4)  'User-entered upwind distance of interest for the average upwind direction in this averaging interval
  Sample (1, FP_DIST_INTRST,    IEEE4)  'Percentage of measured scalar flux from upwind range of interest

  Sample (1, FP_EQUATION,      String)  'Type of footprint equation: Kljun et al or KormannMeixner

  #If (NOT ONE_FL_TABLE) Then
EndTable 'Flux_CSFormat
'*************** END OF FLUX TABLE IN CSI VARIABLE FORMAT ****************


'*************************************************************************
'*****                    FLUX_NOTES TABLE                           *****
'*************************************************************************
DataTable (Flux_Notes, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTV, Min, 0)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&"_Flux_Notes_", 64, -1, 0,DAY_FLUX_CRD, day, 0, 0)
  #EndIf

  '***** CSAT sonic head data  
  '*** Before coordinate rotation
  Sample (2, UxUy_Cov,  IEEE4)    'UxUy_Cov and UxUz_Cov.
  Sample (1, UyUz_Cov,  IEEE4)
  Sample (3, TsUx_Cov,  IEEE4)    'TsUx_Cov, TsUy_Cov, and TsUz_Cov

  '** After coordinate rotations
  'Ux is represented by U, Uy by V, Uz by W, and Ts by T_SONIC, if this rule is not applicable, _R is added for the indication of coordinate-rotated variable. 
  Sample (1, USTAR_R,  IEEE4)    'Friction velocity after coordinate rotations.
  Sample (1, U,        IEEE4)  
  Sample (1, U_SIGMA,  IEEE4)
  Sample (1, V,        IEEE4)
  Sample (1, V_SIGMA,  IEEE4)
  Sample (1, W,        IEEE4)
  Sample (1, W_SIGMA,  IEEE4)
  Sample (1, UV_Cov,   IEEE4)
  Sample (1, UW_Cov,   IEEE4)
  Sample (1, VW_Cov,   IEEE4)
  Sample (1, UT_SONIC_Cov, IEEE4)
  Sample (1, VT_SONIC_Cov, IEEE4)
  Sample (1, WT_SONIC_Cov, IEEE4)

  '*** _fc indicates after frequency corrections
  Sample (1, UW_Cov_fc,       IEEE4)
  Sample (1, VW_Cov_fc,       IEEE4)
  Sample (1, WT_SONIC_Cov_fc, IEEE4)

  '*** After coordinate rotations, freq corrections, and SND correction as indicated by WT_SONIC, fc, and SND.
  Sample (1, WT_SONIC_Cov_fc_SND,  IEEE4)
  
  '**** Summary of diagnosis flags of CSAT
  Totalize (1, n, Long, sonic_disable_f)  'Totalize the number of sonic samples without diagnostic flags
  FieldNames ("sonic_samples") 
  Sample (1, diag_sonic_aggregate, Long)  
  Totalize (1, n, Long, diag_sonic <> -1)
  FieldNames ("no_sonic_head_Tot")
  Totalize (1, n, Long, diag_sonic <> NAN)
  FieldNames ("no_new_sonic_data_Tot")
  Totalize (1, n, Long, sonic_amp_l_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_l_f_Tot")
  Totalize (1, n, Long, sonic_amp_h_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_h_f_Tot")
  Totalize (1, n, Long, sonic_sig_lck_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_sig_lck_f_Tot")
  Totalize (1, n, Long, sonic_del_T_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_del_T_f_Tot")
  Totalize (1, n, Long, sonic_aq_sig_f  IMP (diag_sonic = NAN))
  FieldNames ("sonic_aq_sig_f_Tot")
  Totalize (1, n, Long, sonic_cal_err_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_cal_err_f_Tot")
  
  #If (CSAT3A_EC150) Then 
  #If (CSAT_TYP_3AH) Then 
  '** Summary of variables related to CSAT3AH
  '1. Control commands 
  Totalize (1, -CSAT3H_user_ctrl_on, Long,  slowsequence_disable_f)                               'Times of CSAT3H_user_ctrl_on from CR1000X to heater controller  
  FieldNames ("CSAT3H_user_ctrl_on_Tot")  
  Totalize (1, -CSAT3H_ctrl_on,     Long, ((com_rslt_get = 0) IMP slowsequence_disable_f))        'Times of CSAT3H_ctrl_on in the heater controller itself 
  FieldNames ("CSAT3H_ctrl_on_Tot") 
  
  '2. Transducer heating 
  Average (1, T_trnsd_uppr,       IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f))         'Top transducer temperature
  FieldNames ("T_trnsd_uppr")        
  Minimum (1, T_trnsd_uppr,       IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f), FALSE)  'Top transducer temperature
  FieldNames ("T_trnsd_uppr_Min")
  Average (1, T_trnsd_lwr,        IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f))         'Lower transducer temperature
  FieldNames ("T_trnsd_lwr")
  Minimum (1, T_trnsd_lwr,        IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f), FALSE)  'Lower transducer temperature
  FieldNames ("T_trnsd_lwr_Min")
  Maximum (1, pwr_trnsds,         IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f), FALSE)  'Power heating transducers
  FieldNames ("pwr_trnsd_Max") 
  Totalize (1, trnsd_heater_secs, IEEE4, ((trnsd_heater_on = FALSE) OR (com_rslt_get <> 0) OR slowsequence_disable_f)) 'Transducer heating seconds
  FieldNames("trnsd_heater_secs")
  Totalize (1, -trnsd_heater_fail,Long,  ((com_rslt_get = 0) IMP slowsequence_disable_f))         'Number of transducer heater failure 
  FieldNames("trnsd_heater_fail_Tot")  
  
  '3. Arm heating
  Average (1, T_arm_uppr,       IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f))           'Upper arm temperature 
  FieldNames ("T_arm_uppr")
  Minimum (1, T_arm_uppr,       IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f), FALSE)    'Upper arm temperature 
  FieldNames ("T_arm_uppr_Min")
  Average (1, T_arm_lwr,        IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f))           'Lower arm temperature 
  FieldNames ("T_arm_lwr")
  Minimum (1, T_arm_lwr,        IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f), FALSE)    'Lower arm temperature 
  FieldNames ("T_arm_lwr_Min")
  Maximum (1, pwr_arms,         IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f), FALSE)    'Power heating arms
  FieldNames ("pwr_arms_Max") 
  Totalize (1, arm_heater_secs, IEEE4, ((arm_heater_on = FALSE) OR (com_rslt_get <> 0) OR slowsequence_disable_f))  'Arm heating seconds
  FieldNames("arm_heater_secs")
  Totalize (1, -arm_heater_fail,Long,  ((com_rslt_get = 0) IMP slowsequence_disable_f))           'Number of arm heater failure 
  FieldNames("arm_heater_fail_Tot")  
 
  '4. Houly power used by arms and transducers 
  Sample (1, pwr_hr_trnsds_arms, IEEE4)                                                           'Hourly heater power 
  FieldNames ("pwr_hr_trnsds_arms")   
    
  '5. Variables monitoring CSAT3AH heating
  Totalize (1, trnsd_ice_wet_lck,  Long, ((com_rslt_get = 0) IMP slowsequence_disable_f))         'seconds of sonic transducer locked due to ice and wet  
  FieldNames ("trnsd_ice_wet_lck")
  Totalize (1, -heating_inaplcbl_f,Long, ((com_rslt_get = 0) IMP slowsequence_disable_f))         'Times of flagging sonic heating would be inapplicable to improve the measurements  
  FieldNames ("heating_inaplcbl_f_Tot")
    
  '6. Temperature, TD, and RH 
  Average (1, T_amb_ctrl,   IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f))               'Ambient air temperature (controller)
  FieldNames ("T_amb_ctrl")  
  Minimum (1, T_amb_ctrl,   IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f), FALSE)        'Ambient air temperature (controller)
  FieldNames ("T_amb_ctrl_Min")
  Maximum (1, RH_amb_ctrl,  IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f), FALSE)        'Ambient RH (controller)    
  FieldNames ("RH_amb_ctrl_Max")  
  Maximum (1, T_DP_amb_ctrl,IEEE4, ((com_rslt_get = 0) IMP slowsequence_disable_f), FALSE)        'Ambient dew point temperature (controller)    
  FieldNames ("T_DP_amb_ctrl_Max")
 
  '7. Communication of CR1000X to CR300 in heating control box  
  Totalize (1, n, Long,  ((com_rslt_get = 0) IMP slowsequence_disable_f))                         'Number of success in getting data from CR300 
  FieldNames ("com_rslt_get_Tot") 
  Totalize (1, n, Long,  ((com_rslt_snt = 0) IMP slowsequence_disable_f))                         'Number of success in sending data to CR300 
  FieldNames ("com_rslt_snt_Tot") 
  #EndIf '(CSAT_TYP_3AH)
  #EndIf '(CSAT3A_EC150 )

  '***** IRGA output data ***
  '*** Before coordinate rotation
  Sample  (3, UxCO2_Cov, IEEE4)    'UxCO2_Cov, UyCO2_Cov, UzCO2_Cov
  Sample  (3, UxH2O_Cov, IEEE4)    'UxH2O_Cov, UyH2O_Cov, UzH2O_Cov

  '*** After coordinate rotations 
  '   Ux is represented by U, Uy by V, and Uz by W.
  Sample (1, UCO2_Cov,   IEEE4)
  Sample (1, VCO2_Cov,   IEEE4)
  Sample (1, WCO2_Cov,   IEEE4)

  Sample (1, UH2O_Cov,   IEEE4)
  Sample (1, VH2O_Cov,   IEEE4)
  Sample (1, WH2O_Cov,   IEEE4)

  '*** _fc indicates after frequency corrections based on coordinate rotated variables   
  Sample (1, WCO2_Cov_fc,  IEEE4)
  Sample (1, WH2O_Cov_fc,  IEEE4)
  Sample (1, CO2_E_WPL_fc, IEEE4)    'CO2 flux, WPL term due to water vapor flux (WPL here denotes "WPL term for WPL correction" instead of WPL correction)
  Sample (1, CO2_T_WPL_fc, IEEE4)    'CO2 flux, WPL term due to temperature flux (WPL here denotes "WPL term for WPL correction" instead of WPL correction)
  Sample (1, H2O_E_WPL_fc, IEEE4)    'H2O flux, WPL term due to water vapor flux (WPL here denotes "WPL term for WPL correction" instead of WPL correction)
  Sample (1, H2O_T_WPL_fc, IEEE4)    'H2O flux, WPL term due to temperature flux (WPL here denotes "WPL term for WPL correction" instead of WPL correction)

  '*** Summary of diagnosis flags of IRGA
  Totalize (1, n, Long, (irga_disable_f OR CO2_bad_rng_sig_array(MAX_LAG +1)))
  FieldNames ("CO2_samples")
  Totalize (1, n, Long, (irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  FieldNames ("H2O_samples")
  Sample (1, diag_irga_aggregate, Long)

  Totalize (1, n, Long, diag_irga <> -1)
  FieldNames ("no_irga_head_Tot")
  Totalize (1, n, Long, diag_irga <> NAN)
  FieldNames ("no_new_irga_data_Tot")
  Totalize (1, n, Long, irga_bad_data_f       IMP (diag_irga = NAN))
  FieldNames ("irga_bad_data_f_Tot")
  Totalize (1, n, Long, irga_gen_fault_f      IMP (diag_irga = NAN))
  FieldNames ("irga_gen_fault_f_Tot")
  Totalize (1, n, Long, irga_startup_f        IMP (diag_irga = NAN))
  FieldNames ("irga_startup_f_Tot")
  Totalize (1, n, Long, irga_motor_spd_f      IMP (diag_irga = NAN))
  FieldNames ("irga_motor_spd_f_Tot")
  Totalize (1, n, Long, irga_tec_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_tec_tmpr_f_Tot")
  Totalize (1, n, Long, irga_src_pwr_f        IMP (diag_irga = NAN))
  FieldNames ("irga_src_pwr_f_Tot")
  Totalize (1, n, Long, irga_src_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_src_tmpr_f_Tot")
  Totalize (1, n, Long, irga_src_curr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_src_curr_f_Tot")
  Totalize (1, n, Long, irga_off_f            IMP (diag_irga = NAN))
  FieldNames ("irga_off_f_Tot")
  Totalize (1, n, Long, irga_sync_f           IMP (diag_irga = NAN))
  FieldNames ("irga_sync_f_Tot")
  Totalize (1, n, Long, irga_amb_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_amb_tmpr_f_Tot")
  Totalize (1, n, Long, irga_amb_press_f      IMP (diag_irga = NAN))
  FieldNames ("irga_amb_press_f_Tot")
  Totalize (1, n, Long, irga_CO2_I_f          IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_I_f_Tot")
  Totalize (1, n, Long, irga_CO2_Io_f         IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_Io_f_Tot")
  Totalize (1, n, Long, irga_H2O_I_f          IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_I_f_Tot")
  Totalize (1, n, Long, irga_H2O_Io_f         IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_Io_f_Tot")
  Totalize (1, n, Long, irga_CO2_Io_var_f     IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_Io_var_f_Tot")
  Totalize (1, n, Long, irga_H2O_Io_var_f     IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_Io_var_f_Tot")
  Totalize (1, n, Long, irga_CO2_sig_strgth_f IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_sig_strgth_f_Tot")
  Totalize (1, n, Long, irga_H2O_sig_strgth_f IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_sig_strgth_f_Tot")
  Totalize (1, n, Long, irga_cal_err_f        IMP (diag_irga = NAN))
  FieldNames ("irga_cal_err_f_Tot")
  Totalize (1, n, Long, irga_htr_ctrl_off_f   IMP (diag_irga = NAN))
  FieldNames ("irga_htr_ctrl_off_f_Tot")

  #If (SENSOR_FW) Then
  '*** Beginning of FW output data ***
  '** Before coordinate rotation
  Sample (1, UxFW_Cov, IEEE4)
  Sample (1, UyFW_Cov, IEEE4)
  Sample (1, UzFW_Cov, IEEE4)

   '** After coordinate rotations, Ux is represented by U, Uy by V, and Uz by W.
  Sample (1, UFW_Cov, IEEE4)
  Sample (1, VFW_Cov, IEEE4)
  Sample (1, WFW_Cov, IEEE4)

  ' ** _fc indicates after and freq corrections based on coordinate-rotated data  
  Sample (1, WFW_Cov_fc, IEEE4)
  Totalize   (1, n, Long, FW_bad_data_flg)
  FieldNames ("FW_samples")
  '*** End of FW output data ***
  #EndIf
 
  ' *** Variables used for correction ***
  '** Rotation-related variables
  Sample (1, alpha, IEEE4)                   'Pitch angle
  Sample (1, beta,  IEEE4)                   'Roll angle
  Sample (1, gamma, IEEE4)                   'Yaw angle

  '** Stability-related variables
  Sample (1, height_measurement,    IEEE4)   'Measurement height (m)
  Sample (1, height_canopy,         IEEE4)   'Canopy height (m).
  Sample (1, surface_type_text,    String)   'Crop, Grass, Forest, Shrub, Bare Land, Water, or Ice
  Sample (1, displacement_user,     IEEE4)   'Displacement height input by a user as priority for use in this program (0 is default and d is auto calculated and is used)
  Sample (1, d,                     IEEE4)   'Displacement height used by program (d = displacement_user if displacement_user <> 0; otherwise, it is auto calculated)
  Sample (1, roughness_user,        IEEE4)   'Roughness length input by a user as priority for use in this program (0 is default and z0 is auto calculated and is used)
  Sample (1, z0,                    IEEE4)   'Roughness length used by program z0 = displacement_user if roughness_user <> 0; otherwise, it is auto calculated
  Sample (1, z,                     IEEE4)   'Aerodynamic height
  Sample (1, MO_LENGTH,             IEEE4)   'Monin-Obukhov length
  Sample (1, ZL,                    IEEE4)   'Atmospheric boundary-layer stability.
  Sample (1, iteration_FreqFactor,  IEEE4)   'Iteration number in calculation of freq correction factor for U'W', V'W', and Ts'W'
  Sample (1, latitude,              IEEE4)
  Sample (1, longitude,             IEEE4)
  Sample (1, altitude,              IEEE4)
  Sample (1, UTC_OFST,              Long)
  FieldNames ("UTC_OFFSET")
  
  '** Freq correction related variables
  ' IRGA separation variables
  Sample (2, separation_x_irga,        IEEE4)  'The 12st to 13nd elements of stn_conf_array: separation_x_irga, separation_y_irga
  Sample (1, separation_lat_dist_irga, IEEE4)  'Separation distance in direction normal to wind direction. Used for separation correction
  Sample (1, separation_lag_dist_irga, IEEE4)  'Separation distance along wind direction. Used for lag maximization
  Sample (1, separation_lag_scan_irga, IEEE4)  'Lag in scan number as the wind passes IRGA after passing CSAT. not necessarily to use integer

  #If (SENSOR_FW) Then
  Sample (3, separation_x_FW,          IEEE4)  'The 17th, 18th, and 19th elements of stn_conf_array: separation_x_FW, separation_y_FW, and FW_diameter
  Sample (1, separation_lat_dist_FW,   IEEE4)  'Separation distance in direction normal to wind direction. Used for separation correction
  Sample (1, separation_lag_dist_FW,   IEEE4)  'Separation distance along wind direction. Used for lag maximization
  Sample (1, separation_lag_scan_FW,   IEEE4)  'Lag in scan number the wind passes FW after pass CSAT. not necessary to use integer
  Sample (1, time_const_FW,            IEEE4)
  #EndIf
  
  Sample (1, MAX_LAG,  Long)
  FieldNames ("MAX_LAG")
  Sample (1, lag_irga, IEEE4)

  #If (SENSOR_FW) Then
  Sample (1, lag_FW,   IEEE4)
  #EndIf
 
  Sample (1, FreqFactor_UW_VW,     IEEE4)  'Frequency correction factor for WU and WV
  Sample (1, FreqFactor_WT_SONIC,  IEEE4)  'Frequency correction factor for WT_SONIC
  Sample (1, FreqFactor_WCO2_WH2O, IEEE4)  'Frequency correction factor for covariance of CSI open-path vertical wind with h2o and co2

  #If (SENSOR_FW) Then
  Sample (1, FreqFactor_WFW,       IEEE4)  'Frequency correction factor for covariance of CSAT vertical wind with fine thermocouple (FW) Temperature
  #EndIf

  ' *** Output air properties calculated using measurements
  Sample (2, rho_d_amb_Avg,        IEEE4)  'Density of dry air (g/m^3) and density of moist air (kg/m^3). Calculated from 107 temperature, H2O, and pressure 
  FieldNames ("rho_d_amb,rho_a_amb")  
  Sample (2, rho_d_Avg,            IEEE4)  'Density of dry air (g/m^3) and density of moist air (kg/m^3). Calculated from sonic temperature, H2O, and pressure  
  FieldNames ("rho_d,rho_a")
  
  #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
  '*** Temperature and humidity probe data   
  Sample  (2, rho_d_probe_Avg,     IEEE4)  'Density of dry air (g/m^3) and density of moist air (kg/m^3). Measured from temperature and humidity probe
  FieldNames ("rho_d_probe,rho_a_probe")
  #EndIf

  Sample (1, Cp,       IEEE4)              'Specific heat of moist air at constant pressure, calculated using measurements from IRGA and sonic [J/(kg K)]
  Sample (1, Lv,       IEEE4)              'Latent heat of vaporization [J/g].

  '*** Beginning of other output data ***
  Average(1, T_panel,  IEEE4, FALSE)
  FieldNames ("T_panel")
  Average  (1, V_batt, IEEE4, slowsequence_disable_f)
  FieldNames ("V_batt")
  Totalize (1, n,      Long, slowsequence_disable_f)
  FieldNames ("slowsequence_Tot")
  
  #If (SENSOR_NR01) Then 
  '*** Beginning of recording NR01 heater action ***
   Totalize (1, NR01_heater_secs,  IEEE4, (NOT NR01_heater_on_f))
   FieldNames("nr01_heater_secs")
  #EndIf

  #If (SENSOR_CNR4 AND SENSOR_CNF4) Then 
  '*** Recording CNR4 fan and heater actions 
  Totalize (1, cnr4_fan_secs,      IEEE4, ((NOT cnr4_fan_on_f) OR (cnr4_fan_freq = 0)))
  FieldNames("cnr4_fan_secs")
  Totalize (1, cnr4_heater_1_secs, IEEE4, (NOT cnr4_heater_1_on_f))
  FieldNames("cnr4_heater_1_secs")
  Totalize (1, cnr4_heater_1_secs, IEEE4, (NOT cnr4_heater_2_on_f))
  FieldNames("cnr4_heater_2_secs")
  #EndIf
  
  #If (SENSOR_SN500) Then 
  '*** Beginning of recording SN500 heater actions ***
  Totalize (1, sn500_heater_secs,  IEEE4, (NOT sn500_heater_on_f))
  FieldNames("sn500_heater_secs")
  #EndIf
 
  #If (SENSOR_CS320) Then
  '*** Recording CS320 voltage, temperature, and inclination in three axes 
  Average  (5, V_CS320, IEEE4, slowsequence_disable_f)                    'Averages of voltage, temperature, and three directions for CS320. 
  FieldNames ("V_CS320,T_CS320,x_incline,y_incline,z_incline")
  Totalize (1, CS320_heater_secs,  IEEE4, (NOT CS320_heater_on_f))
  FieldNames("CS320_heater_secs")
  #EndIf 

  '*** Recording the calibrations of self-calibrated soil heat flux plate
  #If (SENSOR_HFP) Then
  Sample (1, shf_plate_cal(1), IEEE4)                                     'Calibrations of soil heat flux plate #1
  FieldNames ("shfp_cal_1_1_1")
  #If (NMBR_HFP > 1) Then
  Sample (1, shf_plate_cal(2), IEEE4)                                     'Calibrations of soil heat flux plate #2
  FieldNames ("shfp_cal_1_1_2")
  #EndIf
  #If (NMBR_HFP > 2) Then
  Sample (1, shf_plate_cal(3), IEEE4)                                     'Calibrations of soil heat flux plate #3
  FieldNames ("shfp_cal_1_1_3")
  #EndIf
  
  #If (SENSOR_HFPSC) Then  
  Sample (1, truefalse (2 + shf_cal_fail_f(1)), String)                   'Self-calibrated sensitivity must be win 80~105% of manufacture one and mV reading must not be NaN. shfp #1 (see HukseFlux HFP01SC manual v1624) 
  FieldNames ("shfp_cal_fail_1_1_1")
  #If (NMBR_HFP > 1) Then
  Sample (1, truefalse (2 + shf_cal_fail_f(2)), String)                   'Self-calibrated sensitivity must be win 80~105% of manufacture one and mV reading must not be NaN. shfp #2 (see HukseFlux HFP01SC manual v1624) 
  FieldNames ("shfp_cal_fail_1_1_2")
  #EndIf 
  #If (NMBR_HFP > 2) Then
  Sample (1, truefalse (2 + shf_cal_fail_f(3)), String)                   'Self-calibrated sensitivity must be win 80~105% of manufacture one and mV reading must not be NaN. shfp #3 (see HukseFlux HFP01SC manual v1624) 
  FieldNames ("shfp_cal_fail_1_1_3")
  #EndIf
  
  #EndIf '(SENSOR_HFPSC)
  #EndIf '(SENSOR_HFP)  

  ' *** Beginning of variables to monitor datalogger performance ***
  Average  (1, process_time, IEEE4, slowsequence_disable_f)
  FieldNames ("process_time")
  Maximum  (1, process_time, IEEE4, slowsequence_disable_f, FALSE)
  FieldNames ("process_time_Max")
  Maximum  (1, buff_depth,   IEEE4, slowsequence_disable_f, FALSE)
  FieldNames ("buff_depth_Max")
EndTable 'Flux_Notes
'*********************** END OF FLUX_NOTES TABLE  ************************


'*************************************************************************
'*****                  TIME SERIES DATA TABLE                       *****
'*************************************************************************
DataTable (Time_Series, TRUE, -1)
  DataInterval (0, SCN_INTV, mSec, 0)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&"_Time_Series_", 64, -1, 0, DAY_TSRS_CRD, day, 0, LastFileName_Time_Series)

  '*** Beginning of CSAT time series output ***
  Sample (3, Ux, IEEE4)
  FieldNames ("Ux,Uy,Uz")
  Sample (1, Ts, IEEE4)
  FieldNames ("T_SONIC")
  Sample (1, diag_sonic, IEEE4)
  FieldNames ("diag_sonic")

  '*** Beginning of IRGA time series output ***
  Sample (1, CO2_density_slow_tmpr, IEEE4)                'Conventional CO2 density 
  FieldNames ("CO2_density")
  Sample (1, CO2_density_fast_tmpr, IEEE4)                'Helbig el al (2016) CO2 density   
  FieldNames ("CO2_density_fast_tmpr")
  Sample (1, H2O_density,           IEEE4)
  FieldNames ("H2O_density")
  Sample (1, diag_irga,             IEEE4)
  FieldNames ("diag_irga")
 
  #If (IRGASON) Then
  Sample (1, Tc,                   IEEE4)
  FieldNames ("T_SONIC_corr")
  #EndIf

  Sample (4, T_amb,IEEE4)
  FieldNames ("TA_1_1_1,PA,CO2_sig_strgth,H2O_sig_strgth")

  #If (SENSOR_FW) Then
  '*** Beginning of FW time series output ***
  Sample (1, FW, IEEE4)
  FieldNames ("FW")
  #EndIf
EndTable 'Time_Series
'******************** END OF TIME SERIES DATA TABLE  *********************


'*************************************************************************
'*****                    DIAGNOSTIC TABLE                           *****
'*************************************************************************
DataTable (Diagnostic, TRUE, 1)
  '*** CSAT diagnosis codes 
  Sample (6, sonic_amp_l_f,    Boolean)
  
  #If (CSAT3A_EC150) Then 
  #If (CSAT_TYP_3AH) Then
  '*** CSAT3AH heating data  
  Sample (1, CSAT3H_user_ctrl_flg, Boolean)     'CSAT3AH heating control start   
  Sample (1, CSAT3H_ctrl_on),      Boolean)     'Control status of CR300 in controller is on if TRUE and off if FALSE 
  
  Sample (1, T_trnsd_uppr, IEEE4)               'Upper transducer temperature  
  Sample (1, T_trnsd_lwr,  IEEE4)               'Lower transducer temperature 
  Sample (1, pwr_trnsds,   IEEE4)               'Power heating transducers
  Sample (1, trnsd_heater_on,  Boolean)         'Transducer heater on (TRUE)/off (FALSE) 
  Sample (1, trnsd_heater_fail,Boolean)         'Transducer heater fail (TRUE)/normal (FALSE) 
    
  Sample (1, T_arm_uppr, IEEE4)                 'Upper arm temperature 
  Sample (1, T_arm_lwr,  IEEE4)                 'Lower arm temperature 
  Sample (1, pwr_arms,   IEEE4)                 'Power heating arms 
  Sample (1, arm_heater_on,    Boolean)         'Arm heater on (TRUE)/off (FALSE) 
  Sample (1, arm_heater_fail,  Boolean)         'Arm heater fail (TRUE)/normal (FALSE)

  Sample (1, pwr_trnsds_arms,    IEEE4)         'Heater power     
  Sample (1, diag_sonic_slwintv, Long)          'Aggregated diagnosis code within a slow scan interval    
    
  Sample (1, trnsd_ice_wet_lck,  Long)          'Seconds of transducers locked due to ice and wet
  Sample (1, heating_inaplcbl_f, Boolean)       'Flag to indicate sonic heating would be inapplicable to improve the measurements  
   
  Sample (1, com_rslt_get, Long)                'Number of failure in communication of CR1000X gets data from CR300   
  Sample (1, com_rslt_snt, Long)                'Number of failure in communication of CR1000X sends data to CR300 

  Sample (1, T_amb_ctrl,   IEEE4)               'Average ambient air temperature (controller) 
  Sample (1, RH_amb_ctrl,  IEEE4)               'Average ambient RH (controller)
  Sample (1, T_DP_amb_ctrl,IEEE4)               'Average ambient dew point temperature (controller)      
  #EndIf '(CSAT_TYP_3BH)
  #EndIf '(CSAT3A_EC150)

  'IRGA Diagnosis 
  Sample (22, irga_bad_data_f, Boolean)
  Sample (4,  CO2_zero_coeff,  IEEE4)
  
  #If (SENSOR_HFPSC) Then 
  Sample (1, shf_cal_fail_f(1), Boolean)       'Self-calibrated sensitivity must be win 80~105% of manufacture one and mV reading must not be NaN. shfp #1 (see HukseFlux HFP01SC manual v1624) 
  FieldNames ("shfp_cal_fail_1_1_1")
  #If (NMBR_HFP > 1) Then
  Sample (1, shf_cal_fail_f(2), Boolean)       'Self-calibrated sensitivity must be win 80~105% of manufacture one and mV reading must not be NaN. shfp #2 (see HukseFlux HFP01SC manual v1624) 
  FieldNames ("shfp_cal_fail_1_1_2")
  #EndIf 
  #If (NMBR_HFP > 2) Then
  Sample (1, shf_cal_fail_f(3), Boolean)      'Self-calibrated sensitivity must be win 80~105% of manufacture one and mV reading must not be NaN. shfp #3 (see HukseFlux HFP01SC manual v1624) 
  FieldNames ("shfp_cal_fail_1_1_3")
  #EndIf
  #EndIf '(SENSOR_HFPSC)
  
EndTable 'Diagnostic
'*********************** END OF DIAGNOSTIC TABLE *************************


'*************************************************************************
'*****                  SYSTEM OPERATION NOTES                       *****
'*************************************************************************
DataTable (System_Operatn_Notes, TRUE, NMBR_RCRDS_OPRTN_NOTES_CPU)    'File size in the number of records 
 CardOut (0,  NMBR_RCRDS_OPRTN_NOTES_CRD)
    
 Sample (1, message, String)
   FieldNames ("Message")
 Sample (2, curr_value_str, String)
  FieldNames ("Current Value,Previous Value")
EndTable 'System_Operatn_Notes
'******************* END OF SYSTEM OPERATION NOTES ***********************



'*************************************************************************
'*****                        SUBROUTINES                            *****
'*************************************************************************

'*** Subroutines for coordinate rotation corrections
' 1. Two Subroutines for Double Rotations
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum with scalar variables

' Definition of double rotation: the 1st AND 2nd rotations in Tanner & Thurtell (1969)
'      a. Counterclockwise about the instrument z-axis for Gamma degrees
'      b. Counterclockwise about the intermediate y-axis for Alpha degrees
'         [Originally clockwise, but in these subroutines following Wilczak et al. (2001) convention of counterclockwise rotation]

'  SUBROUTINE                     MAIN PROGRAM
'  alph                           alpha 
'  bet                            beta
'  gamm                           gamma
'  U_mean, V_mean, W_mean         Ux_Avg, Uy_Avg, Uz_Avg
'  UU_cov, VV_cov, WW_cov         Ux_SIGMA, Uy_SIGMA, Uz_SIGMA
'  UVcov,  UWcov,  VWcov          UxUy_cov, UxUz_cov, UyUz_cov         
'  Umean_R, Vmean_R, Wmean_R      U, V, W
'  UUcov_R, VVcov_R, WWcov_R      U_SIGMA, V_SIGMA, W_SIGMA
'  UVcov_R, UWcov_R, VWcov_R      UV_Cov, UW_Cov, VW_Cov  

'  SU_cov,  SV_cov, SW_cov        SUx_cov,  SUy_cov, SUz_cov   where S is a scalar variable (e.g. CO2, H2O, or T_SONIC)   
'  SUcov_R, SVcov_R, SWcov_R      SU_cov, SV_cov, SW_cov       where S is a scalar variable (e.g. CO2, H2O, or T_SONIC) 
     
' Sub: Rotation12_Momentum (where "12" indicates the 1st and 2nd rotations)
'      Transform the expression of momentum variables in the instrument coordinate system to the natural wind coordinate system.
Sub Rotation12_Momentum(alph, gamm, _
  U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UVcov,   UWcov,   VWcov, _
  Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For efficient calculations, efficient use of memory, and shorter expressions in the following equations, the variables of "UWcov_R" and
  ' "VWcov_R" are used first as intermediate variables before both variables are needed for their own roles.
  UWcov_R =  UU_cov*COS(gamm)*COS(gamm) + VV_cov*SIN(gamm)*SIN(gamm)
  VWcov_R =  UWcov*COS(gamm) + VWcov*SIN(gamm)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = COS(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) - W_mean*SIN(alph)
  Vmean_R = 0
  Wmean_R = SIN(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) + W_mean*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = COS(alph)*COS(alph)*UWcov_R + _
  WW_cov*SIN(alph)*SIN(alph) + UVcov*COS(alph)*COS(alph)*SIN(2*gamm) - _
  SIN(2*alph)*VWcov_R

  VVcov_R = UU_cov*SIN(gamm)*SIN(gamm) + VV_cov*COS(gamm)*COS(gamm) - UVcov*SIN(2*gamm)

  WWcov_R = SIN(alph)*SIN(alph)*UWcov_R  + _
  WW_cov*COS(alph)*COS(alph) + UVcov*SIN(alph)*SIN(alph)*SIN(2*gamm) + _
  SIN(2*alph)*VWcov_R

  ' c. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = -0.5*(UU_cov - VV_cov)*COS(alph)*SIN(2*gamm) + _
  UVcov*COS(alph)*COS(2*gamm) + _
  SIN(alph)*(UWcov*SIN(gamm) - VWcov*COS(gamm))

  UWcov_R =  0.5*SIN(2*alph)*(UWcov_R - WW_cov + UVcov*SIN(2*gamm)) + COS(2*alph)*VWcov_R

  VWcov_R = -SIN(alph)*(0.5*(UU_cov - VV_cov)*SIN(2*gamm)-UVcov*COS(2*gamm))- _
  COS(alph)*(UWcov*SIN(gamm) - VWcov*COS(gamm))

EndSub 'Rotation12_Momentum

' Sub: Rotation12_Scalar_Covariance [where "12" indicates the 1st and 2nd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of variance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in x and y.

Sub Rotation12_Scalar_Covariance(alph, gamm, SU_cov,  SV_cov, SW_cov, SUcov_R, SVcov_R, SWcov_R)

  SUcov_R =  COS(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) - SW_cov*SIN(alph)

  SVcov_R = -SU_cov*SIN(gamm) + SV_cov*COS(gamm)

  SWcov_R =  SIN(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) + SW_cov*COS(alph)

EndSub 'Rotation12_Scalar_Covariance

' 2. Sub-programs for Planar Fit Rotations [Wilczak et al. (2001)]
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum variable with scalar variables

'    Planar Fit Rotations
'      a. Counterclockwise rotation about the instrument y-axis for Alph degrees  [2nd rotation in Tanner and Thurtell (1969), clockwise]
'      b. Counterclockwise rotation about the intermediate x-axis for Beta degrees [3rd rotation in Tanner and Thurtell (1969)]

' Sub: Rotation23_Momentum [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
Sub Rotation23_Momentum(alph, bet, _
  U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UVcov,   UWcov,   VWcov, _
  Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For efficient calculations, efficient use of memory, and shorter expressions in the following equations, the four variables of Wmean_R, UVcov_R,
  ' UWcov_R, and VWcov_R are used first as intermediate variables for repeated terms before the four variables are needed for their own roles.
  Wmean_R =  V_mean*SIN(bet) - W_mean*COS(bet)
  UVcov_R =  VV_cov*SIN(bet)*SIN(bet) - VWcov*SIN(2*bet) + WW_cov*COS(bet)*COS(bet)
  UWcov_R =  UVcov*SIN(bet) - UWcov*COS(bet)
  VWcov_R =  UVcov*COS(bet) + UWcov*SIN(bet)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = U_mean*COS(alph) +  Wmean_R*SIN(alph)
  Vmean_R = V_mean*COS(bet)  +  W_mean *SIN(bet)
  Wmean_R = U_mean*SIN(alph) -  Wmean_R*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = UU_cov*COS(alph)*COS(alph) + UVcov_R*SIN(alph)*SIN(alph) + UWcov_R*SIN(2*alph)

  VVcov_R = VV_cov*COS(bet)*COS(bet)   + VWcov*SIN(2*bet)            + WW_cov*SIN(bet)*SIN(bet)

  WWcov_R = UU_cov*SIN(alph)*SIN(alph) + UVcov_R*COS(alph)*COS(alph) - UWcov_R*SIN(2*alph)

  ' c. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = SIN(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet)- VWcov*COS(2*bet)) + COS(alph)*VWcov_R

  UWcov_R = 0.5*SIN(2*alph)*(UU_cov - VV_cov*SIN(bet)*SIN(bet) - WW_cov*COS(bet)*COS(bet) + VWcov*SIN(2*bet)) - COS(2*alph)*UWcov_R

  VWcov_R = -COS(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet) - VWcov*COS(2*bet))+SIN(alph)*VWcov_R

EndSub 'Rotation23_Momentum

' Sub: Rotation23_Scalar_Covariance [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of covariance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in z.

Sub Rotation23_Scalar_Covariance(alph, bet, _
  SU_cov,   SV_cov,   SW_cov, _
  SU_cov_R, SV_cov_R, SW_cov_R)

  SU_cov_R =  SU_cov*COS(alph) + SIN(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

  SV_cov_R =  SV_cov*COS(bet)  + SW_cov*SIN(bet)

  SW_cov_R =  SU_cov*SIN(alph) - COS(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

EndSub 'Rotation23_Scalar_Covariance


'*** Subroutine to calculate displacement height, roughness length, and aerodynamic height
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' S_type                 Surface_type
' d_user                 displacement_user
' z0_user                Roughness_user
' h_canopy               height_canopy
' h_measurement          height_measurement
' displacement           d
' Roughness              z0
' h_aerodynamic          z (sensing height above the ground - d)

Sub  Displacement_roughness_heights (S_type, d_user, z0_user, h_canopy, h_measurement, displacement, roughness, h_aerodynamic)
  ' Calculate displacement height, roughness length, and aerodynamic height
  If ((S_type = CROP) OR (S_type = GRASS)) Then              'Crop and grass

    Select Case h_canopy
    Case Is = 0.0
      displacement = 0.0                                     'Default w/o canopy
      roughness    = 0.01                                    'Default w/o canopy
    Case Is > 0.0
      displacement = 10.0^(0.979*LOG10(h_canopy)-0.154)      'Crop or grass canopy, Eq. 4.5, page 138 in Rosenberg et al. (1983)
      roughness    = 10.0^(0.977*LOG10(h_canopy)-0.883)      'Crop or grass canopy, Eq. 4.4, page 137 in Rosenberg et al. (1983)
    EndSelect

  EndIf

  If ((S_type = FOREST) OR (S_type = SHRUB)) Then            'Forest and Shrub
    displacement = 2.0*h_canopy/3.0                          'Forest canopy, 2/3 rule, page 116, Oke, 1987
    roughness    = 0.06*h_canopy                             'Forest canopy, Jarvis et al. (1976) ans Raupach et al. (1991)
  EndIf

  If ((S_type = BARELAND) OR (S_type = WATER) OR (S_type = ICE)) Then   'Bare land, water, or ice
    displacement = 0.0                                                  'Default w/o canopy
    roughness    = 0.01                                                 'Default w/o canopy
  EndIf

  If (d_user <> 0.0)  Then displacement = d_user             'User preferred has a priority
  If (z0_user <> 0.0) Then roughness    = z0_user            'User preferred has a priority

  h_aerodynamic = h_measurement - displacement
EndSub 'Displacement_roughness_heights


'*** Subroutines for freq correction factors
'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' freq_factor            FreqFactor_uw_vw

' *** Freq factor for UW and VW
Sub FreqFactorCSAT_UW_VW_BA_LA (height_aerodynamic, stability, U_total, freq_factor)
  'Variables used inside subrotine
  Dim cosp_uw                       'Cospectrum of U or V with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_LA_uu               'Transfer function of line averaging for UU or VV

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of U or V with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of U or V with W
  Dim weight                        'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J As Long                     'Iteration index. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Define intermediate variables to reduce the repeat computation inside iteration loops
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                       'PATH_LENGTH_CSAT/U_total
  Dim PI2_pu_freq_csat              'Intermediate variable 2*PI*pu_csat*freq
  Dim A_uw, B_uw                    'Parameters in the cospectrum of U with W for stable condition

  If ((stability <> NaN) AND (U_total <> NaN)) Then
    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0

    'Prepare calculations
    zu      = height_aerodynamic/U_total
    pu_csat = PATH_LENGTH_CSAT/U_total

    'Calculate parameters in the cospectrum of U with W for stable condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_uw =  0.124*((1.0 + 7.9*stability)^0.75)       'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1.0 + 7.9*stability)^(-0.825))   'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4   'Similarity functions are defined in a range of stability from -2 to 2 (pgs 17, 28, 41~43, Kaimal & Finnigan 1994). Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_uw =  0.124*((1.0 + 7.9*4.0)^0.75)             'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1.0 + 7.9*4.0)^(-0.825))         'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    ' Calculate correction factor
    For J = 0 To FREQ_BIN
      freq  = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2.0*PI*pu_csat*freq

      '** Cospectrum
      If stability > 0.0 Then
        cosp_uw = freq*zu/(A_uw + B_uw*(freq*zu)^2.1)             'Eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                     'Eq. 26 in Moore (1986), eqs. 17 & 18 in Moncrieff et al (1997), eq. 2.85 in Dijk (2002)
        Case Is < 0.24
          cosp_uw = 20.78*freq*zu/((1.0 + 31.0*freq*zu)^1.575)
        Case Is >= 0.24
          cosp_uw = 12.66*freq*zu/((1.0 + 9.6*freq*zu)^2.4)
        EndSelect
      EndIf

      '** Transfer function
      tran_func_BA    = 1.0 - (SIN (10800*OUTPUT_INTV*freq)/(PI*60*OUTPUT_INTV*freq))^2   'Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Inside SIN(), angle degrees must be used.
      tran_func_LA_uu = (SIN (180.0*pu_csat*freq)/(PI*pu_csat*freq))^2.0                  'Eq. 2.70 in Dijk (2002)

      If PI2_pu_freq_csat >= 0.01 Then
        tran_func_LA_ww = (4.0/PI2_pu_freq_csat)*(1.0 + (PI2_pu_freq_csat + 3.0)/(2.0*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) - 3.0/(2.0*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), pg. 610 in Moncrieff et al. (1997)
      Else
        tran_func_LA_ww = 1.0 'Due to single precision in CR1000X, this term cannot be calculated when the 2*Pi*dimensionless_freq < 0.01. This is an approximation. The error in the approximation is < 0.001
      EndIf

      ' Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator   += weight*cosp_uw

      freq_factor_denominator += weight*cosp_uw*tran_func_BA*SQR(tran_func_LA_uu*tran_func_LA_ww)

    Next J

    '** correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1.0
  EndIf
EndSub 'FreqFactorCSAT_UW_VW_BA_LA

' *** Frequency factor for wTs

'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
' height_aerodynamic     z
' Stability              ZL
' U_total                WS_rslt
' tran_func_LA_Dijk()    tran_func_LA_data_Dijk()
' freq_factor            FreqFactor_WT_SONIC

Sub FreqFactorCSAT_wTs_BA_LA (height_aerodynamic, stability, U_total, tran_func_LA_Dijk(2,35), freq_factor)
  'Variables used inside subrotine
  Dim cosp_wTs                 'Copectrum of Ts (T_SONIC) with W
  Dim tran_func_BA             'Transfer function of block averaging for covariance
  Dim Tran_func_LA_wTs         'Transfer function of line averaging for WT_SONIC

  Dim freq                     'Cyclic frequency
  Dim freq_factor_numerator    'Numerator to calculate the freq correction factor for covariance of T_SONIC with W
  Dim freq_factor_denominator  'Denominator to calculate the freq correction factor for covariance of T_SONIC with W
  Dim weight                   'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J  As Long               'Index for the outmost iteration. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  Dim jj As Long               'Index for the iteration inside the outmost iteration
  Dim Prev_jj As Long

  'Define following variables for saving computation time by calculating these once outside iteration loops or reduce the repeat computations
  Dim zu                       'z/U_total, ratio of aerodynamic height to total horizontal velocity 
  Dim pu_csat                  'PATH_LENGTH_CSAT/U_total
  Dim PI2_pu_freq_csat         'Intermediate variable 2*PI*pu_csat*freq
  Dim A_wTs, B_wTs             'Parameters in the cospectrum of T_SONIC with W in stable condition

  If ((stability <> NaN) AND (U_total <> NaN)) Then

    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0
    Prev_jj                 = 1

    'Prepare calculations
    zu      = height_aerodynamic/U_total
    pu_csat = PATH_LENGTH_CSAT/U_total

    'Calculate parameters in the cospectrum of W with T_SONIC for stable condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_wTs = 0.2840*((1.0 + 6.4*stability)^0.75)               'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1.0 + 6.4*stability)^(-0.825))           'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4.0  'Similarity functions are defined in a range of stability (ZL) from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994).  Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_wTs = 0.2840*((1.0 + 6.4*4.0)^0.75)                     'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1.0 + 6.4*4.0)^(-0.825))                 'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Start calculations for correction factor
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2.0*PI*pu_csat*freq

      '**Cospectrum
      If (stability > 0.0) Then
        cosp_wTs   = zu*freq/(A_wTs + B_wTs*(zu*freq)^2.1)      'Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                     'Eq.25 in Moore (1986), eqs.15 & 16 in Moncrieff et al. (1997), eq.2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wTs = 12.92*zu*freq/((1 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wTs =  4.378*zu*freq/((1 + 3.8*zu*freq)^2.4)     '4.378 from original source Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '**Transfer function
      tran_func_BA = 1.0 - (SIN (10800*OUTPUT_INTV*freq)/(PI*60*OUTPUT_INTV*freq))^2.0   'Eq.4 in Kaimal et al (1989), Eq.3 in Massman (2000)

      For jj = Prev_jj To 34
        If  (PI2_pu_freq_csat >= tran_func_LA_Dijk(1,jj)) AND  (PI2_pu_freq_csat < tran_func_LA_Dijk(1, jj+1)) Then

          Tran_func_LA_wTs = tran_func_LA_Dijk(2,jj) + (PI2_pu_freq_csat - tran_func_LA_Dijk(1,jj))*(tran_func_LA_Dijk(2,jj+1) _
                             -tran_func_LA_Dijk(2,jj))/(tran_func_LA_Dijk(1,jj+1) - tran_func_LA_Dijk(1,jj))
          Prev_jj = jj

          ExitFor
        EndIf
      Next jj

      If (PI2_pu_freq_csat >= tran_func_LA_Dijk(1, 35)) Then Tran_func_LA_wTs = tran_func_LA_Dijk(2, 35)

      'Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in sequential order.

      freq_factor_numerator   += weight*cosp_wTs
      freq_factor_denominator += weight*cosp_wTs*tran_func_BA*Tran_func_LA_wTs

    Next J

    '**Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1.0
  EndIf
EndSub 'FreqFactorCSAT_wTs_BA_LA


' Calculate separation of scalar sensor sensing center to CSAT measurement center
'    1. Separation distance normal to wind direction (effective separation distance)
'    2. Separation distance along with wind direction (effective lag distance)
 
'         Variable Notation  
'  SUBROUTINE             MAIN PROGRAM
'  wnd_dir                WD_SONIC
'  separation_x           separation_x_IRGA or separation_x_FW
'  separation_y           separation_y_IRGA or separation_y_FW
'  separation_lat_dis     separation_lat_dist_IRGA or separation_lat_dist_FW
'  separation_lag_dis     separation_lag_dist_IRGA or separation_lag_dist_FW

Sub Separation_Lag_Lateral_Distances (wnd_dir, separation_x, separation_y, separation_lat_dis, separation_lag_dis)
  separation_lag_dis =  separation_x*COS(wnd_dir) + separation_y*SIN(wnd_dir)
  separation_lat_dis = -separation_x*SIN(wnd_dir) + separation_y*COS(wnd_dir)
EndSub 'Separation_Lag_Lateral_Distances


' *** Freq factor of CSAT + CSI IRGA for WCO2 and WH2O
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' separation_lat_dis     separation_lat_dist_IRGA
' Freq_factor            FreqFactor_wco2_wh2o

Sub FreqFactorCSOPEC_wco2_wh2o_BA_LA_SP (height_aerodynamic, stability, U_total, separation_lat_dis, freq_factor)
  'Variables used inside subrotine
  Dim cosp_wco2_wh2o                'Cospectrum of CO2 or H2O with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_LA_co2_h2o          'Transfer function of line averaging for variance of CO2 or H2O
  Dim tran_func_SP_wco2_wh2o        'Transfer function of lateral separation (normal to the wind direction) between CSAT for W and IRGA for CO2 or H2O

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of CO2 or H2O with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of CO2 or H2O with W
  Dim weight                        'Weight factor in the numerical integration of Composite Simpson's Rule
  Dim J As Long                     'Iteration index. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Define following variables for saving computation time by calculating these once outside iteration loops or by reducing repeat computations
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                       'path_length_cast/U_total
  Dim pu_irga                       'path_length_irga/U_total
  Dim du_irga                       'Ratio of effective lateral separation distance (normal to wind) to total wind speed
  Dim PI2_pu_csat                   'Intermediate variable 2*Pi*pu_csat
  Dim PI2_pu_irga                   'Intermediate variable 2*Pi*pu_irga
  Dim PI2_pu_freq_csat              'Intermediate variable 2*Pi*pu_csat*freq
  Dim PI2_pu_freq_irga              'Intermediate variable 2*Pi*pu_irga*freq
  Dim A_wco2_wh2o, B_wco2_wh2o      'Parameters in the cospectrum of scalar (e.g. CO2 or H2O) with W

  If ((stability <> NaN) AND (U_total <> NaN) AND (separation_lat_dis <> NaN)) Then

    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0

    'Prepare calculations
    zu      = height_aerodynamic/U_total
    pu_csat = PATH_LENGTH_CSAT/U_total
    pu_irga = PATH_LENGTH_IRGA/U_total
    du_irga = ABS(separation_lat_dis)/U_total
    PI2_pu_csat = 2.0*PI*pu_csat
    PI2_pu_irga = 2.0*PI*pu_irga

    'Calculate parameters in the cospectrum of W with CO2 or H2O for stable condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_wco2_wh2o = 0.2840*((1.0 + 6.4*stability)^0.75)         'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wco2_wh2o = 9.3447*((1.0 + 6.4*stability)^(-0.825))     'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4   'Similarity functions are defined in a range of Stability (ZL) from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994). Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_wco2_wh2o = 0.2840*((1.0 + 6.4*4.0)^0.75)               'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wco2_wh2o = 9.3447*((1.0 + 6.4*4.0)^(-0.825))           'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Start calculations for correction factors
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat  = PI2_pu_csat*freq
      PI2_pu_freq_irga  = PI2_pu_irga*freq

      '**Cospectrum
      If stability > 0.0 Then
        cosp_wco2_wh2o = zu*freq/(A_wco2_wh2o + B_wco2_wh2o*(zu*freq)^2.1)    'Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                                 'Eq. 25 in Moore (1986), eqs. 15 & 16 in Moncrieff et al (1997), eq. 2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wco2_wh2o = 12.92*zu*freq/((1.0 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wco2_wh2o =  4.378*zu*freq/((1.0 + 3.8*zu*freq)^2.4)           '4.378 from original source of Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '** Transfer functions
      tran_func_BA = 1.0 - (SIN (10800.0*OUTPUT_INTV*freq)/(PI*60.0*OUTPUT_INTV*freq))^2.0  'Block averaging: Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Angle degree must be used inside SIN().

      tran_func_SP_wco2_wh2o = EXP(-9.9*(du_irga*freq)^1.5)                                 'Spatial separation: Eq. 4.8 in Foken et al. (2012)

      If PI2_pu_freq_csat >= 0.01 Then                                                      'Line averaging
        tran_func_LA_ww  = (4.0/PI2_pu_freq_csat)*(1.0+ (PI2_pu_freq_csat+3.0)/(2.0*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) -3.0/(2.0*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), page 610 in Moncrieff et al (1997)
      Else
        tran_func_LA_ww  = 1.0       'Due to single precision in CR1000X, this term cannot be calculated when the 2PI*dimensionless_frequency < 0.01. This is an approximation with an error < 0.001.
      EndIf

      If PI2_pu_freq_irga >= 0.01 Then
        tran_func_LA_co2_h2o = (1.0/PI2_pu_freq_irga)*(3.0 + (PI2_pu_freq_irga + 4.0)/(PI2_pu_freq_irga*EXP(PI2_pu_freq_irga)) -4.0/PI2_pu_freq_irga)      'Eq. 7 in Moore (1986), page 610 in Moncrieff et al (1997)
      Else
        tran_func_LA_co2_h2o  = 1.0   'Due to single precision in CR1000X, this term cannot be calculated when the normalized frequency < 0.01 Hz. This is an approximation with an error < 0.001
      EndIf

      'Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator    += weight*cosp_wco2_wh2o

      freq_factor_denominator  += weight*cosp_wco2_wh2o*tran_func_BA*SQR(tran_func_LA_ww*tran_func_LA_co2_h2o)*Tran_func_SP_wco2_wh2o

    Next J

    '** Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1.0
  EndIf

EndSub 'FreqFactorCSOPEC_wco2_wh2o_BA_LA_SP


#If (SENSOR_FW) Then  
'*** Subroutine for time constant of FW sensor
'         Variable Notation 
'  SUBROUTINE             MAIN PROGRAM
'  FW_D                   FW_diameter
'  FW_temperature         fw_avg
'  U_total                WS_rslt
'  density_moist_air      rho_a_avg

Sub Time_Const_Thermocouple_E(FW_D, FW_temperature, U_total, density_moist_air, time_const)
  Const C_TC_E   =  420.7734       'Specific heat of junction of thermocouple E [J/(kg deg C)]
  Const rho_TC_E =  8825           'Specific gravity (material density) of junction of thermocouple E [kg/m^3]

  Dim K_air                        'Thermal conductivity of air [W/(m deg C)]
  Dim mu_air                       'Viscosity of air [kg/(m s)]
  Dim Re                           'Reynold number (adimensional).
  Dim Nu                           'Nusselt Number (adimensional)
  Dim h_tc                         'Convective heat transfer coefficient [W/(m^2 deg C)]

  K_air  = 2.42508e-2 + 7.038086e-5*FW_temperature     'Table 1 Montgomery (1947)
  mu_air = 1.716800e-5 + 4.982100e-8*FW_temperature    'Table 1 Montgomery (1947)

  Re = (density_moist_air*(0.5*FW_D)*U_total)/mu_air   'Reynold number
  Nu = 2.0 +0.181*Re^0.67                              'Nusselt Number     
  
  h_tc = (K_air*Nu)/(0.5*FW_D)                         'Convective heat transfer coefficient

  time_const = ((0.5*FW_D*rho_TC_E*C_TC_E)/h_tc)       'Time constant
EndSub 'Time_Const_Thermocouple_E


' *** Frequency factor of CSAT + FW for WT_FW (T_FW is the temperature measured using fine wire thermocouple of FW05, FW1, FW2, or FW3)  
  
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' separation_lat_dis     separation_lat_dist_FW
' time_const             time_const_FW
' Freq_factor            FreqFactor_wFW

Sub FreqFactorCSATFW_wT_BA_LA_TC_SP (height_aerodynamic, stability, U_total, separation_lat_dis, time_const, freq_factor)
  'Variables used inside subroutine
  Dim cosp_wT                       'Cospectrum of T with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_TC_TT               'Transfer function of time constant for TT
  Dim tran_func_SP_wT               'Transfer function of lateral separation between CSAT3 w and FW T
  Dim A_wT, B_wT                    'Parameters in the cospectrum of air temperature with W in the stable condition

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of T with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of T with W
  Dim weight                        'Weight factor in the numerical integration of Composite Simpson's Rule.
  Dim J As Long                     'Iteration index. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
         
  'Define following variables for saving computation time by calculating these once outside iteration loops or by reducing repeat computation
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim du_FW                         'The ratio of effective lateral separation distance to total wind speed
  Dim PI2_pu_csat                   'Intermediate variable 2*Pi*PATH_LENGTH_CSAT/U_total
  Dim PI2_pu_freq_csat              'Intermediate variable 2*Pi*(PATH_LENGTH_CSAT/U_total)*freq

  If ((stability <> NaN) AND (U_total <> NaN) AND (separation_lat_dis <> NaN) AND (time_const <> NaN)) Then
    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0

    'Prepare calculations
    zu          = height_aerodynamic/U_total
    PI2_pu_csat = 2.0*PI*PATH_LENGTH_CSAT/U_total
    du_FW       = ABS(separation_lat_dis)/U_total

    'Calculate the parameters in the cospectrum of air temperature with W for a stable surface-layer condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_wT = 0.2840*((1.0 + 6.4*stability)^0.75)        'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wT = 9.3447*((1.0 + 6.4*stability)^(-0.825))    'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4  'Similarity functions are defined in a range of ZL from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994). Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_wT = 0.2840*((1.0 + 6.4*4.0)^0.75)              'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wT = 9.3447*((1.0 + 6.4*4.0)^(-0.825))          'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Calculate correction factor
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = PI2_pu_csat*freq

      '** Cospectrum
      If (stability > 0.0) Then
        cosp_wT   = zu*freq/(A_wT + B_wT*(zu*freq)^2.1)          'Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                    'Eq. 25 in Moore (1986), eqs. 15 & 16 in Moncrieff et al. (1997), eq. 2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wT = 12.92*zu*freq/((1.0 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wT =  4.378*zu*freq/((1.0 + 3.8*zu*freq)^2.4)       '4.378 from original source of Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '** Transfer function
      tran_func_BA    = 1.0 - (SIN (10800.0*OUTPUT_INTV*freq)/(PI*60.0*OUTPUT_INTV*freq))^2.0     'Block averaging: Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Angle degree must be sued inside SIN().
      tran_func_SP_wT = EXP(-9.9*(du_FW*freq)^1.5)                                                'Spatial separation: Eq. 4.8 in Foken et al. (2012)
      tran_func_TC_TT = 1.0/(1.0 + (2.0*PI*time_const*freq)^2.0)                                  'Time constant: Eq. 5 Horst (1997)

      If (PI2_pu_freq_csat >= 0.01) Then
        tran_func_LA_ww  = (4.0/PI2_pu_freq_csat)*(1.0 + (PI2_pu_freq_csat + 3.0)/(2.0*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) - 3.0/(2.0*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), pg. 610 in Moncrieff et al. (1997)
      Else
        tran_func_LA_ww  = 1.0   'Due to single precision in CR1000X, this term cannot be calculated when 2PI*dimensionless_frequency < 0.01. This is an approximation with an error < 0.001.
      EndIf

      'Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator   += weight*cosp_wT
      freq_factor_denominator += weight*cosp_wT*tran_func_BA*SQR(tran_func_LA_ww*tran_func_TC_TT) *Tran_func_SP_wT
    Next J
    
    '**Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
    
  Else

    freq_factor = 1.0
  EndIf
EndSub 'FreqFactorCSATFW_wT_BA_LA_TC_SP
#EndIf


'*** Subroutines for data quality classification ***
'a. Data quality grading for momentum flux using steady state test, integral turbulence characteristics, and horizontal wind orientation relative to the CSAT coordinate system   
'   Foken et al. (2012)
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Planar_fit            Planar_Fit_flg
'  stability             ZL
'  SIGMA_u               U_SIGMA
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  lat                   latitude
'  wnd_dir               WD_SONIC
'  RNS                   RN_UW_VW_cov      RNS: Relative Non-Stationarity
'  QC                    TAU_QC            Quality Classes 1 to 9.

Sub Data_Quality_SSITC_w_WndDir_Momentum (Planar_Fit As Boolean, stability, SIGMA_u, SIGMA_w, U_star, lat, wnd_dir, RNS, QC)
  ' Test on turbulence conditions in development
  Dim    ITC_uw(2)                              'ITC: Integral Turbulence Characteristic. This array is used in instruction MaxSpa to select max
  Alias  ITC_uw(1) = ITCuu                      'ITC for variance of horizontal velocity
  Alias  ITC_uw(2) = ITCww                      'ITC for variance of vertical velocity

  Dim    ITC_uw_max(2)                          'for use of instruction MaxSpa. Hold the max and the index of max location
  Alias  ITC_uw_max(1) = ITC_uu_ww              'ITC for momentum flux
  Alias  ITC_uw_max(2) = ITC_uu_ww_max_seq      'the index of max location

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean                'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean                'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Momentum_1st_Occurrence   'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Momentum_1st_Occurrence   'The lowest possible grade of ITC in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Momentum_1st_Occurrence   'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'for use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature 
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
 
 'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible grade for Relative Non-Stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS < 10.0))

  For J = 1 To 8
    RNS_Momentum_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                    'Omega: earth angular velocity

  Select Case stability
  Case Is <= -0.032
    ITCuu = 4.15*ABS(stability)^0.125                      'Table 4.2 (Foken et al. 2012)
    ITCww = 2.00*ABS(stability)^0.125                      'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0
    ITCuu = 2.7                                            'Table 4.2 (Foken et al. 2012)
    ITCww = 1.3                                            'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0
    ITCuu = 0.44*LN(ABS(Coriolis_parameter)/U_star) + 6.3  'Table 4.3 (Foken et al. 2012)
    ITCww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITCuu = -(SIGMA_u/U_star)/9.1                           'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
    ITCww = -(SIGMA_w/U_star)/9.1                           'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITCuu = ABS((ITCuu - (SIGMA_u/U_star))/ITCuu)              'In fraction
  ITCww = ABS((ITCww - (SIGMA_w/U_star))/ITCww)              'In fraction

  If (NOT Planar_Fit) Then
    'If double rotations, both the max of ITC_uu and ITC_ww is used as ITC_uu_ww.
    MaxSpa(ITC_uu_ww, 2, ITCuu)                               'Max is used for momentum flux related to uw and vw
  Else
    'If planar fit, only ITC_ww is used as ITC_uu_ww.
    ITC_uu_ww = ITCww
  EndIf

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_uu_ww < 0.31)
  ITC_category(2) = (ITC_uu_ww < 0.31)
  ITC_category(3) = ((ITC_uu_ww >= 0.31) AND (ITC_uu_ww < 0.76))
  ITC_category(4) = (ITC_uu_ww < 0.31)
  ITC_category(5) = ((ITC_uu_ww >= 0.31) AND (ITC_uu_ww < 1.01))
  ITC_category(6) = ((ITC_uu_ww >= 0.76) AND (ITC_uu_ww < 1.01))
  ITC_category(7) = ((ITC_uu_ww >= 1.01) AND (ITC_uu_ww < 2.51))
  ITC_category(8) = ((ITC_uu_ww >= 2.51) AND (ITC_uu_ww < 10.00))

  For J = 1 To 8
    ITC_Momentum_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. Wind direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir < 151.0) OR (wnd_dir > 209.0)) Then
    Wnd_Momentum_1st_Occurrence = 1
  ElseIf (((wnd_dir >= 151.0) AND (wnd_dir < 171.0)) OR ((wnd_dir > 189.0) AND (wnd_dir <= 209.0)))
    Wnd_Momentum_1st_Occurrence = 7
  ElseIf ((wnd_dir >= 171.0) AND (wnd_dir <= 189.0))
    Wnd_Momentum_1st_Occurrence = 0
  EndIf

  '1st case
  If ((RNS_Momentum_1st_Occurrence = 0) OR (ITC_Momentum_1st_Occurrence =0) OR (Wnd_Momentum_1st_Occurrence = 0)) Then        'Any in category 9 (0 used for 9 now)
    QC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Momentum_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_uu_ww = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN

EndSub 'Data_Quality_SSITC_w_WndDir_Momentum


'b. Data quality grading for momentum flux using steady state test and integral turbulence characteristics.
'   Foken et al. (2004).    
  
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Planar_fit            Planar_Fit_flg
'  stability             ZL
'  SIGMA_u               U_SIGMA
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  lat                   latitude
'  RNS                   RN_UW_VW_cov      RNS: Relative Non-Stationarity
'  TAU_SSITC             TAU_SSITC_TEST    Quality Classes 1 to 9.

Sub Data_Quality_SSITC_wo_WndDir_Momentum (Planar_Fit As Boolean, stability, SIGMA_u, SIGMA_w, U_star, lat, RNS, TAU_SSITC)
  ' Test on turbulence conditions in development
  Dim    ITC_uw(2)                              'ITC: Integral Turbulence Characteristic. This array is used in instruction MaxSpa to select max
  Alias  ITC_uw(1) = ITCu                       'ITC for variance of horizontal velocity
  Alias  ITC_uw(2) = ITCw                       'ITC for variance of vertical velocity

  Dim    ITC_uw_max(2)                          'for use of instruction MaxSpa. Hold the max and the index of max location
  Alias  ITC_uw_max(1) = ITC_u_w                'ITC for momentum flux
  Alias  ITC_uw_max(2) = ITC_u_w_max_seq        'the index of max location

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean                'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean                'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(2)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Momentum_1st_Occur   'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Momentum_1st_Occur   'The lowest possible grade of ITC in the overall grade system
 
  Dim Lowest_Seq_Max(2)                                         'for use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                 'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature 
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
 
 'Reset
  TAU_SSITC = 0

  '1. Relative Non-Stationarity
  'Possible grade for Relative Non-Stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS  < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Momentum_1st_Occur = -J *RNS_category(J)
    If (RNS_Momentum_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                   'Omega: earth angular velocity

  Select Case stability
  Case Is <= -0.032
    ITCu = 4.15*ABS(stability)^0.125                      'Table 9.1 (Foken et al. 2004)
    ITCw = 2.00*ABS(stability)^0.125                      'Table 9.1 (Foken et al. 2004)

  Case Is > -0.032 AND Is <= 0
    ITCu = 2.7                                            'Table 9.1 (Foken et al. 2004)
    ITCw = 1.3                                            'Table 9.1 (Foken et al. 2004)

  Case Is < 0.4 AND Is > 0
    ITCu = 0.44*LN(ABS(Coriolis_parameter)/U_star) + 6.3  'Table 9.2 (Foken et al. 2004)
    ITCw = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 9.2 (Foken et al. 2004)

  Case Is >= 0.4
    ITCu = -(SIGMA_u/U_star)/9.1                          'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
    ITCw = -(SIGMA_w/U_star)/9.1                          'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITCu = ABS((ITCu - (SIGMA_u/U_star))/ITCu)              'In fraction
  ITCw = ABS((ITCw - (SIGMA_w/U_star))/ITCw)              'In fraction

  If (NOT Planar_Fit) Then
    'If double rotations, the max of ITC_u and ITC_w is used as ITC_u_w.
    MaxSpa(ITC_u_w, 2, ITCu)                             'Max is used for momentum flux related to uw and vw
  Else
    'If planar fit, only ITC_w is used as ITC_u_w.
    ITC_u_w = ITCw
  EndIf

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_u_w < 0.31)
  ITC_category(2) = (ITC_u_w < 0.31)
  ITC_category(3) = ((ITC_u_w >= 0.31) AND (ITC_u_w < 0.76))
  ITC_category(4) = (ITC_u_w < 0.31)
  ITC_category(5) = ((ITC_u_w >= 0.31) AND (ITC_u_w < 1.01))
  ITC_category(6) = ((ITC_u_w >= 0.76) AND (ITC_u_w < 1.01))
  ITC_category(7) = ((ITC_u_w >= 1.01) AND (ITC_u_w < 2.51))
  ITC_category(8) = ((ITC_u_w >= 2.51) AND (ITC_u_w < 10.00))

  For J = 1 To 8
    ITC_Momentum_1st_Occur = -J *ITC_category(J)
    If (ITC_Momentum_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '1st case
  If  ((RNS_Momentum_1st_Occur = 0) OR (ITC_Momentum_1st_Occur =0)) Then        'Any in category 9 (0 used for 9 now)
    TAU_SSITC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 2, RNS_Momentum_1st_Occur)
    TAU_SSITC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_u_w = NaN)) AND (TAU_SSITC = 9)) Then  TAU_SSITC = NaN

EndSub 'Data_Quality_SSITC_wo_WndDir_Momentum


'c. Data quality grading for scalar flux using steady state test, integral turbulence characteristics, and horizontal wind orientation relative to the CSAT coordinate system 
'   Foken et al. (2012) 
'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
'  stability             ZL
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  Ts_std                T_SONIC_SIGMA
'  T_star                TSTAR
'  lat                   latitude
'  wnd_dir               WD_SONIC
'  RNS                   RN_WT_SONIC_cov, RN_WCO2_Cov, or RN_WH2O_Cov     Relative Non-Stationarity
'  QC                    Fc_QC, LE_QC, or H_QC                            Quality Classes 1 to 9.

Sub Data_Quality_SSITC_w_WndDir_Scalar (stability, SIGMA_w, U_star, Ts_std, T_star, lat, wnd_dir, RNS, QC)
  ' Test on developed turbulence conditions
  Dim ITC_TsTs                             'ITC (Integral Turbulence Characteristics) for variance of T_SONIC. 
  Dim ITC_wTs                              'ITC for variance of vertical wind speed with T_SONIC. 
  Dim ITC_ww                               'ITC for variance of vertical wind. 

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean           'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean           'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Scalar_1st_Occurrence     'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Scalar_1st_Occurrence     'The lowest possible grade of ITC in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Scalar_1st_Occurrence     'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'For use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
    
  'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS  < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Scalar_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                    'Omega: earth angular velocity

  'Test on developed turbulence conditions for a scalar flux using the integral turbulence characteristic
  Select Case stability
  Case Is <= -0.032
    ITC_ww = 2.00*ABS(stability)^0.125                       'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0.0
    ITC_ww = 1.3                                             'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0.0
    ITC_ww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITC_ww = -(SIGMA_w/U_star)/9.1                          'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect
  
    ITC_ww = ABS((ITC_ww - (SIGMA_w/U_star))/ITC_ww)        'In fraction

  Select Case stability
  Case Is < -1.0
    ITC_TsTs = ABS(stability)^(-1/3)                        'Table 4.2 (Foken et al. 2012)

  Case Is <= -0.062 AND Is >= -1.0
    ITC_TsTs = ABS(stability)^(-0.25)                       'Table 4.2 (Foken et al. 2012)

  Case Is < 0.02 AND Is > -0.062
    ITC_TsTs = 0.5*ABS(stability)^(-0.50)                   'Table 4.2 (Foken et al. 2012)

  Case  Is >= 0.02 AND Is < 1.0
    ITC_TsTs = 1.4*stability^(-0.25)                        'Table 4.2 (Foken et al. 2012)

  Case Is >= 1.0
    ITC_TsTs = -(Ts_std/ABS(T_star))/9.1                    'Classify it into grade 9 when ZL >= 1
  EndSelect

  ITC_TsTs = ABS((ITC_TsTs - Ts_std/ABS(T_star))/ITC_TsTs)  'in fraction

  ITC_wTs = IIF ( (ITC_TsTs > ITC_ww), ITC_TsTs, ITC_ww)

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_wTs < 0.31)
  ITC_category(2) = (ITC_wTs < 0.31)
  ITC_category(3) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 0.76))
  ITC_category(4) = (ITC_wTs < 0.31)
  ITC_category(5) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 1.01))
  ITC_category(6) = ((ITC_wTs >= 0.76) AND (ITC_wTs < 1.01))
  ITC_category(7) = ((ITC_wTs >= 1.01) AND (ITC_wTs < 2.51))
  ITC_category(8) = ((ITC_wTs >= 2.51) AND (ITC_wTs < 10.00))

  For J = 1 To 8
    ITC_Scalar_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. Wind direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir <= 151.0) OR (wnd_dir >= 209.0)) Then
    Wnd_Scalar_1st_Occurrence = 1
  ElseIf (((wnd_dir > 151.0) AND (wnd_dir <= 171.0)) OR ((wnd_dir >= 189.0) AND (wnd_dir < 209.0)))
    Wnd_Scalar_1st_Occurrence = 7
  ElseIf ((wnd_dir > 171.0) AND (wnd_dir < 189.0))
    Wnd_Scalar_1st_Occurrence = 0
  EndIf

  '1st case
  If  ((RNS_Scalar_1st_Occurrence = 0) OR (ITC_Scalar_1st_Occurrence = 0) OR (Wnd_Scalar_1st_Occurrence = 0)) Then        'Any in category 9 (0 used for 9, here)
    QC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Scalar_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_wTs = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN
EndSub 'Data_Quality_SSITC_w_WndDir_Scalar


'd. Data quality grading for scalar flux using steady state test and integral turbulence characteristics. 
'   Foken et al. (2004) 
   
'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
'  stability             ZL
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  SIGMA_Ts              T_SONIC_SIGMA
'  T_star                TSTAR
'  lat                   latitude
'  RNS                   RN_WT_SONIC_cov, RN_WCO2_Cov, or RN_WH2O_Cov                Relative Non-Stationarity
'  SSITC                 Fc_SSITC_TEST, LE_SSITC_TEST, ET_SSITC_TEST, or H_SSITC     Quality Classes 1 to 9.

Sub Data_Quality_SSITC_wo_WndDir_Scalar (stability, SIGMA_w, U_star, SIGMA_Ts, T_star, lat, RNS, SSITC)
  ' Test on developed turbulence conditions
  Dim ITC_TsTs                             'ITC (Integral Turbulence Characteristics) for variance of T_SONIC. 
  Dim ITC_wTs                              'ITC for variance of vertical wind speed with T_SONIC. 
  Dim ITC_ww                               'ITC for variance of vertical wind. 

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean           'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean           'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(2)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Scalar_1st_Occur          'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Scalar_1st_Occur          'The lowest possible grade of ITC in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'For use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.
    
  'Reset
  SSITC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS  < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Scalar_1st_Occur = -J *RNS_category(J)
    If (RNS_Scalar_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                    'Omega: earth angular velocity

  'Test on developed turbulence conditions for scalar flux using the integral turbulence characteristic
  Select Case stability
  Case Is <= -0.032
    ITC_ww = 2.00*ABS(stability)^0.125                       'Table 9.1 (Foken et al. 2004)

  Case Is > -0.032 AND Is <= 0.0
    ITC_ww = 1.3                                             'Table 9.1 (Foken et al. 2004)

  Case Is < 0.4 AND Is > 0.0
    ITC_ww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1   'Table 9.1 (Foken et al. 2004)

  Case Is >= 0.4
    ITC_ww = -(SIGMA_w/U_star)/9.1                           'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect
  ITC_ww = ABS((ITC_ww - (SIGMA_w/U_star))/ITC_ww)           'In fraction

  Select Case stability
  Case Is < -1.0
    ITC_TsTs = ABS(stability)^(-1.0/3.0)                    'Table 9.1 (Foken et al. 2004)

  Case Is <= -0.062 AND Is >= -1.0
    ITC_TsTs = ABS(stability)^(-0.25)                       'Table 9.1 (Foken et al. 2004)

  Case Is < 0.02 AND Is > -0.062
    ITC_TsTs = 0.5*ABS(stability)^(-0.50)                   'Table 9.1 (Foken et al. 2004)

  Case  Is >= 0.02 AND Is < 1.0
    ITC_TsTs = 1.4*stability^(-0.25)                        'Table 9.1 (Foken et al. 2004)

  Case Is >= 1.0
    ITC_TsTs = -(SIGMA_Ts/ABS(T_star))/9.1                    'Classify it into grade 9 when ZL >= 1
  EndSelect

  ITC_TsTs = ABS((ITC_TsTs - SIGMA_Ts/ABS(T_star))/ITC_TsTs)  'in fraction

  ITC_wTs = IIF ( (ITC_TsTs > ITC_ww), ITC_TsTs, ITC_ww)

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_wTs < 0.31)
  ITC_category(2) = (ITC_wTs < 0.31)
  ITC_category(3) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 0.76))
  ITC_category(4) = (ITC_wTs < 0.31)
  ITC_category(5) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 1.01))
  ITC_category(6) = ((ITC_wTs >= 0.76) AND (ITC_wTs < 1.01))
  ITC_category(7) = ((ITC_wTs >= 1.01) AND (ITC_wTs < 2.51))
  ITC_category(8) = ((ITC_wTs >= 2.51) AND (ITC_wTs < 10.00))

  For J = 1 To 8
    ITC_Scalar_1st_Occur = -J *ITC_category(J)
    If (ITC_Scalar_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '1st case
  If  ((RNS_Scalar_1st_Occur = 0) OR (ITC_Scalar_1st_Occur =0)) Then        'Any in category 9 (0 used for 9, here)
    SSITC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 2, RNS_Scalar_1st_Occur)
    SSITC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_wTs = NaN)) AND (SSITC = 9)) Then  SSITC = NaN
EndSub 'Data_Quality_SSITC_wo_WndDir_Scalar


'*** Subroutines for Planetary Boundary-Layer Height
' Planetary Boundary-Layer height Kljun et al. (2004 2015)
 
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  h_PBL                  PBLH                          Planetary Boundary-Layer height
'  Obukhov                MO_LENGTH

Sub Planetary_Boundary_Layer_Height(Obukhov, h_PBL)
  
 If (Obukhov <> NaN) Then 
  'Estimate planetary boundary-layer (PBL) height using data in L- and h-columns in Table I in Kljun et al (2004)
  Select Case Obukhov
  Case Is < 0.0
    'h_PBL = 1000 m when Obukhov is -infinity. h_PBL = 1200 m at Obukhov = -650. Assume when Obukhov is <-650, h_PBL will decreases at the same rate
    'as h_PBL decreases when -650 < Obukhov <-30. Thus h_PBL reaches the limit of 1000 m at Obukhov = -1013.3; therefore, h_PBL = 1000 m if Obukhov <= -1013.3.
    If (Obukhov < -1013.3) Then
      h_PBL = 1000.0                                   'Set h_PBL = 1000 m as long as Obukhov < -1013.3 m.
    ElseIf (Obukhov <= -650) Then
      h_PBL = 1200.0 - 200.0*((Obukhov + 650.0)/(-1013.3+650.0))
    ElseIf (Obukhov <= -30.0) Then
      h_PBL = 1500.0 - 300.0*((Obukhov + 30.0)/(-650.0 + 30.0))
    ElseIf (Obukhov <= -5.0) Then
      h_PBL = 2000.0 - 500.0*((Obukhov + 5.0)/(-30.0 + 5.0))
    ElseIf (Obukhov <= 0.0) Then
      h_PBL = 2000.0 + 20.0*(Obukhov + 5.0)                  'Extrapolation to Obukhov --> -0.
    EndIf

  Case Is > 0.0
    'h_PBL = 1000 m when Obukhov is +infinity, and h_PBL = 800 m at Obukhov = 1000. Assume that h_PBL becomes higher with Obukhov at the same rate
    'as in the Obukhov range of 130 to 1000. Thus h_PBL reaches the limit of 1000 m at Obukhov = 1316.4; therefore, h_PBL = 1000 m if Obukhov > 1316.4
    If (Obukhov > 1316.4) Then
      h_PBL = 1000.0                                        'Set h_PBL = 1000 m as long as Obukhov > 1316.4 m.
    ElseIf (Obukhov >= 1000.0) Then
      h_PBL = 800.0 + 200.0*((Obukhov - 1000.0)/(1316.4-1000.0))
    ElseIf (Obukhov >= 130.0) Then
      h_PBL = 250.0 + 550.0*((Obukhov -130.0)/(1000.0 - 130.0))
    ElseIf (Obukhov >= 84.0) Then
      h_PBL = 200.0 + 50.0*((Obukhov - 84.0)/(130.0 -84.0))
    ElseIf (Obukhov > 0.0) Then
      h_PBL = 200.0 - (84.0 - Obukhov)*(50.0/46.0)               'Extrapolation to Obukhov --> +0
    EndIf
  EndSelect

 Else
   
    h_PBL = NaN
    
 EndIf
 
 EndSub 'Planetary_Boundary_Layer_Height
 

'*** Calculate Tc temperature from Ts, P, and H2O_density 

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' T_s                     Ts_K                K
' h2o_dnsty               H2O_density         g m-3
' P_atm                   press               kPa

Function Tc_function(T_s, h2o_dnsty, P_atm)
'Working variables   
Dim T_c1, T_c2, T_c3 

  'Equation (14) for air temperature from sonic temperature, water vapor density, and atmospheric pressure 
  'Cpd = 1004, Cvd = 717, Cpw = 1952, Cvw = 1463 J deg-1 kg-1 (Wallace and Hobbs 2006)  
  'a. 3.040446 = Cvw/Cvd + 1  
  'b. 1.040446 = Cvw/Cvd - 1 
  'c. 1.696000 = 2*(2*Cpw/Cpv - Cvw/Cvd -1)
  'd. 1.944223 = Cpw/Cpd
  'e. 2.040446 = Cvw/Cvd
     
  T_c1 = P_atm + (2*Rv - 3.040446*Rd)*h2o_dnsty*T_s               
  T_c2 = P_atm*P_atm + (1.040446*Rd*h2o_dnsty*T_s)*(1.040446*Rd*h2o_dnsty*T_s) + 1.696000*Rd*h2o_dnsty*P_atm*T_s
  T_c3 = 2*h2o_dnsty*((Rv - 1.944223*Rd) + (Rv - Rd)*(Rv - 2.040446*Rd)*h2o_dnsty*T_s/P_atm)
    
  Return ((T_c1 - SQR(T_c2))/T_c3)
EndFunction 'Tc_function

 #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
'*** Subroutines for H2O vapor pressure, dew point temperature, H2O density, and dry air density (Buck, 1981)
 
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  T_air                  T_probe
'  RH_air                 RH_probe
'  Press_atm              press_amb
'  e_sat_air              e_sat_probe
'  e_air                  e_probe
'  T_DP_air               T_DP_Probe
'  rho_H2O                H2O_density_probe
'  rho_d                  rho_d_probe      

Sub H2O_vapor_dewpoint (T_air, RH_air, press_atm, e_sat_air, e_air, T_DP_air, H2O_density_air, rho_d_air) 
  
 Dim Enhance_factor1_air           'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
 Dim Enhance_factor2_air           'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
 Dim x_tmp_air                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
 Dim Td_gp_air                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature

 Enhance_factor1_air = 1.00041 + press_atm*(3.48e-5 + 7.4e-9*(T_air + 30.6 - 0.38*press_atm)^2.0)     'Eq. 6 from Appendix A of flux program manual
 
   Select Case T_air                                               'Eq. 5 from Appendix A of flux program manual
      Case Is >= 0
        e_sat_air = 0.61121*Enhance_factor1_air*EXP((17.368*T_air)/(T_air + 238.88))
      Case Is < 0
        e_sat_air = 0.61121*Enhance_factor1_air*EXP((17.966*T_air)/(T_air + 247.15))
   EndSelect'T_probe
    
   e_air = (RH_air*e_sat_air)/100
    
   H2O_density_air = e_air/((T_air + T_0C_K)*Rv)                    'g/m^3
   rho_d_air       = (press_atm - e_air)/((T_air + T_0C_K)*Rd)      'g/m^3
     
   'Dew point temperature for general use for accurately computing the final dew point temperature
   Enhance_factor2_air = 1.00072 + (3.46e-5)*press_atm              'Eq. 9 from Appendix A of flux program manual

   x_tmp_air = LN(e_air/(0.61121*Enhance_factor2_air))              'For dew point temperature, assume that e is saturation water vapor pressure
   Td_gp_air = 240.97*x_tmp_air/(17.502 - x_tmp_air)

  'Accurate dew point temperature
  Enhance_factor1_air  = 1.00041 + press_atm*(3.48e-5 + 7.4e-9*(Td_gp_air + 30.6 - 0.38*press_atm)^2.0)  'Eq. 6 from Appendix A of flux program manual
  x_tmp_air            = LN(e_air/(0.61121*Enhance_factor1_air))    'For dew point temperature, assume that e is saturation water vapor pressure

     Select Case Td_gp_air                                          'Eq. 11 from Appendix A of flux program manual
       Case Is >= 0
         T_DP_air = (238.88*x_tmp_air)/(17.368 - x_tmp_air)
       Case Is < 0
         T_DP_air = (247.15*x_tmp_air)/(17.966 - x_tmp_air)
     EndSelect      
EndSub 'H2O_vapor_dewpoint
#EndIf ' (SENSOR_T_RH OR SENSOR_HYGRO)


'*** Subroutines for footprint characteristics
' 1. Footprint of Kljun et al. (2004): Footprint characteristics
 
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  U_star                 USTAR
'  SIGMA_w                  W_SIGMA
'  height_aerodynamic     z
'  Obukhov                MO_LENGTH
'  roughness              z0
'  upwnd_dist             upwnd_dist_intrst             Upwind range of interest (measurement targeted range)
'  FP_win_range           FP_DIST_INTRST                Percentage of measured scalar flux from upwind range of interest
'  x_max                  FETCH_MAX                     Upwind location of source/sink that contributes most to the measured flux
'  FP_90pct_range         FETCH_90                      Upwind range within which the source/sink contributes 90% to the measured flux
'  FP_55pct_range         FETCH_55                      Upwind range within which the source/sink contributes 55% to the measured flux
'  FP_40pct_range         FETCH_40                      Upwind range within which the source/sink contributes 40% to the measured flux

Sub FootprintCharacteristics_Kljun(U_star, SIGMA_w, height_aerodynamic, Obukhov, roughness, upwnd_dist, FP_win_range, x_max, FP_90pct_range, FP_55pct_range,FP_40pct_range)
  '*** Variables used inside subroutine
  'Model parameters
  Dim k1, k2, k3, k4           'Parameters in the model of Kljun et al (2004)
  Dim h_PBL                    'Planetary boundary-layer height

  'Composit variables repeatedly used in iterative computation
  Dim zh_ratio                 'Ratio of aerodynamic height to planetary boundary-layer height (height_aerodynamic/h_PBL)
  Dim suz                      'For repeatedly used variable of ((SIGMA_w/U_star)^0.8)/height_aerodynamic
  Dim k1_suz_zh                'For repeatedly used variable of k1*[((SIGMA_w/U_star)^0.8)*(1-height_aerodynamic/h_PBL)/height_aerodynamic]

  'Working variables
  Dim FP_cumulative            'Cumulative_footprint
  Dim FP_cumulative_prev       'Cumulative_footprint in a previous iteration
  Dim x_inflection_L           'x at the left inflection point of footprint (i.e., x_inflection_L  < x_max) where x is the upwind distance to measurement station
  Dim x_inflection_R           'x at the right inflection point of footprint (i.e., x_inflection_R > x_max) where x is the upwind distance to measurement station
  Dim x_L                      'x at the left boundary of an integration interval where x is the upwind distance to measurement station
  Dim x_R                      'x at the right boundary of an integration interval where x is the upwind distance to measurement station
  Dim integration_interval     'Interval for numerical integration (i.e., x_R - x_L)

  'Variables for use of Boole's Rule for numerical integration
  Dim FP_L                     'footprint at x = x_L
  Dim FP_M1                    'footprint at x = x_L + 0.25*(x_R - x_L)
  Dim FP_M2                    'footprint at x = x_L + 0.50*(x_R - x_L)
  Dim FP_M3                    'footprint at x = x_L + 0.75*(x_R - x_L)
  Dim FP_R                     'footprint at x = x_R

  Dim interval_count           'Used to calculate the number of intervals needed for numerical integration after FP_90pct_range was calculated, but before upwnd_dist is reached
  Dim J As Long                'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Calculate parameters in Kljun et al (2004)].
  k1 = 0.175/(3.418 - LN(roughness))     'pgs. 515 & 516, left top panel in Fig. 7 and eq. (13). Email from Dr. Kljun on Feb 10, 2015
  k2 = 3.68254                           'pgs. 515 & 516, right top panel in Fig. 7 and eq.(14). Calculated from eq.(10) using k1 and k3
  k3 = 4.277*(3.418 - LN(roughness))     'pgs. 515 & 516, left bottom panel in Fig. 7 and eq.(15). Email from Dr. Kljun on Feb 10, 2015
  k4 = 1.685*(3.418 - LN(roughness))     'pgs. 515 & 516, right bottom panel in Fig. 7 and eq.(16). Email from Dr. Kljun on Feb 10, 2015

  If ((U_star <> NaN) AND (SIGMA_w <> NaN) AND (Obukhov <> NaN)) Then 
  'Estimate planetary boundary-layer (PBL) height using data in L- and h-columns in Table I in Kljun et al (2004)
  Select Case Obukhov
  Case Is <= 0.0
    'h_PBL = 1000 m when Obukhov is -infinity. h_PBL = 1200 m at Obukhov = -650. Assume when Obukhov is <-650, h_PBL will decreases at the same rate
    'as h_PBL decreases when -650 < Obukhov <-30. Thus h_PBL reaches the limit of 1000 m at Obukhov = -1013.3; therefore, h_PBL = 1000 m if Obukhov <= -1013.3.
    If (Obukhov < -1013.3) Then
      h_PBL = 1000.0                                        'Set h_PBL = 1000 m as long as Obukhov < -1013.3 m.
    ElseIf (Obukhov <= -650.0) Then
      h_PBL = 1200.0 - 200.0*((Obukhov + 650.0)/(-1013.3 + 650.0))
    ElseIf (Obukhov <= -30.0) Then
      h_PBL = 1500.0 - 300.0*((Obukhov + 30.0)/(-650.0 + 30.0))
    ElseIf (Obukhov <= -5.0) Then
      h_PBL = 2000.0 - 500.0*((Obukhov + 5.0)/(-30.0 + 5.0))
    ElseIf (Obukhov <= 0.0) Then
      h_PBL = 2000.0 + 20.0*(Obukhov + 5.0)                 'Extrapolation to Obukhov --> -0.
    EndIf

  Case Is > 0.0
    'h_PBL = 1000 m when Obukhov is +infinity, and h_PBL = 800 m at Obukhov = 1000. Assume that h_PBL becomes higher with Obukhov at the same rate
    'as in the Obukhov range of 130 to 1000. Thus h_PBL reaches the limit of 1000 m at Obukhov = 1316.4; therefore, h_PBL = 1000 m if Obukhov > 1316.4
    If (Obukhov > 1316.4) Then
      h_PBL = 1000.0                                       'Set h_PBL = 1000 m as long as Obukhov > 1316.4 m.
    ElseIf (Obukhov >= 1000.0) Then
      h_PBL = 800.0 + 200.0*((Obukhov - 1000.0)/(1316.4-1000.0))
    ElseIf (Obukhov >= 130.0) Then
      h_PBL = 250.0 + 550.0*((Obukhov -130.0)/(1000.0 - 130.0))
    ElseIf (Obukhov >= 84.0) Then
      h_PBL = 200.0 + 50.0*((Obukhov - 84.0)/(130.0 -84.0))
    ElseIf (Obukhov > 0.0) Then
      h_PBL = 200.0 - (84.0 - Obukhov)*(50.0/46.0)                   'Extrapolation to Obukhov --> +0
    EndIf
  EndSelect

  'Calculate variables repeatedly used inside iteration loops
  zh_ratio  = height_aerodynamic/h_PBL
  suz       = ((SIGMA_w/U_star)^0.8)/height_aerodynamic
  k1_suz_zh = k1*suz*(1-zh_ratio)

  'Upwind location of source/sink that contributes most to the measured flux
  x_max = (k3 - k4)/suz
  x_inflection_L = x_max*(k3*((SQR(k2) - 1)/SQR(k2))-k4)/(k3-k4)     'x at the left inflection point of footprint (i.e., < x_max)
  x_inflection_R = x_max*(k3*((SQR(k2) + 1)/SQR(k2))-k4)/(k3-k4)     'x at the right inflection point of footprint (i.e., > x_max)

  'reset variables
  FP_cumulative  = 0.0
  FP_win_range   = 0.0
  FP_90pct_range = 0.0
  FP_55pct_range = 0.0
  FP_40pct_range = 0.0

  '***Calculate footprint characteristics: FP_win_range, FP_90pct_range, FP_55pct_range, and FP_40pct_range
  ' Use five numerical integration segments to calculate the footprint characteristics
  ' 1st: starting point of footprint defined (-k4/suz) to the left footprint inflection point (x_inflection_L)
  ' 2nd: the left footprint inflection point to the footprint maximum (x_max)
  ' 3rd: the footprint maximum to the right footprint inflection point (x_inflection_R) then further to 
  '      [x_inflection_R + (x_inflection_R - x_max)] or until cumulative footprint reaches 90% whichever is reached first. 
  ' 4th: from x > [x_inflection_R + (x_inflection_R - x_max)] or x at cumulative footprint > 90% and then until the distance of interest is reached
  '      but limited x_max + 200*height_aerodynamic (x_200z).
  ' 5th: If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
  '      or x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic. 

  ' Use a high resolution of integration intervals for the first three segments 
  '     a lower resolution for the 4th and 5th segments, but high precision numerical method of Boole's Rule

    '1st numerical integration segment: Upwind range until x reaches left inflection point

    '*** Starting calculations 
    ' Preparation for use of x_L and x_R inside an iteration
    x_R  = - k4/suz                                                        'Initialization. This value will be used for the starting point of integration
    integration_interval = (x_inflection_L - x_R)/NMBR_INT_INTERV_SEGMENT  'Use x at the left inflection point as a ending boundary of the 1st numerical integration segment
    FP_R = 0                                                               'Pre-calculation

    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = (suz*x_R + k4)/k3                                              'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '2nd numerical integration segment: Upwind range from the left footprint inflection point to the maximum footprint
    integration_interval = (x_max - x_inflection_L)/NMBR_INT_INTERV_SEGMENT   'For numerical integration, use x at the left inflection point as the starting boundary and x_max as the ending boundary

    'Upwind range within x_max
    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = (suz*x_R + k4)/k3                                            'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '3rd numerical integration segment: Upwind range from the maximum footprint to the right footprint inflection point and then further
    'to [x_inflection_R + (x_inflection_R -x_max)] or until 90% of footprint is found
    integration_interval = (x_inflection_R - x_max)/NMBR_INT_INTERV_SEGMENT  'For numerical integration, use x_max as the starting boundary and x at the right inflection point as the middle boundary

    For J = 1 To 2*NMBR_INT_INTERV_SEGMENT                                    'Using the fine resolution for integration even beyond x_inflection_R to to [x_inflection_R + (x_inflection_R -x_max)]
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of an integration interval
      FP_R = (suz*x_R + k4)/k3                                                'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 90% footprint distance
      If ((FP_cumulative >= 0.9) AND (FP_90pct_range = 0.0)) Then
        FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
        ExitFor
      EndIf
    Next J

    '4th numerical integration segment: x > [x_inflection_R + (x_inflection_R - x_max)] or cumulative footprint > 90%
    'Use lower integration resolution, but more accurate numerical integration method of Boole's Rule
    integration_interval = 4.0*height_aerodynamic

    'If upwind range of 90% footprint is not reached. Continue to calculate
    While ((FP_cumulative < 0.9) AND (x_R - x_max < 200.0*height_aerodynamic))
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      '*** Boole's Rule for numerical integration ***
      'Footprint value at the left boundary of an integration interval
      FP_L = FP_R

      FP_M1 = (suz*(x_L + 0.25*integration_interval) + k4)/k3             'Pre-calculation
      FP_M1 = k1_suz_zh*(FP_M1^k2)*EXP(k2*(1.0 - FP_M1))

      FP_M2 = (suz*(x_L + 0.50*integration_interval) + k4)/k3             'Pre-calculation
      FP_M2 = k1_suz_zh*(FP_M2^k2)*EXP(k2*(1.0 - FP_M2))

      FP_M3 = (suz*(x_L + 0.75*integration_interval) + k4)/k3             'Pre-calculation
      FP_M3 = k1_suz_zh*(FP_M3^k2)*EXP(k2*(1.0 - FP_M3))

      'Footprint value at the right boundary of an integration interval
      FP_R = (suz*x_R + k4)/k3                                            'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

      'Boole's Rule used for an individual interval to cumulate the footprint
      FP_cumulative += integration_interval*(7.0*FP_L + 32.0*FP_M1 + 12.0*FP_M2+ 32.0*FP_M3+ 7.0*FP_R)/90.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

     'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Wend

    'Find the 90% footprint distance
    If ((FP_cumulative >= 0.90) AND (FP_90pct_range = 0.0)) Then
      FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
    EndIf 
    
    'Assign FP_90pct_range as NaN if cumulative footprint cannot reach 0.9 within x_max + 200*height_aerodynamic
    If ((FP_cumulative < 0.90) AND (FP_90pct_range = 0.0)) Then
      FP_90pct_range = NaN
    EndIf

    '5th numerical integration segment.
    'If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
    'or x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic. 
    
    If (x_R < upwnd_dist) Then

      ' Control the integration w/in 25 iterations after above integrations
      If ((upwnd_dist - x_R) < (100.0*height_aerodynamic)) Then

        interval_count       = INT((upwnd_dist - x_R)/integration_interval)
        integration_interval = (upwnd_dist - x_R)/interval_count           'Rescale the integration interval

        For J = 1 To interval_count                                        'To Upwnd_dist, the cumulative footprint is enough
          x_L = x_R
          x_R = x_R + integration_interval
          FP_cumulative_prev = FP_cumulative

          '*** Boole's Rule for numerical integration *****
          'Footprint value in the left boundary of integration interval
          FP_L = FP_R

          FP_M1 = (suz*(x_L + 0.25*integration_interval) + k4)/k3          'Pre-calculation
          FP_M1 = k1_suz_zh*(FP_M1^k2)*EXP(k2*(1.0 - FP_M1))

          FP_M2 = (suz*(x_L + 0.50*integration_interval) + k4)/k3          'Pre-calculation
          FP_M2 = k1_suz_zh*(FP_M2^k2)*EXP(k2*(1.0 - FP_M2))

          FP_M3 = (suz*(x_L + 0.75*integration_interval) + k4)/k3          'Pre-calculation
          FP_M3 = k1_suz_zh*(FP_M3^k2)*EXP(k2*(1.0 - FP_M3))

          'Footprint value in the right boundary of integration interval
          FP_R = (suz*x_R + k4)/k3                                         'Pre-calculation
          FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1.0 - FP_R))

          'Boole's Rule used for an individual interval to cumulate the footprint
          FP_cumulative += integration_interval*(7.0*FP_L + 32.0*FP_M1 + 12.0*FP_M2+ 32.0*FP_M3+ 7.0*FP_R)/90.0

          'Try to find the 90% footprint distance again
          If ((FP_cumulative >= 0.9) AND (FP_90pct_range = NaN)) Then
            FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
          EndIf
        Next J

        Select Case FP_cumulative
        Case Is < 1.00
          FP_win_range = 100.0*FP_cumulative
        Case Is >= 1.0
          FP_win_range = 99.0
        EndSelect

      Else
        FP_win_range = 99
      EndIf

    EndIf

  Else
    x_max          = NaN
    FP_win_range   = NaN
    FP_90pct_range = NaN
    FP_55pct_range = NaN
    FP_40pct_range = NaN
  EndIf
EndSub 'FootprintCharacteristics_Kljun

' 2. Footprint of Kormann and Meixner (2001)

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  U_star                 USTAR
'  height_aerodynamic     z
'  Stability              ZL
'  U_total                WS_rslt
'  upwnd_dist             upwnd_dist_intrst            Upwind range of interest (measurement target)
'  FP_win_range           FP_DIST_INTRST               Percentage of measured scalar flux from upwind range of interest
'  x_max                  FETCH_MAX                    Upwind location of source/sink that contributes most to the measured flux
'  FP_90pct_range         FETCH_90                     Upwind range within which the source/sink contributes 90% to the measured flux
'  FP_55pct_range         FETCH_55                     Upwind range within which the source/sink contributes 55% to the measured flux
'  FP_40pct_range         FETCH_40                     Upwind range within which the source/sink contributes 40% to the measured flux

Sub FootprintCharacteristics_KormannMeixner (U_star, height_aerodynamic, stability, U_total, upwnd_dist, FP_win_range, x_max, FP_90pct_range, FP_55pct_range, FP_40pct_range)
  'Parameters in the vertical profiles of horizontal wind and eddy diffusivity
  Dim m_KM                     'Exponent of vertical profile of horizontal wind in footprint of Kormann and Meixner (2001)
  Dim n_KM                     'Exponent of vertical profile of eddy diffusivity in footprint of Kormann and Meixner (2001)
  Dim wnd_const                'Wind constant in the vertical profile of horizontal wind

  'Composite variables
  Dim r_KM                     'Shape factor (r_KM =2 + m_KM - n_KM) in footprint of Kormann and Meixner (2001)
  Dim Phi_c                    'Phi_c is the thermal stratification as a function of stability [see eq 1.32 in Kaimal & Finnigan 1994 and eq. 34 in Kormann and Meixner (2001)].
  Dim kp                       'Constant in power-law profile of the eddy diffusivity [(k*u_star*height_aerodynamic^(1-n_KM))/Phi_c  
  Dim Xi                       'wnd_const/(kp*r_KM^2) 
  Dim Mu                       '(m_KM + 1)/r_KM
  Dim Gamma_Mu                 'Gamma function of Mu
  Dim xgz                      '((Xi^Mu)*(height_aerodynamic^(m_KM +1)))/Gamma_Mu
  Dim xz                       'Xi*height_aerodynamic^r_KM

  'Working variables
  Dim FP_cumulative            'Cumulative_footprint
  Dim FP_cumulative_prev       'Cumulative_footprint in a previous iteration
  Dim x_inflection_L           'x at the left inflection point of footprint (i.e., x_inflection_L < x_max) where x is upwind distance to measurement station
  Dim x_inflection_R           'x at the right inflection point of footprint (i.e., x_inflection_R > x_max) where x is upwind distance to measurement station
  Dim x_L                      'x at the left boundary of integration interval where x is upwind distance to measurement station
  Dim x_R                      'x at the right boundary of integration interval where x is upwind distance to measurement station
  Dim integration_interval     'Interval for numerical integration (i.e., x_R - x_L)

  'Variables for use of Boole's rule
  Dim FP_L                     'footprint at x = x_L
  Dim FP_M1                    'footprint at x = x_L + 0.25*(x_R - x_L)
  Dim FP_M2                    'footprint at x = x_L + 0.50*(x_R - x_L)
  Dim FP_M3                    'footprint at x = x_L + 0.75*(x_R - x_L)
  Dim FP_R                     'footprint at x = x_R

  Dim J As Long                'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'From changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

   If ((U_star <> NaN) AND (stability <> NaN) AND (U_total <> NaN)) Then
     
  'Calculate the exponent of vertical profile of horizontal wind and the exponent of vertical profile of eddy diffusivity
  If (stability > 0) Then
    'Similarity functions are defined in a range of ZL from -2 to 2 (pages 28, 41~43, Kaimal & Finnigan 1994). Extended to +/-4 as shown in Fig 5.23 in Stull (1988)
   Select Case stability 
     Case Is <= 4.0    
       m_KM = (U_star/(k*U_total))*(1.0 + 5.0*stability)         'Exponent of vertical profile of horizontal wind
       n_KM = 1.0/(1.0 + 5.0*stability)                          'Exponent of vertical profile of eddy diffusivity
       Phi_c = 1.0 + 5.0 * stability                             'The thermal stratification as a function of stability
     Case Is > 4.0
       m_KM = (U_star/(k*U_total))*(1.0 + 5.0*4.0)               'Exponent of vertical profile of horizontal wind
       n_KM = 1.0/(1.0 + 5.0*4.0)                                'Exponent of vertical profile of eddy diffusivity
       Phi_c = 1.0 + 5.0 * 4                                     'The thermal stratification as a function of stability
   EndSelect
  Else
    Select Case stability
     Case Is >= -4.0  
       m_KM = (U_star/(k*U_total))/((1.0 - 16.0*stability)^0.25) 'Exponent of vertical profile of horizontal wind
       n_KM = (1.0 - 24.0*stability)/(1.0 - 16.0*stability)      'Exponent of vertical profile of eddy diffusivity
       Phi_c = 1.0 /(SQR(1.0 - 16.0*stability))                  'The thermal stratification as a function of stability
       
     Case Is < -4.0
       m_KM = (U_star/(k*U_total))/((1.0 - 16.0*(-4.0))^0.25)    'Exponent of vertical profile of horizontal wind
       n_KM = (1.0-24.0*(-4.0))/(1.0 - 16.0*(-4.0))              'Exponent of vertical profile of eddy diffusivity
       Phi_c = 1.0 /(SQR(1.0 + 16.0*4))                          'The thermal stratification as a function of stability
    EndSelect
  EndIf

  'Calculate the wind constant in the vertical profile of horizontal wind
  wnd_const = U_total/(height_aerodynamic^m_KM)                 'Wind constant

  'Calculate the composite variables
  r_KM = 2.0 + m_KM - n_KM                                      'Shape factor
  kp = (k * U_star * height_aerodynamic^(1.0 - n_KM))/Phi_c     'From eqs (11) and (32) in Kormann and Meixner (2001)
  Xi = wnd_const/(kp*r_KM*r_KM)
  Mu = (m_KM + 1.0)/r_KM

  Gamma_Mu = SQR(2.0*PI/Mu)*(((Mu + 1.0/(12.0*Mu - 0.1/Mu))/EXP(1.0))^Mu)   'Gamma fuction of Mu [see Nemes (2007)]

  xgz = ((Xi^Mu)*(height_aerodynamic^(m_KM +1.0)))/Gamma_Mu
  xz  = Xi*(height_aerodynamic^r_KM)

  'Turning and inflection points
  x_max          = xz/(Mu + 1.0)                                            'Upwind location of source/sink that contributes most to the measured flux
  x_inflection_L = x_max*(1.0 - 1.0/SQR(Mu + 2.0))                          'x at the left footprint inflection point
  x_inflection_R = x_max*(1.0 + 1.0/SQR(Mu + 2.0))                          'x at the right footprint inflection point

  'Reset variables
  FP_cumulative  = 0.0
  FP_win_range   = 0.0
  FP_90pct_range = 0.0
  FP_55pct_range = 0.0
  FP_40pct_range = 0.0

  '***Calculate footprint characteristics: FP_win_range, FP_90pct_range, FP_55pct_range, and FP_40pct_range
  ' Use five numerical integration segments to calculate the footprint characteristics
  ' 1st: starting segment from 0 (+ Delt-->0) to the left footprint inflection point (x_inflection_L)
  ' 2nd: the left footprint inflection point to the footprint maximum (x_max)
  ' 3rd: the footprint maximum to the right footprint inflection point (x_inflection_R) then further to 
  '      [x_inflection_R + (x_inflection_R - x_max)] or until cumulative footprint reaches 90% whichever is reached first. 
  ' 4th: from x > [x_inflection_R + (x_inflection_R - x_max)] or x at culumutive footprint > 90% if reached and then until the distance of interest or 
  '      FP_90pct_range is reached if not reached in 3rd segment but limited further x_max + 1000*height_aerodynamic.
  ' 5th: If upwind range of interest or FP_90 has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
  '      or the 4th segment end point to upwind distance of interest, but limited to integration further + 1000*height_aerodynamic.  

  ' Use a high resolution of integration intervals for the first three segments 
  '     a lower resolution for the 4th and 5th segments, but high precision numerical method of Boole's rule

   '1st numerical integration segment: Upwind range within the left inflection point
   'In numerical integration, use x at the left footprint inflection point as the ending boundary of this segment
    integration_interval = x_inflection_L/NMBR_INT_INTERV_SEGMENT  
    x_R  = 0.0                                                        'Reset
    FP_R = 0.0                                                        'Reset
    
    'Upwind range within the left inflection point
    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integral interval
      FP_L = FP_R

      'Footprint value at the right boundary of integral interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1.0))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '2nd numerical integration segment: Upwind range from the left footprint inflection point to the maximum footprint
    'In this segment, use x at the left inflection point as the starting boundary and x_max as the ending boundary
    integration_interval = (x_max - x_inflection_L)/NMBR_INT_INTERV_SEGMENT   

    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integral interval
      FP_L = FP_R

      'Footprint value at the right boundary of integral interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1.0))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '3rd numerical integration segment: Upwind range from the maximum footprint to the right footprint inflection point and further to
    ' [x_inflection_R + (x_inflection_R - x_max)] or to 90% footprint whichever is first reached.
    'In this segment, use x_max as the starting boundary and x at the right inflection point as the boundary of middle interval
    integration_interval = (x_inflection_R - x_max)/NMBR_INT_INTERV_SEGMENT   

    'Upwind range within two times of range from x_max to the right inflection point
    'The fine resolution of integration is used even beyond x_inflection_R to [x_inflection_R + (x_inflection_R - x_max)] or until 90% footprint is reached
    For J = 1 To 2*NMBR_INT_INTERV_SEGMENT   
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += integration_interval*(FP_L + FP_R)/2.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 90% footprint distance
      If ((FP_cumulative >= 0.9) AND (FP_90pct_range = 0.0)) Then
        FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
        ExitFor
      EndIf

    Next J

    '4th numerical integration segment: x > [x_inflection_R + (x_inflection_R - x_max)] or cumulative footprint < 90%
    'Use lower integration resolution, but the more accurate numerical integration method of Boole's rule
    integration_interval = 5.0*height_aerodynamic

    'If upwind range of 90% footprint is not reached. Continue, but limited to x_max + 1000*height_aerodynamic
    While ((FP_cumulative < 0.9) AND (x_R - x_max < 1000.0*height_aerodynamic))
      x_L = x_R
      x_R = x_R + integration_interval
      FP_cumulative_prev = FP_cumulative

      '*** Boole's rule *****
      'Footprint value at the left boundary of an integration interval
      FP_L = FP_R

      'Footprint value at the 1st, 2nd, and 3rd quarter integration interval
      FP_M1 = xgz*EXP(-xz/(x_L + 0.25*integration_interval))/((x_L + 0.25*integration_interval)^(Mu + 1.0))
      FP_M2 = xgz*EXP(-xz/(x_L + 0.50*integration_interval))/((x_L + 0.50*integration_interval)^(Mu + 1.0))
      FP_M3 = xgz*EXP(-xz/(x_L + 0.75*integration_interval))/((x_L + 0.75*integration_interval)^(Mu + 1.0))

      'Footprint value at the right boundary of an integration interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1.0))

      'The Boole's rule used for an individual interval to cumulate footprint
      FP_cumulative += integration_interval*(7.0*FP_L + 32.0*FP_M1 + 12.0*FP_M2 + 32.0*FP_M3 +7.0*FP_R)/90.0

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0.0)) Then
        FP_40pct_range = x_R - integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0.0)) Then
        FP_55pct_range = x_R - integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Wend
    
    'Find the 90% footprint distance
    If ((FP_cumulative >= 0.90) AND (FP_90pct_range = 0.0)) Then
        FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
    EndIf

    ' 5th numerical integration segment:
    ' If upwind range of interest or FP_90pct has not been reached, this segment is integrated
    ' from x at FP_90 = 90% (x_90) or the 4th segment end if upwind distance of either interest or FP_90 is not reached.  
    ' but limited to 1000*height_aerodynamic further. 
    
    If ((x_R < upwnd_dist) OR (FP_90pct_range = 0)) Then
       integration_interval = 2*integration_interval

       For J = 1 To  100                               '1000*height_aerodynamic after above integration, the cumulative footprint is enough
          x_L = x_R
          x_R = x_R + integration_interval
          FP_cumulative_prev = FP_cumulative

          '*** Boole's rule *****
          'Footprint value at the left boundary of integration interval
          FP_L = FP_R

          'Footprint value at the right boudary of the 1st, 2nd, and 3rd quarter integration interval
          FP_M1 = xgz*EXP(-xz/(x_L + 0.25*integration_interval))/((x_L + 0.25*integration_interval)^(Mu + 1.0))
          FP_M2 = xgz*EXP(-xz/(x_L + 0.50*integration_interval))/((x_L + 0.50*integration_interval)^(Mu + 1.0))
          FP_M3 = xgz*EXP(-xz/(x_L + 0.75*integration_interval))/((x_L + 0.75*integration_interval)^(Mu + 1.0))

          'Footprint value at the right boundary of integration interval
          FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1.0))

          FP_cumulative += integration_interval*(7.0*FP_L + 32.0*FP_M1 + 12.0*FP_M2 + 32.0*FP_M3 +7.0*FP_R)/90.0
          
         'Find the footprint w/in the range of interest
          If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
             FP_win_range = 100.0*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/integration_interval)
          EndIf
         
          'Try FP_90pct_range again in case that FP_90pct_range is not resolved
          If ((FP_cumulative >= 0.9) AND (FP_90pct_range = 0)) Then
            FP_90pct_range = x_R - integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
          EndIf
          
          If ((x_R > upwnd_dist) AND (FP_90pct_range > x_max)) Then
            ExitFor
          EndIf 

        Next J

        If (FP_win_range = 0) Then  
        Select Case FP_cumulative
        Case Is < 1.0
          FP_win_range = 100.0*FP_cumulative
        Case Is >= 1.0
          FP_win_range = 99.0
        EndSelect
        EndIf
        
        'Assign FP_90pct_range as current x_R if cumulative footprint cannot reach 0.9 within the integration range above. 
        If ((FP_cumulative < 0.90) AND (FP_90pct_range = 0)) Then
          FP_90pct_range = x_R
        EndIf
    EndIf

  Else
    x_max          = NaN
    FP_win_range   = NaN
    FP_90pct_range = NaN
    FP_55pct_range = NaN
    FP_40pct_range = NaN
  EndIf
EndSub 'FootprintCharacteristics_KormannMeixner
'************************* END of SUBROUTINES ****************************


'*************************************************************************
'*****                       MAIN PROGRAM                            *****
'************************************************************************'
BeginProg
  #If (CSAT3A_EC150) Then 
  #If (CSAT_TYP_3AH) Then 
   '*** Open communication of CR1000X to CSAT3AH heating controller 
      SerialOpen (ComSDC7, 115200, 4, 0, 200)        'Opening for bidirectional communications
      CSAT3H_user_ctrl_on = CSAT3H_user_ctrl_flg      
  #EndIf '(CSAT_TYP_3AH)
  #EndIf '(CSAT3A_EC150) 
  
  '*** Zero and span coefficients for EC150. These for IRGASON are assigned as defaults in declaration for this variable    
  #If (CSAT3A_EC150) Then 
     rst_zro_spn_coeff_array (1, 2) = 1.000598     'CO2 zero coefficient 
     rst_zro_spn_coeff_array (2, 2) = 1.000149     'CO2 span coefficient 
     rst_zro_spn_coeff_array (3, 2) = 0.999724     'H2O zero coefficient 
     rst_zro_spn_coeff_array (4, 2) = 0.997214     'CO2 span coefficient 
  #EndIf    
  
  #If (SENSOR_HFP) Then
  '*** Load calibrations of soil heat flux plate.
   shf_plate_cal(1) = 1000/HFP_SNSTVT_1 
   #If (NMBR_HFP > 1) Then 
   shf_plate_cal(2) = 1000/HFP_SNSTVT_2
   #EndIf 
   #If (NMBR_HFP > 2) Then 
   shf_plate_cal(3) = 1000/HFP_SNSTVT_3
   #EndIf 
 
   #If (SENSOR_HFPSC) Then
   Move (shf_mfct_cal(1), NMBR_HFP, shf_plate_cal(1), NMBR_HFP)    
  '*** Load heater resistance soil heat flux plate.  
   shf_htr_resstnc (1) = HFP_OHM_1 
   #If (NMBR_HFP > 1) Then              
   shf_htr_resstnc (2) = HFP_OHM_2
   #EndIf 
   #If (NMBR_HFP > 2) Then              
   shf_htr_resstnc (3) = HFP_OHM_3
   #EndIf    
   #EndIf '(SENSOR_HFPSC)
 #EndIf '(SENSOR_HFP)

  '*** Reset and start timer  
  Timer (1, Sec, 0)
  secs_snc_pwr_swtch = 0

'*****           STORE AND READ STATION VARIABLES IN CPU              *****
  SemaphoreGet (1)
  stn_conf_array_file = FileOpen ("CPU:stn_conf_array.dat", "rb", 0)      'Open file and check if a file exists.
  stn_conf_array_file_size = FileSize (stn_conf_array_file)
  FileClose (stn_conf_array_file)                                         'Close file after check
  SemaphoreRelease (1)

  If (stn_conf_array_file_size <> 4*NMBR_STN_VAR + 2) Then                'Station configuration file does not exist.
    ' Set default values of station variables (Default values of 0 are listed for code readability although default value of variable is 0.)
    sonic_azimuth      = 0.0
    latitude           = 41.766           'Latitude of Campbell Scientific Campus, Logan, UT, USA
    hemisphere_NS      = NORTH            '"1" for north and "-1" for south. Campbell Scientific Campus is located in North Hemisphere
    longitude          = -111.855         'Longitude of Campbell Scientific Campus, Logan, UT, USA
    hemisphere_EW      = WEST             '"1" for east and "-1" for west. Campbell Scientific Campus is located in West Hemisphere
    altitude           = 1356.0           'Altitude of Campbell Scientific Campus, Logan, UT, USA
    height_measurement = 2.0
    surface_type       = GRASS
    height_canopy      = 0.5
    displacement_user  = 0.0              '"0" indicates that the user DOES NOT have preferred zero displacement height
    roughness_user     = 0.0              '"0" indicates that the user DOES NOT have preferred roughness length

    Select Case IRGASON
    Case TRUE
      separation_x_irga = 0              'Coordinate x of IRGASON IRGA measurement center in the CSAT coordinate system
      separation_y_irga = 0              'Coordinate y of IRGASON IRGA measurement center in the CSAT coordinate system
    Case FALSE
      separation_x_irga = 0.04066        'Range: 0.04066 to 0.09126 m:  Coordinate x of EC150 IRGA measurement center in the CSAT3A coordinate system
      separation_y_irga = 0.02905        'Range: 0.02905 to 0.03348 m:  Coordinate y of EC150 IRGA measurement center in the CSAT3A coordinate system
    EndSelect 'IRGASON

    #If (SENSOR_GPS) Then 
      height_GPS16X = 2.0
    #EndIf 
       
    #If (SENSOR_FW) Then
    Select Case IRGASON
     Case TRUE
       separation_x_FW = 0.35787 - 0.3520 'Coordinate x of fine wire thermocouple junction in the CSAT coordinate system (0.35200 is the default length of FW sensor) 
       separation_y_FW = 0.03259          'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
     Case FALSE      
       separation_x_FW = 0.36427 - 0.3520 'Coordinate x of fine wire thermocouple junction in the CSAT coordinate system (0.35200 is the default length of FW sensor) 
       separation_y_FW = -0.02306         'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
     EndSelect
      FW_diameter     = FW3_DIA           'Diameter of fine wire thermocouple
   #EndIf '(SENSOR_FW)

   #If (SENSOR_HFP AND SENSOR_SWC) Then
    soil_bulk_density = 1300.0            'Default soil bulk density (kg/m^3)
    Cds               =  870.0            'Default specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
    thick_abv_SHFP    =    0.16           'Default depth of HFP01 or HFP01SC below soil surface (m)
   #EndIf

  Else
    Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:stn_conf_array.dat", 1)         'Read the stored values from the file.

  EndIf '(stn_conf_array_file_size <> 4*NMBR_STN_VAR + 2)
  
  'Error control   
  If ((sonic_azimuth < 0.0) OR (sonic_azimuth > 360.0)) Then 
    sonic_azimuth = 0.0                  'Set back to default value 
  EndIf 
  
  If (ABS(latitude) > 90.0) Then  
     latitude = 41.766                  'Set back to default value 
  EndIf 
  
  If ((hemisphere_NS <> NORTH) AND (hemisphere_NS <> SOUTH)) Then
     hemisphere_NS = NORTH              'Set back to default value 
  EndIf
  
  If (ABS(longitude) > 180.0) Then  
     longitude = -111.855              'Set back to default value 
  EndIf 
  
  If ((hemisphere_EW <> EAST) AND (hemisphere_EW <> WEST)) Then
     hemisphere_EW = WEST              'Set back to default value 
  EndIf
  
  If ((altitude > 8000.0) OR (altitude < -1000.0)) Then  
     altitude = 1356.0                 'Set back to default value 
  EndIf
  
  If ((height_measurement > 250.0) OR (height_measurement < 0.2)) Then 
     height_measurement = 2.0          'Set back to default value 
  EndIf 
  
  If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND (height_measurement > 100.0)) Then 
    height_measurement = 2.0           'Set back to default value 
  EndIf
  
  If ((surface_type < CROP) OR (surface_type > ICE)) Then 
    surface_type = GRASS               'Set back to default value 
  EndIf 
  
  If ((surface_type = BARELAND) OR (surface_type = WATER) OR (surface_type = ICE)) Then 
    height_canopy = 0.0                'Set back to default value 
  EndIf 
  
  If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND (height_canopy > 15.0)) Then 
    height_canopy = 0.5                'Set back to default value 
  EndIf
  
  If ((surface_type = FOREST) OR (height_canopy > 100.0)) Then 
    height_canopy = 0.5                'Set back to default value 
  EndIf 
    
  If (displacement_user > height_measurement) OR (displacement_user < 0.0) Then  
     displacement_user = 0.0           'Set back to default value 
  EndIf
  
  If (roughness_user > height_measurement) OR (roughness_user < 0.0) Then  
     roughness_user = 0.0              'Set back to default value 
  EndIf
  
  'If IRGASON, but previously CSAT3A+EC150, automatically reset
  If (IRGASON) Then
     separation_x_irga = 0.0                                              'Coordinate x of IRGASON IRGA measurement center in the CSAT coordinate system
     separation_y_irga = 0.0                                              'Coordinate y of IRGASON IRGA measurement center in the CSAT coordinate system
   #If (SENSOR_FW) Then
     separation_y_FW = 0.03259                                            'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
   #EndIf
  EndIf '(IRGASON)
  
  If (NOT IRGASON) Then
    If ((separation_x_irga < 0.04066) OR (separation_x_irga > 0.09126)) Then 
      separation_x_irga = 0.04066                                         'Range: 0.04066 to 0.09126 m:  Coordinate x of EC150 IRGA measurement center in the CSAT3A coordinate system
    EndIf 
    If ((separation_y_irga < 0.02905) OR (separation_y_irga > 0.03348)) Then 
     separation_y_irga = 0.02905                                          'Range: 0.02905 to 0.03348 m:  Coordinate y of EC150 IRGA measurement center in the CSAT3A coordinate system
    EndIf
    #If (SENSOR_FW) Then
      separation_y_FW = -0.02408                                          'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
    #EndIf
  EndIf '(NOT IRGASON)
  
 #If (SENSOR_GPS) Then 
  If (height_GPS16X < 0) OR (height_GPS16X > 100.0) Then 
     height_GPS16X = height_measurement
  EndIf
 #EndIf '(SENSOR_GPS) 

 #If (SENSOR_FW) Then
   If (separation_x_FW > 0.1) OR (separation_x_FW < 0.0) Then  
      Select Case IRGASON      
        Case TRUE 
              separation_x_FW = 0.35787 - 0.3520                          'Coordinate x of fine wire thermocouple junction in the CSAT coordinate system (0.35200 is the default length of FW sensor) 
        Case FALSE
              separation_x_FW = 0.36427 - 0.3520
      EndSelect
    EndIf 
 #EndIf '(SENSOR_FW)

 #If (SENSOR_HFP AND SENSOR_SWC) Then
   If  ((soil_bulk_density > 1800.0) OR (soil_bulk_density < 600.0)) Then 
      soil_bulk_density = 1300.0                                          'Default soil bulk density (kg/m^3)
   EndIf 
   If ((Cds < 400.0) OR (Cds > 1500.0)) Then 
      Cds =  870.0                                                        'Default specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
   EndIf 
   If ((thick_abv_SHFP > 0.30) OR (thick_abv_SHFP < 0.0)) Then 
      thick_abv_SHFP = 0.16                                               'Default depth of HFP01 or HFP01SC below soil surface (m)
   EndIf 
 #EndIf '(SENSOR_HFP AND SENSOR_SWC)

  '*** Calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan
  Call Displacement_roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
        
  For i = 14 To 17
    If  (NOT (stn_conf_array(i) > 0.0)) Then 
      stn_conf_array(i) = 100.0*z                                         'Default value of 100*z for all sectors in different directions
    EndIf 
  Next
  
  z_prev = z
  Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR)   'Keep current values of stn_conf_array() in stn_conf_array_prev() for later reference as previous values
  surface_type_text = surface_type_array(surface_type)
  
  Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:stn_conf_array.dat", 0)         'Store the values to the file. 

  '*** Store and read Planar Fit angles in CPU
  SemaphoreGet (1)  
  planar_fit_angle_conf_array_file      = FileOpen ("CPU:planar_fit_angle_conf_array.dat", "rb", 0)  'Open the file and check if a file exists
  planar_fit_angle_conf_array_file_size = FileSize (planar_fit_angle_conf_array_file)                'Size of the planar fit angle configuration file stored on the CPU.
  FileClose (planar_fit_angle_conf_array_file)                                                       'Close file after check
  SemaphoreRelease (1)

  If (planar_fit_angle_conf_array_file_size <> (4*8 + 2)) Then
    Move (planar_fit_angle_conf_array(1,1), 8 , 0, 1)                                                'Default values of 0 are listed for code reading
    Calfile (planar_fit_angle_conf_array(1, 1), 8, "CPU:planar_fit_angle_conf_array.dat", 0)         'Store the default values to the file
  Else
    Calfile (planar_fit_angle_conf_array(1, 1), 8, "CPU:planar_fit_angle_conf_array.dat", 1)         'Read the values from the file
    For i =1 To 4
      If (planar_fit_angle_conf_array (i, 1) <> 0) OR (planar_fit_angle_conf_array (i, 2) <> 0) Then
        Planar_Fit_flg = TRUE
        ExitFor
      EndIf
    Next i
  EndIf

  Move (planar_fit_angle_conf_array_prev(1,1), 8, planar_fit_angle_conf_array(1,1), 8)                'Keep current values PF planar_fit_angle_conf_array() in planar_fit_angle_prev_array() for later reference as previous values
'************* END OF STORE AND READ STATION VARIABLES IN CPU ************
 

'*****             INITIAL SETTING FOR TIME STAMP                    ***** 
  CR1000X_clock = status.timestamp(4,1)
  TIMESTAMP_START = Left (CR1000X_clock, 4) & Mid (CR1000X_clock, 6, 2) & Mid (CR1000X_clock, 9, 2) & Mid (CR1000X_clock,12,2)& Mid (CR1000X_clock,15,2)
  TIMESTAMP_START = Left (TIMESTAMP_START, 12)  
  Erase(TIMESTAMP_END) 
'************* END OF INITIAL SETTING FOR TIME STAMP *********************
      

'***** INITIAL CHECK HOW MANY DAYS LEFT FOR DATA STORAGE IN MicroSD ******
    '*** Unique: Compute the data table size for Time_Series
    '16 bytes for TimeStamp and record number, 4 bytes for each variable in IEEE4 and Long, and 13 unconditional variables   
    bytes_rcd_Time_Series = (16 + 4*13 - 4*(IRGASON) - 4*(SENSOR_FW))  
  
    '24 hours/day, 3600 seconds/hour, (1000/SCN_INTV) is scan rate in Hz, "1.1" is factor used in CR1000X OS, and "1000" is a unit conversion factor from bytes to KB.         
    bytes_tbl_Time_Series = (DAY_TSRS_CRD*24*3600*(1000/SCN_INTV)*1.1)*bytes_rcd_Time_Series
  
    'Add the bytes in KB for row heading and extra
    If (NOT (IRGASON OR SENSOR_FW)) Then
      bytes_tbl_Time_Series = bytes_tbl_Time_Series + 1024*3.13
  
    ElseIf (IRGASON XOR SENSOR_FW) Then
      bytes_tbl_Time_Series = bytes_tbl_Time_Series + 1024*3.11
    
    ElseIf (IRGASON AND SENSOR_FW) Then   
      bytes_tbl_Time_Series = bytes_tbl_Time_Series + 1024*3.08
    
    EndIf 
    
     day_snc_0101_1990 = SecsSince1990(status.TimeStamp(1,1), 1)/(24*3600)
            
     days_actv_tbl_Time_Series = DAY_TSRS_CRD - (day_snc_0101_1990 MOD DAY_TSRS_CRD) 

     'Pre-set, assume no extra storage in MicroSD
     days_totl_tbl_Time_Series = days_actv_tbl_Time_Series 

    '*** Unique: Compute the data table size for Flux_AmeriFluxFormat
    '12 bytes each of two TimeStamp, 9 bytes for each variable in IEEE4 or Long, 41 uncoditial variables
    bytes_rcd_AmeriFluxFormat = 12*2 + 9*41

    #If (SENSOR_HFP AND SENSOR_SWC)  Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*2           'G and SG
    #EndIf
      
    #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*3          'TA_1_1_3, RH_1_1_3, and T_DP_1_1_3
    #EndIf
    
    #If (SENSOR_SWC) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*NMBR_CS65x 'SWC_1_1_1, _1_1_2, and/or _1_1_3. Measured using CS65X or TDR
    #EndIf

    #If (SENSOR_TCAV) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*NMBR_TCAV  'TS_1_1_1, _1_1_2, and/or _1_1_3.  
    #EndIf

    #If ((NOT SENSOR_TCAV) AND SENSOR_SWC)  Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*NMBR_CS65x 'TS_1_1_1, _1_1_2, and/or _1_1_3.  
    #EndIf    

    #If (SENSOR_Rn) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1          'Albedo
    #EndIf
  
    'SENSOR_NR01, _CNR4, or _SN500
    #If (SENSOR_Rn) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1          'NETRAD
    #EndIf

    #If (SENSOR_CS310) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1          'PPFD_IN
    #EndIf    

    #If (SENSOR_Rn OR SENSOR_CS301 OR SENSOR_CS320) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1          'SW_IN. for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
    #EndIf

    #If (SENSOR_Rn) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*3          'SW_OUT, LW_IN, and LW_OUT
    #EndIf
   
    #If (SENSOR_TE525) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1          'Precipitation 
    #EndIf
   
    #If (CDM_VOLT_116) Then 
    #If (SENSOR_SI111) Then
      bytes_rcd_AmeriFluxFormat = bytes_rcd_AmeriFluxFormat + 9*1          'T_CANOPY  
    #EndIf
    #EndIf

    'Add 5KB row-heading and other extra 
    bytes_tbl_AmeriFluxFormat = DAY_FLUX_CRD*(24*60/OUTPUT_INTV)*1.1*bytes_rcd_AmeriFluxFormat + 1024*5.0 

   '*** Unique: Compute the data table size for Flux_CSFormat
   '16 bytes for TimeStamp and record number, 4 bytes for each variable in IEEE4 or Long, 
   '60 uncoditial variables, and 16 bytes for one string variable (i.e., FP_EQUATION)  
    bytes_rcd_flux_CSFormat = 16 + 4*60 + 16*1
  
    #If (SENSOR_FW) Then
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2             'H_FW amd H_FW_samples 
    #EndIf
      
    #If (SENSOR_Rn) Then
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1             'NETRAD,
    #EndIf

    #If (SENSOR_HFP AND SENSOR_SWC))  Then
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2             'G and SG
    #EndIf
   
    #If (SENSOR_Rn AND SENSOR_HFP AND SENSOR_SWC) Then
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1             'energy_closure
      #If (SENSOR_TE525) Then  
      bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1             'poor_energy_closure_flg
      #EndIf  
    #EndIf

   #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
     'Temperature and humidity probe data
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*6              'TA_1_1_3, RH_1_1_3, T_DP_1_1_3, e_probe_Avg, e_sat_probe_Avg, and H2O_density_probe_Avg
   #EndIf
   
   #If (SENSOR_FW) Then
   'Fine wire thermocouple data
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2              'FW and FW_SIGMA
   #EndIf
   
   #If (SENSOR_TE525) Then
  'Rain gauge data
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1              'P
   #EndIf
  
   #If (SENSOR_Rn) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1              'ALB
   #EndIf

   #If (SENSOR_Rn OR SENSOR_CS301 OR SENSOR_CS320) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1              'SW_IN. For use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
   #EndIf
  
   #If (SENSOR_Rn) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*4              'SW_OUT, LW_IN, LW_OUT, and T_nr (T_nr_in for SN500)
   #EndIf
   
   #If (SENSOR_SN500) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1              'T_nr_out
   #EndIf
  
   #If (SENSOR_NR01 OR SENSOR_CNR4) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2              'R_LW_in_meas and R_LW_out_meas
   #EndIf

   #If (SENSOR_CS310) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*1              'PPFD_IN
   #EndIf
       
   #If (CDM_VOLT_116) Then 
   #If (SENSOR_SI111) Then
   'Surface temperature (i.e., canopy temperature) 
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*2              'T_CANOPY and T_SI111_body  
   #EndIf
   #EndIf

   #If (SENSOR_TCAV) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_TCAV      'TS_1_1_1, _1_1_2, and/or _1_1_3 depending on NMBR_TCAV
   #EndIf

   #If ((NOT SENSOR_TCAV) AND SENSOR_SWC)  Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_CS65x     'TS_1_1_1, _1_1_2 and/or _1_1_3 depending on NMBR_CS65x 
   #EndIf
   
   #If (SENSOR_SWC) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_CS65x     'SWC_1_1_1, _1_1_2, and _1_1_3 depending on NMBR_CS65x
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_CS65x     'cs65x_ec_1_1_1, _1_1_2,and _1_1_3 depending on NMBR_CS65x 
   #EndIf

   #If (SENSOR_HFP) Then
   '*** soil heat flux plat data 
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_HFP       'G_plate_1_1_1, _1_1_2, and _1_1_3 depending on NMBR_HFP 
   #EndIf
   
   #If (SENSOR_HFP AND SENSOR_SWC) Then
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_HFP       'G_1_1_1, _1_1_2, and _1_1_3 depending on NMBR_HFP 
     bytes_rcd_flux_CSFormat = bytes_rcd_flux_CSFormat + 4*NMBR_HFP       'SG_1_1_1, _1_1_2, and _1_1_3 depending on NMBR_HFP 
   #EndIf
    
   '*** Unique: Compute the data table size for Flux_Notes
   '16 bytes for TimeStamp and record number (added according to ONE_FL_TABLE), 4 bytes for each variable in IEEE4 or Long, and 118 unconditional variables, 
     x_tmp = 4*118
   
   #If (CSAT3A_EC150) Then 
   #If (CSAT_TYP_3AH) Then 
     x_tmp = x_tmp + 4*25         '20 variables for CSAT3AH (e.g. T_trnsd_uppr .......)
   #EndIf
   #EndIf

   #If (SENSOR_FW) Then
     x_tmp = x_tmp + 4*8          'UxFW_Cov, UyFW_Cov, UzFW_Cov, UFW_Cov, VFW_Cov, WFW_Cov, WFW_Cov_fc, and FW_samples.
     x_tmp = x_tmp + 4*7          'separation_x_FW, _y_FW, FW_diameter, separation_lat_dist_FW, _lag_dist_FW, _lag_scan_FW, and time_const_FW
     x_tmp = x_tmp + 4*2          'lag_FW and FreqFactor_WFW
   #EndIf
  
   #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
     x_tmp = x_tmp + 4*2          'rho_d_probe and _a_probe
   #EndIf

   #If (SENSOR_NR01) Then                                              
     x_tmp = x_tmp + 4*1          'nr01_heater_secs      
   #EndIf 
     
   #If (SENSOR_CNR4 AND SENSOR_CNF4) Then 
     x_tmp = x_tmp + 4*5          'cnr4_fan_secs, _fan_freq_max, _fan_freq_min, _heater_1_secs, and _heater_2_secs
   #EndIf
  
   #If (SENSOR_SN500) Then 
     x_tmp = x_tmp + 4*1          'sn500_heater_secs
   #EndIf
  
   #If (SENSOR_CS320) Then
     x_tmp = x_tmp + 4*6          'V_CS320, T_CS320, x_incline, y_incline, z_incline, and CS320_heater_secs
   #EndIf   
   
   #If (SENSOR_HFP) Then
     x_tmp = x_tmp + 4*NMBR_HFP  'shfp_cal_1_1_1, _1_1_2, and/or _1_1_3 depending on NMBR_HFP 
     #If (SENSOR_HFPSC) Then
     x_tmp = x_tmp + 4*NMBR_HFP  'shfp_cal_fail_1_1_1, _1_1_2, and/or _1_1_3, depending on NMBR_HFP     
     #EndIf     
   #EndIf 

   #If (ONE_FL_TABLE) Then 
    bytes_rcd_flux_CSFormat = (bytes_rcd_flux_CSFormat + x_tmp)
    
    days_actv_tbl_flux_CSFormat = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD) 
    
    'Pre-set, assume no extra storage in MicroSD     
    days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat 
    
    'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat uses. 
    'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.   
    card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat 
    
  #Else 
 
   '16 bytes added for TimeStamp and record number
    bytes_rcd_flux_notes = 16 + x_tmp
    '24 hours/day, 60 minutes/hour, factor 1.1 used in CR1000X OS, and 5 KB for row heading and extra (approximation) 
    bytes_tbl_flux_notes = DAY_FLUX_CRD*(24*60/OUTPUT_INTV)*1.1*bytes_rcd_flux_notes + 1024*5.0 
    
    days_actv_tbl_flux_CSFormat_notes = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD)

    'Pre-set, assume no extra storage in MicroSD
    days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes

   'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat and Flux_notes uses. 
   'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.   
    card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat_notes/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat 

  #EndIf '(ONE_FL_TABLE)
  
   '24 hours/day, 60 minutes/hour, factor 1.1 used in CR1000X OS, and 5KB for row heading and extra (approximation) 
    bytes_tbl_flux_CSFormat  = DAY_FLUX_CRD*(24*60/OUTPUT_INTV)*1.1*bytes_rcd_flux_CSFormat + 1024*5.0

  '** Read the number of free bytes in MicroSD and calculate how many days left for data storage in MicroSD
    card_bytes_free = Status.CardBytesFree                                   'In bytes.
 
 If  (card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") Then
    card_bytes_free_unassgnd = card_bytes_free - card_bytes_free_assgnd 

  #If (ONE_FL_TABLE) Then 
     While (((days_totl_tbl_flux_CSFormat >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR _
           ((days_totl_tbl_flux_CSFormat < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat))))      

       If (days_totl_tbl_flux_CSFormat >= days_totl_tbl_Time_Series) Then
          card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series 
          days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
          days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series    
       
       Else  
          card_bytes_free_assgnd      = card_bytes_free_assgnd + bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat
          days_more_tbl_flux_CSFormat = days_more_tbl_flux_CSFormat + DAY_FLUX_CRD
          days_totl_tbl_flux_CSFormat = days_more_tbl_flux_CSFormat + days_actv_tbl_flux_CSFormat   
  
      EndIf 
        
        card_bytes_free_unassgnd = card_bytes_free - card_bytes_free_assgnd

    Wend 
    
        If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat) Then 
          card_storage_available_days = days_totl_tbl_flux_CSFormat
        Else
          card_storage_available_days = days_totl_tbl_Time_Series
        EndIf  

  #Else 
    
       While (((days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR _
             ((days_totl_tbl_flux_CSFormat_notes < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat + bytes_tbl_flux_notes))))      

       If (days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) Then
          card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series 
          days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
          days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series   
       
       Else
          card_bytes_free_assgnd            = card_bytes_free_assgnd + bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat + bytes_tbl_flux_notes 
          days_more_tbl_flux_CSFormat_notes = days_more_tbl_flux_CSFormat_notes + DAY_FLUX_CRD
          days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes   

      EndIf 

        card_bytes_free_unassgnd  = card_bytes_free - card_bytes_free_assgnd 

    Wend 

        If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat_notes) Then 
          card_storage_available_days = days_totl_tbl_flux_CSFormat_notes
        Else
          card_storage_available_days = days_totl_tbl_Time_Series
        EndIf  

  #EndIf '(ONE_FL_TABLE)   

 Else
     days_actv_tbl_Time_Series          = NaN
     days_more_tbl_Time_Series          = NaN
     days_totl_tbl_Time_Series          = NaN
     
   #If (ONE_FL_TABLE) Then 
      days_actv_tbl_flux_CSFormat       = NaN    
      days_more_tbl_flux_CSFormat       = NaN   
      days_totl_tbl_flux_CSFormat       = NaN   
   #Else 
      days_actv_tbl_flux_CSFormat_notes = NaN  
      days_more_tbl_flux_CSFormat_notes = NaN
      days_totl_tbl_flux_CSFormat_notes = NaN
   #EndIf '(ONE_FL_TABLE)

      card_storage_available_days       = NaN 
   
 EndIf '(card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.")
'** END OF INITIAL CHECK HOW MANY DAYS LEFT FOR DATA STORAGE IN MicroSD **
 
 
'*****        PREPARATION OF MEASUREMENTS AND COMPUTATION            ***** 
  '***  Read date and time from CR1000X for the first soil heat flux through ground surface  
   RealTime(realtime_array(1))

 #If (SENSOR_HFP AND SENSOR_SWC) Then
   ' Variables used to calculate the number of seconds from the beginning of the program to the end of the first averaging interval (time interval offset)
   Offset_intv_delta_ht_storage = ((3600.0*realtime_array(4) + 60*realtime_array(5) + realtime_array(6)) MOD (60*OUTPUT_INTV)) 'result in seconds
 #EndIf
    
  '*** Set the SDM clock speed.
   SDMSpeed (SDM_CLCK_SPD)

 #If (SENSOR_GPS) Then
  '*** Set 3.3 VDC for pps
   PortPairConfig (GPS16X_PORT, 2)
 #EndIf
  
 #If (CDM_VOLT_116) Then
    '*** Add CDM-A/VOLT116 as a CPI module 
    CPIAddModule (MODEL_CDMVLT, SN_CDM_VOLT, CPI_DEVICE, CPI_CDM_VOLT)
 #EndIf 
'********* END OF PREPARATION OF MEASUREMENTS AND COMPUTATION ************  

 
'*****                     MAIN SCAN LOOP                            *****
Scan (SCN_INTV, mSec, SCAN_BUFFER_SIZE, 0)
 
 #If (SENSOR_GPS) Then   
   '*** GPS16X measurements
    GPS (latitude_GPS_degree, GPS16X_COM_PORT, UTC_OFST*3600, TIME_DIFF_RST_CR1000X, nmea_sentence(1))
 #EndIf
       
 #If (CDM_VOLT_116 AND SENSOR_FW) Then
  '*** CDM-A/VOLT116 panel temperature measurement
   CDM_PanelTemp (MODEL_CDMVLT, CPI_CDM_VOLT, T_cdm_volt_1, NMBR_TMPR_CDM_VOLT, CDM_VOLT_1ST_TMPR_CHAN, FIRST_NOTCH_FREQ_MAIN_SCAN)
 #EndIf  
       
 #If (SENSOR_FW) Then
'******                     Beginning of FW measurements             *****
   diag_FW_raw = FALSE
   CDM_TCDiff (MODEL_CDMVLT, CPI_CDM_VOLT, FW_raw, 1, mV200, FW_ANALOG_INPUT, TypeE, T_cdm_volt_4, TRUE, 500, FIRST_NOTCH_FREQ_MAIN_SCAN, 1, 0)
   If (FW_raw = NaN) OR (FW_raw > 80.0) OR (FW_raw < -50.0) Then diag_FW_raw = TRUE
    
   CallTable delay_fw                                                     'FW measured temperature and diagnostic code
'***************************  End of FW measurements  ********************
 #EndIf
 
 #If (SENSOR_T_RH) 
 '*****         Temperature and humidity probe measurements           *****
   #If (SENSOR_CS310) Then 
      VoltSe (T_probe, 2, mV1000, TMPR_RH_ANALOG_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_MAIN_SCAN, 1, 0)

   #Else    
     VoltDiff(T_probe, 1, mV1000, TMPR_RH_ANALOG_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_MAIN_SCAN, 1, 0)
     CDM_VoltDiff (MODEL_CDMVLT, CPI_CDM_VOLT, RH_probe, 1, mV1000, TMPR_RH_CDMVOLT_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_MAIN_SCAN, 1, 0)

   #EndIf '(SENSOR_CS310) 
   T_probe  = T_probe*TMPR_MULT + TMPR_OFST
   RH_probe = RH_probe*RH_MULT  + RH_OFST

 '**********  End of temperature and humidity probe measurements **********
 #EndIf '(SENSOR_T_RH)   

 '*****                 CSI IRGA + CSAT MEASUREMENTS                   *****
 If (set_CO2_fast_tmpr_flg AND (CO2_fast_tmpr <> select_CO2_fast_tmpr)) Then 
    CO2_fast_tmpr = select_CO2_fast_tmpr
    set_CO2_fast_tmpr_flg = FALSE
 EndIf 

    '*** Get EC100 data
     EC100 (sonic_irga_raw(1), EC100SDM_ADR, 2)                               '1st to 5th elements: Sonic data and 6th to 13th elements: IRGA, air temperature, and pressure data; 13th element is alternative CO2 output available in EC100 OS 7.01.

 If (CO2_fast_tmpr) Then
   sonic_irga_raw(14) = sonic_irga_raw(6)                                     'Backup conventional CO2
   sonic_irga_raw(6)  = sonic_irga_raw(13)                                    'If CO2_fast_tmpr = true, calculations using alternative CO2 corrected using air temperature derived from Ts and H2O.
   sonic_irga_raw(13) = sonic_irga_raw(14)                                    'Put conventional CO2 to the element that was alternative CO2 
 EndIf
    
#If (CSAT3A_EC150) Then
 #If (CSAT_TYP_3AH) Then
    AvgRun (Ts_rung_mean,    1, sonic_irga_raw(4),  (SLW_SCN_INTV/SCN_INTV))  'Running average of Ts
    AvgRun (press_rung_mean, 1, sonic_irga_raw(10), (SLW_SCN_INTV/SCN_INTV))  'Running average of press
       
   diag_sonic_tmp      = IIF ((sonic_irga_raw(5) <> NaN) AND (sonic_irga_raw(5) <> -1), sonic_irga_raw(5), &h3f)
   diag_sonic_slwintv = diag_sonic_slwintv OR diag_sonic_tmp
 #EndIf '(CSAT_TYP_3AH)       
#EndIf '(CSAT3A_EC150) 

   CallTable delay_3d                                                 'Sonic data: Ux, Uy, Uz, Ts, and diag_sonic 
   CallTable delay_cs                                                 'IRGA data: conventional or alternative CO2, H2O, diag_irga, T_amb, press_amb, CO2_sig_strgth, H2O_sig_strgth, and alternative or conventional CO2
     
 If (sonic_irga_raw(8) = NaN) Then                                    'The EC150 diagnostic word (diag_irga) is sonic_irga_raw(8).
    NaN_cnt += 1
      
   'Do not reset if irga was turned off manually or automatically due to low voltage. NaN_cnt may be greater after zero/span is set when measurement frequency is higher.   
   If ((NaN_cnt > (600 + SLW_SCN_INTV)/SCN_INTV) AND (NOT irga_vlt_low_auto_off) AND _
     (NOT irga_pwr_off_f) AND (V_batt_runng > SYSTEM_PWR_OFF_SET_PT)) Then      
       config_ec100_f = TRUE
       NaN_cnt        = 0
   EndIf

 Else
      NaN_cnt = 0

 EndIf '(sonic_irga_raw(8) = NAN)
    
'*** Preparation for Manual IRGA Power Control
'Flag user options for IRGA power off
If (set_irga_power_flg) Then
  set_irga_power_flg = FALSE
   
  If (NOT irga_pwr_switch_f) Then           'In this case, give a priority to "auto power off/on"    
  
     Select Case irga_power 
       Case PWR_ON
         irga_pwr_off_f = FALSE 
       Case PWR_OFF
         irga_pwr_off_f = TRUE   
     EndSelect
  
  Else 
     irga_power = irga_pwr_array (1, 2)
     Select Case irga_power 
       Case PWR_ON
         prev_value_str = "IRGA on"  
         curr_value_str = prev_value_str
       Case PWR_OFF
         prev_value_str = "IRGA off"  
         curr_value_str = prev_value_str   
     EndSelect
     message = "Auto pwr swtchng: Manual oprtn cancld."
     CallTable System_Operatn_Notes
     
  EndIf '(NOT irga_pwr_switch_f)
EndIf '(set_irga_power_flg) 

'Flag switch power 
If (irga_pwr_off_f_prev <> irga_pwr_off_f) AND (NOT irga_pwr_switch_f) Then
   If (irga_pwr_off_f AND (secs_snc_pwr_swtch >= 120)) Then
                  
     irga_pwr_switch_f    = TRUE
     irga_pwr_array(1, 2) = PWR_OFF     'Turn IRGA off.
     irga_pwr_array(2, 2) = H_OFF       'Turn heating off 

     prev_value_str       = "IRGA on"
     curr_value_str       = "IRGA off"  
     message              = "IRGA manually off."
     irga_pwr_off_f_prev  = irga_pwr_off_f
                
   ElseIf (irga_pwr_off_f AND (secs_snc_pwr_swtch < 120)) Then
     message = "EC100 being turned off w/in 120 s."
   
   ElseIf ((NOT irga_pwr_off_f) AND (V_batt_runng > SYSTEM_PWR_OFF_SET_PT) AND (secs_snc_pwr_swtch > 100)) Then 

     irga_pwr_switch_f    = TRUE
     irga_pwr_array(1, 2) = PWR_ON          'Turn IRGA on.
     irga_pwr_array(2, 2) = heater_user       'Turn heating on.   
    
     prev_value_str      = "IRGA off"
     curr_value_str      = "IRGA on"              
     message             = "IRGA manually on."
     irga_pwr_off_f_prev = irga_pwr_off_f
                   
   ElseIf ((NOT irga_pwr_off_f) AND (V_batt_runng <= SYSTEM_PWR_OFF_SET_PT)) Then
                  
     message        = "IRGA cannot be on: low volt."
     irga_pwr_off_f = irga_pwr_off_f_prev
                   
   ElseIf ((NOT irga_pwr_off_f) AND (V_batt_runng > SYSTEM_PWR_OFF_SET_PT) AND (secs_snc_pwr_swtch <= 100))  Then  
     message = "IRGA being turned on w/in 100 s."
                   
   EndIf '(irga_pwr_off_f AND (secs_snc_pwr_swtch >= 120))
 EndIf '(irga_pwr_off_f_prev <> irga_pwr_off_f)
 
 '*Note the changes in span gases 
 'CO2 span gas 
 If (CO2_span_gas <> CO2_span_gas_prev) Then 
    prev_value_str = CO2_span_gas_prev & " umol mol-1"
    curr_value_str = CO2_span_gas      & " umol mol-1"              
    message        = "CO2 span gas value rest." 
    CallTable System_Operatn_Notes
      
    CO2_span_gas_prev = CO2_span_gas
 EndIf 
   
 'H2o Span gas 
 If (T_DP_span_gas <> T_DP_span_gas_prev) Then 
    prev_value_str = T_DP_span_gas_prev & " Deg C"
    curr_value_str = T_DP_span_gas      & " Deg C"              
    message        = "H2O span gas value rest." 
    CallTable System_Operatn_Notes
      
    T_DP_span_gas_prev = T_DP_span_gas
  EndIf 
 

'*** EC100 CONFIGURATION 
Select Case config_ec100_initial_f

  'INITIAL CONFIGURATION 
  Case TRUE

    If (sonic_irga_raw(8) <> NAN) Then 
        
      '** Record previous configurations of EC100 before the OPEC system starts to take measurements 
      If (get_ec100_config_f AND config_ec100_f) Then
        
        Call Config (ec100_setting_array(1,1), 11, get_ec100_config_f)    'Get previous configuration of EC100.
          config_type    = "Recrd prev config"
          config_status  = "Started"
          curr_value_str = "Recrding"
          
          If (operatn_failed_cnt = 0) Then 
          prev_value_str = "Starting"
          Else
          prev_value_str = curr_value_str
          EndIf             
          
        If (NOT get_ec100_config_f) Then 
          config_status = "Recrded" 
          press_source   = ec100_setting_array(2, 2)                      'Reconfirmation
          CO2_zero_coeff = ec100_setting_array(5, 2)
          CO2_span_coeff = ec100_setting_array(6, 2)
          H2O_zero_coeff = ec100_setting_array(7, 2)
          H2O_span_coeff = ec100_setting_array(8 ,2)
          heater_actual  = ec100_setting_array(9, 2)
          heater_user    = heater_actual
          irga_power     = ec100_setting_array(10, 2)  
          shadow_corr    = ec100_setting_array(11, 2)
          
           For i = 1 To 11 
               ec100_reset_array(i, 2) = ec100_setting_array(i,2)
           Next i 
          CallTable Config_Setting_Notes                                  'Record previous configuration of gas analyzer on compiling. 
 
          message = "EC100: Prev config recrded"
        
        operatn_failed_cnt = 0
        Else
          operatn_failed_cnt = operatn_failed_cnt + 1
          
          message = "Recrd prev EC100 config: Failed " & operatn_failed_cnt & "."
          
        EndIf '(NOT get_ec100_config_f)
        CallTable System_Operatn_Notes
        NaN_cnt = 0
      
      EndIf '(get_ec100_config_f and config_ec100_f)
      

      '** Check EC100 configurations. If not as required, the EC100 are reconfigured as required   
      If (config_ec100_f AND (NOT get_ec100_config_f)) Then   
        If ((ec100_setting_array (1, 2) <> BANDWIDTH) OR (ec100_setting_array (2, 2) <> DIFFERENTIAL_PRESS) _
           OR (ec100_setting_array (4, 2) <> TEMPERATURE_SOURCE)) Then  
                     
          Call Config (config_ec100_array(1, 1), 3, config_ec100_f)       'Configure EC100 with default settings as required by a user.

          config_type    = "Requr setting"
          config_status  = "Requrng" 
          curr_value_str = "Config as requrd"
          If (operatn_failed_cnt = 0) Then 
          prev_value_str = "Recrdng"
          Else
          prev_value_str = curr_value_str
          EndIf  
          
          If (NOT config_ec100_f) Then
            config_status       = "Requrd"  
            get_ec100_config_f  = TRUE 
            message = "EC100 reconfigrd as required"         
                        
          operatn_failed_cnt = 0
          Else 
            operatn_failed_cnt = operatn_failed_cnt + 1
 
            message = "EC100 reconfig: failed " & operatn_failed_cnt & "."
             
          EndIf '(NOT ec100_config_f)
          CallTable System_Operatn_Notes
          NaN_cnt = 0
          
        Else 
          curr_value_str = "Config chck"
          prev_value_str = "Recrding"
          message        = "EC100 config matches as required" 
          config_ec100_f = FALSE
          
          CallTable System_Operatn_Notes
          NaN_cnt = 0
       
        EndIf '((ec100_setting_array (1, 2) <> BANDWIDTH) OR (ec100_setting_array (2, 2) <> DIFFERENTIAL_PRESS) _

      EndIf '(config_ec100_f AND (NOT get_ec100_config_f))   
      

     '** Record EC100 configuration again if EC100 was reconfigured for required configurations
     If (get_ec100_config_f AND (NOT config_ec100_f)) Then
   
       Call Config (ec100_setting_array(1, 1), 11, get_ec100_config_f)     'Get previous EC100 configuration after reconfiguration as required.   
       config_type    = "Recrd reconfig"
       config_status  = "Started"
       curr_value_str = "Rcrding"
       If (operatn_failed_cnt = 0) Then
       prev_value_str = "Config as requrd" 
       Else  
       prev_value_str = curr_value_str 
       EndIf     
   
       If (NOT get_ec100_config_f) Then
          config_status  = "Recrded" 
       
          For i = 1 To 11
          ec100_reset_array(i, 2) = ec100_setting_array(i, 2)
          Next i      
          CallTable Config_Setting_Notes
       
          message = "EC100 reconfig recrded."
 
       operatn_failed_cnt = 0    
       Else 
         operatn_failed_cnt = operatn_failed_cnt + 1
     
         message = "Reading EC100 reconfigs failed: # " & operatn_failed_cnt & "."
        
       EndIf '(NOT get_ec100_config_f) 
       CallTable System_Operatn_Notes
       NaN_cnt        = 0
       config_ec100_f = FALSE                                              'Make sure to keep config_ec100_f = FALSE
    
     EndIf '(get_ec100_config_f and (NOT config_ec100_f)) 
     
   
     '** Check zero/span coefficients. Flag these out of reasonable ranges.
     '   If out of a reasonable range, these will be individually reset for default values in section of coefficient reset    
     If ((NOT config_ec100_f) AND (NOT get_ec100_config_f)) Then            
       For i = 1 To 4
      
         Select Case i 

           Case 1 
           prev_value_str = "CO2zro coef: N/A"
           curr_value_str = "CO2zro coef: " & CO2_zero_coeff  
           rst_CO2_zro_coef_flg = ((CO2_zero_coeff < 0.990) OR (CO2_zero_coeff > 1.011))   'Using data from 847 IRGASON and 427 EC150 CO2 zero coefficient mean +/- 10xSTD  
      
           Case 2
           prev_value_str = "CO2spn coef: N/A"
           curr_value_str = "CO2spn coef: " & CO2_span_coeff   
           rst_CO2_spn_coef_flg = ((CO2_span_coeff < 0.962) OR (CO2_span_coeff > 1.039))   'Using data from 847 IRGASON and 427 EC150 CO2 span coefficient mean +/- 5xSTD  
       
           Case 3
           prev_value_str = "H2Ozro coef: N/A"
           curr_value_str = "H2Ozro coef: " & H2O_zero_coeff   
           rst_H2O_zro_coef_flg = ((H2O_zero_coeff < 0.979) OR (H2O_zero_coeff > 1.020))   'Using data from 847 IRGASON and 427 EC150 H2O zero coefficient mean +/- 10xSTD 
       
           Case 4
           prev_value_str = "H2Ospn coef: N/A" 
           curr_value_str = "H2Ospn coef: " & H2O_span_coeff 
           rst_H2O_spn_coef_flg = ((H2O_span_coeff < 0.940) OR (H2O_span_coeff > 1.057))   'Using data from 847 IRGASON and 427 EC150 H2O span coefficient mean +/- 5xSTD  

         EndSelect 'i 
      
         If (rst_zro_spn_coef_flg_array (i)) Then                
                    
           Select Case i 
             
             Case 1
             message = "CO2zro coef out of rng to reset."        'Process will reset this coeff.  
             Case 2   
             message = "CO2spn coef out of rng to reset."        'Process will reset this coeff. 
             Case 3   
             message = "H2Ozro coef out of rng to reset."        'Process will reset this coeff. 
             Case 4   
             message = "H2Ospn coef out of rng to reset."        'Process will reset this coeff. 
             
           EndSelect 'i 
       
         Else  
          'If not out of range, the current coefficients from irga will be used for future reset  
          Select Case i
          
            Case 1
            message = "CO2zro coef in rng."
            rst_zro_spn_coeff_array (1, 2) = CO2_zero_coeff

            Case 2   
            message = "CO2spn coef in rng."
            rst_zro_spn_coeff_array (2, 2) = CO2_span_coeff
         
            Case 3   
            message = "H2Ozro coef in rng."
            rst_zro_spn_coeff_array (3, 2) = H2O_zero_coeff
         
            Case 4   
            message = "H2Ospn coef in rng."
            rst_zro_spn_coeff_array (4, 2) = H2O_span_coeff
         
          EndSelect 'i  
         EndIf '(rst_zro_spn_coef_flg_array (i))         
         CallTable System_Operatn_Notes
  
       Next i 
       NaN_cnt = 0
       config_ec100_initial_f = FALSE
       prev_value_str = "Chck coeffs"     'For the judgment of mode in the following processes and a record in System_Operatn_Notes 
  
     EndIf '((NOT config_ec100_f) AND (NOT get_ec100_config_f)) 

    Else 
      If (NaN_cnt > (600 + SLW_SCN_INTV)/SCN_INTV) Then 
          
         If (prev_value_str = NaN) Then 
             prev_value_str = "Not running"
             curr_value_str = "Initialztn"
         EndIf 
         message = "While starting, NaN diag: " & NaN_cnt   
         CallTable System_Operatn_Notes
         NaN_cnt = 0
       
      EndIf '(NaN_cnt > (600 + SLW_SCN_INTV)/SCN_INTV)        

    EndIf '(sonic_irga_raw(8) <> NaN)

'CONFIGURATIONS WHILE PROGRAM IS RUNNING
'Note: EC100 reconfiguration is initiated by different flags: Power control, reconfiguration, barometer swicth, 
'      shadow correction switch, zero/span, reset zero/span coefficients, field auto H2O zero if in option, and heating switch.  
Case FALSE                                                  'config_ec100_initial_f = FALSE 
  
  
 '** Power on/off IRGA: First priority in configuration            
 If (irga_pwr_switch_f) Then 
 
   Call Config (irga_pwr_array(1, 1), 2, irga_pwr_switch_f)
   config_type   = "IRGA pwr"
   config_status = "Switching" 
  
   Select Case irga_pwr_array(1, 2)            
     Case PWR_ON 
       prev_value_str_pwr = "IRGA off"
     Case PWR_OFF
       prev_value_str_pwr = "IRGA on"
   EndSelect 

   If (NOT irga_pwr_switch_f) Then 
      config_status      = "Switched" 
      config_commend     = 21
      get_ec100_config_f = TRUE 
      
      'Notes: prev_value_str, curr_value_str, and message are assigned while irga_pwr_switch_f is set to true       
                          
      Select Case V_batt_runng 
        Case Is < SYSTEM_PWR_OFF_SET_PT                                'Auto turn off due to low voltage
          irga_vlt_low_auto_off = TRUE  
          irga_user_set_pwr_on  = (NOT irga_pwr_off_f) 
          irga_pwr_off_f        = TRUE 
          irga_pwr_off_f_prev   = TRUE
 
        Case Is >= SYSTEM_PWR_OFF_SET_PT  
          If (irga_vlt_low_auto_off AND irga_pwr_off_f) Then           'Auto turn on after auto-off due to low voltage  
            irga_vlt_low_auto_off = FALSE 
            irga_pwr_off_f        = FALSE
            irga_pwr_off_f_prev   = FALSE
                  
          ElseIf (irga_vlt_low_auto_off AND (NOT irga_pwr_off_f)) Then  'Manually turn on after auto-off due to low voltage   
            irga_vlt_low_auto_off = FALSE 
            irga_user_set_pwr_on  = TRUE 
                     
          ElseIf (NOT irga_vlt_low_auto_off) Then                       'Manually turn on/off normally (not related to low voltage)   
            irga_user_set_pwr_on = (NOT irga_pwr_off_f)                      
            
          EndIf 

        EndSelect 'V_batt_runng 

        Timer (1, Sec, 2)
        secs_snc_pwr_swtch = 0
   
   operatn_failed_cnt = 0  
   CallTable System_Operatn_Notes                               'Must be here    
   Else 
     operatn_failed_cnt = operatn_failed_cnt + 1
     If (operatn_failed_cnt > 2000/SCN_INTV) Then               'Give the 2 seconds for IRGA on/off process 
       
       prev_value_str = prev_value_str_pwr
       curr_value_str = prev_value_str_pwr         
       message = "IRGA switch failed #" & operatn_failed_cnt & "."
       CallTable System_Operatn_Notes                            'Must be here
     
       irga_pwr_switch_f     = FALSE
       irga_pwr_off_f        = FALSE
       irga_pwr_off_f_prev   = FALSE
       irga_power            = ec100_reset_array (10, 2)
       irga_pwr_array (1, 2) = ec100_reset_array (10, 2)
       irga_pwr_array (2, 2) = heater_user

     EndIf 
               
   EndIf '(NOT irga_pwr_switch_f)
   NaN_cnt        = 0
   config_ec100_f = FALSE 
   

 '**  Within 120 seconds of IRGA on, CPEC system does not perform configurations in any "Elseif" segment below   
 ElseIf ((Left(config_status, 11) = "Switched on") AND (secs_snc_pwr_swtch < 120)) Then 
     config_ec100_f         = FALSE
     set_press_source_flg   = FALSE
     set_shadow_corr_flg    = FALSE
     set_zero_flg           = FALSE
     set_CO2_span_flg       = FALSE
     set_H2O_span_flg       = FALSE
     rst_CO2_zro_coef_flg   = FALSE
     rst_CO2_spn_coef_flg   = FALSE
     rst_H2O_zro_coef_flg   = FALSE
     rst_H2O_spn_coef_flg   = FALSE
     set_heater_flg         = FALSE
     message = "IRGA warming up"
     
 
  '** Reset all configurations as previous ones if EC100 continously output NaN for diagnosis code.
  ElseIf (config_ec100_f) Then 
    
    Call Config (ec100_reset_array(1, 1), 11, config_ec100_f)         'Reconfigure EC100 with previous settings.
    config_type   = "Reconfig"
    config_status = "Reconfgurng" 
        
    curr_value_str = "Reconfig"
    If (operatn_failed_cnt = 0) Then 
    prev_value_str = "fld_mea"
    Else
    prev_value_str = curr_value_str
    EndIf    
        
    If (NOT config_ec100_f) Then
       config_status      = "Reconfigrd"  
       config_commend     = 1000
       get_ec100_config_f = TRUE 
       message            = "EC100 reconfigrd" 
        
     operatn_failed_cnt = 0  
     Else 
       operatn_failed_cnt = operatn_failed_cnt + 1
          
       message = "EC100 reconfig failed: #" & operatn_failed_cnt & "."
           
     EndIf '(NOT config_ec100_f)
     CallTable System_operatn_Notes
     NaN_cnt =0 
     
   
  '** Switch options for barometer       
  ElseIf (set_press_source_flg AND (sonic_irga_raw(8) <> NaN)) Then
    
     press_source_array(1, 2) = press_source
     Call Config (press_source_array(1, 1), 1, set_press_source_flg)
     config_type   = "Barometer"
     config_status = "Switching" 
        
     Select Case ec100_reset_array(2, 2)
       Case BB   
         prev_value_str = "Basic"            
       Case EB   
         prev_value_str = "Extended"  
       Case UB   
         prev_value_str = "User-slctd" 
     EndSelect 

     If (NOT set_press_source_flg) Then                                    'Record EC100 re-configuration 
       config_status      = "Switched" 
       config_commend     = 2
       get_ec100_config_f = TRUE
       
      Select Case press_source
      
        Case BB   
        curr_value_str = "Basic"            
        Case EB   
        curr_value_str = "Extended" 
        Case UB   
        curr_value_str = "User-slctd"  
       
      EndSelect 
      message = "Barometer optn switchd."
  
     operatn_failed_cnt = 0 
     Else 
       operatn_failed_cnt = operatn_failed_cnt + 1 
    
       curr_value_str = prev_value_str            
       message = "Barometer optn switch: Failed #" & operatn_failed_cnt & "."

     EndIf '(NOT set_press_source_flg)
     CallTable System_Operatn_Notes
     NaN_cnt        = 0
     config_ec100_f = FALSE                                                'Make sure config_ec100_f to be FALSE.
     
 
  '** Switch Shadow correction option        
  ElseIf (set_shadow_corr_flg AND (sonic_irga_raw(8) <> NaN)) Then
    
     shadow_corr_array(1, 2) = shadow_corr
     Call Config (shadow_corr_array(1, 1), 1, set_shadow_corr_flg)
     config_type   = "Shadow crrctn"
     config_status = "Switching" 
        
     Select Case ec100_reset_array(11, 2) 
       Case CORR_ON 
         prev_value_str = "On"
       Case  CORR_OFF 
         prev_value_str = "Off"
     EndSelect                  
 
     If (NOT set_shadow_corr_flg) Then
       config_status      = "Swtched" 
       config_commend     = 25 
       get_ec100_config_f = TRUE 
          
       Select Case shadow_corr 
         Case CORR_ON           
           curr_value_str = "On"
         Case CORR_OFF  
           curr_value_str = "Off"
       EndSelect 
       message = "Shadow corrctn switchd."        

     operatn_failed_cnt = 0 
     Else    
       operatn_failed_cnt = operatn_failed_cnt + 1
       
       curr_value_str = prev_value_str
       message = "Shadow corrctn switchd: Failed #" & operatn_failed_cnt & "."    
        
     EndIf '(NOT set_shadow_corr_flg) 
     CallTable System_Operatn_Notes
     NaN_cnt = 0 
     config_ec100_f = FALSE    
      

  '** Zero CO2/H2O
   ElseIf (set_zero_flg AND (sonic_irga_raw(8) <> NaN)) Then
     
     If (operatn_failed_cnt = 0) Then     
     prev_value_str_CO2 = "CO2: " & sonic_irga_raw (6) & " mg m-3"
     prev_value_str_H2O = "H2O: " & sonic_irga_raw (7) & " g m-3"
     EndIf
     
     Call Config (zro_array(1, 1), 1, set_zero_flg)
     config_type   = "CO2/H2O Zro"
     config_status = "Zeroing"  
  
     If (NOT set_zero_flg) Then
       config_status      = "Zeroed"  
       config_commend     = 111            '11 and 1, used for zeroing              
       get_ec100_config_f = TRUE
                
       prev_value_str = prev_value_str_CO2 
       curr_value_str = "CO2: 0 mg m-3" 
       message        = "CO2 zro prfrmed."
       CallTable System_Operatn_Notes
              
       prev_value_str = prev_value_str_H2O 
       curr_value_str = "H2O: 0 g m-3" 
       message        = "H2O zro prfrmed."
       CallTable System_Operatn_Notes
    
     operatn_failed_cnt = 0   
     Else
       operatn_failed_cnt = operatn_failed_cnt + 1  

       Select Case operatn_failed_cnt 
       
         Case 1, 2
           prev_value_str     = prev_value_str_CO2
           prev_value_str_CO2 = "CO2: " & sonic_irga_raw (6) & " mg m-3" 
           curr_value_str     = prev_value_str_CO2 
           message            = "CO2 zro operatn #" & operatn_failed_cnt & " to retry." 
         Case 3
           prev_value_str     = prev_value_str_CO2  
           curr_value_str     = "CO2: " & sonic_irga_raw (6) & " mg m-3" 
           message            = "CO2 zro operatn #3 failed: aborted." 
              
       EndSelect 'operatn_failed_cnt
       CallTable System_Operatn_Notes
     
       Select Case operatn_failed_cnt 
       
         Case 1, 2 
           prev_value_str     = prev_value_str_H2O
           prev_value_str_H2O = "H2O: " & sonic_irga_raw (7) & " g m-3" 
           curr_value_str     = prev_value_str_H2O 
           message = "H2O zro operatn #" & operatn_failed_cnt & " to retry." 
         Case 3
           set_zero_flg   = FALSE
           prev_value_str = prev_value_str_H2O  
           curr_value_str = "H2O: " & sonic_irga_raw (7) & " g m-3" 
           message        = "H2O zro operatn #3 failed: aborted." 
     
       operatn_failed_cnt = 0 
       EndSelect 'operatn_failed_cnt
       CallTable System_Operatn_Notes
     
     EndIf '(NOT set_zero_flg)
     NaN_cnt        = 0
     config_ec100_f = FALSE
         
        
   '** Span CO2     
   ElseIf (set_CO2_span_flg AND (sonic_irga_raw(8) <> NaN)) Then
     
     If (operatn_failed_cnt = 0) Then 
     prev_value_str_CO2 = "CO2: " & CO2_mixratio_kd & " umol mol-3"
     EndIf       

     spn_CO2_array(1, 2) = CO2_span_gas
     Call Config (spn_CO2_array(1, 1), 2, set_CO2_span_flg)
     config_type   = "CO2 span"
     config_status = "Spanning" 
        
     If (NOT set_CO2_span_flg) Then 
        config_status      = "Spanned"
        config_commend     = 112                                 '11 and 2, used for CO2 span 
        get_ec100_config_f = TRUE
        
        prev_value_str = prev_value_str_CO2 
        curr_value_str = "CO2: " & CO2_span_gas & " umol mol-3" 
        message        = "CO2 spn prfrmed."
        CallTable System_Operatn_Notes

     operatn_failed_cnt = 0  
     Else
       operatn_failed_cnt = operatn_failed_cnt + 1 

       Select Case operatn_failed_cnt 
       
         Case 1, 2
           prev_value_str     = prev_value_str_CO2
           prev_value_str_CO2 = "CO2: " & CO2_mixratio_kd & " umol mol-3" 
           curr_value_str     = prev_value_str_CO2 
           message            = "CO2 spn operatn #" & operatn_failed_cnt & " to retry." 
         Case 3
          set_CO2_span_flg    = FALSE
          prev_value_str      = prev_value_str_CO2  
          curr_value_str      = "CO2: " & CO2_mixratio_kd & " umol mol-3" 
          message             = "CO2 spn operatn #3 failed: aborted." 
         
       operatn_failed_cnt = 0          
       EndSelect 'operatn_failed_cnt
       CallTable System_Operatn_Notes
                            
     EndIf '(NOT set_CO2_span_flg)
     NaN_cnt        = 0
     config_ec100_f = FALSE
     
 
  '** Span H2O       
  ElseIf (set_H2O_span_flg AND (sonic_irga_raw(8) <> NaN)) Then
    
     If (operatn_failed_cnt = 0) Then 
     prev_value_str_H2O = "Dew PT: " & T_DP & " Deg C"    
     EndIf 

     spn_H2O_array(1, 2) = T_DP_span_gas
     Call Config (spn_H2O_array(1, 1), 2, set_H2O_span_flg)
     config_type   = "H2O span"
     config_status = "Spanning" 
        
     If (NOT set_H2O_span_flg) Then 
       config_status      = "Spanned" 
       config_commend     = 113                                 '11 and 3, used for H2O span  
       get_ec100_config_f = TRUE 
 
       prev_value_str = prev_value_str_H2O 
       curr_value_str = "Dew PT: " & T_DP & " Deg C" 
       message        = "H2O spn prfrmed."
       CallTable System_Operatn_Notes
   
     operatn_failed_cnt = 0
     Else 
       operatn_failed_cnt = operatn_failed_cnt + 1
    
       Select Case operatn_failed_cnt 
       
         Case 1, 2
           prev_value_str     = prev_value_str_H2O
           prev_value_str_H2O = "Dew PT: " & T_DP & " Deg C" 
           curr_value_str     = prev_value_str_H2O 
           message            = "H2O spn operatn #" & operatn_failed_cnt & " to retry." 
         Case 3
           set_H2O_span_flg    = FALSE
           prev_value_str     = prev_value_str_H2O  
           curr_value_str     = "Ddew PT: " & T_DP & " Deg C" 
           message            = "H2O spn operatn #3 failed: aborted." 
         
       operatn_failed_cnt = 0          
       EndSelect 'operatn_failed_cnt
       CallTable System_Operatn_Notes

     EndIf '(NOT set_H2O_span_flg) 
     NaN_cnt        = 0
     config_ec100_f = FALSE
     

  '** Reset CO2 zero coefficient
  ElseIf (rst_CO2_zro_coef_flg AND (sonic_irga_raw(8) <> NaN)) Then  

  If ((CO2_zero_coeff < 0.990) OR (CO2_zero_coeff > 1.011)) Then 
  
    'Initial CO2_zero_coeff in IRGA is out of range 
    If ((ec100_reset_array(5, 2) = ec100_setting_array(5, 2)) AND (ec100_reset_array(5, 2) <> rst_zro_spn_coeff_array(1, 2))) Then
      
      prev_value_str = "CO2 zro coef: " & CO2_zero_coeff 
      curr_value_str = "CO2 zro coef: " & rst_zro_spn_coeff_array(1, 2) 
      message        = "Initl CO2zro coef out of rng: Rest as " & rst_zro_spn_coeff_array(1, 2) & "."
          
    'Input of CO2_zero_coeff from Public or CR1000KD is out of range 
    ElseIf ((CO2_zero_coeff <> ec100_setting_array(5, 2)) AND (rst_zro_spn_coeff_array(1, 2) = ec100_reset_array(5, 2))) Then
      
      prev_value_str = "CO2 zro coef: " & rst_zro_spn_coeff_array(1, 2) 
      curr_value_str = "CO2 zro coef: " & rst_zro_spn_coeff_array(1, 2) 
      message        = "CO2zro coef rest ignored, input out of rng: " & CO2_zero_coeff & "."
    
      CO2_zero_coeff       = rst_zro_spn_coeff_array(1, 2)
      rst_CO2_zro_coef_flg = FALSE 
      CallTable System_Operatn_Notes
   
    'Zero procedure failed: CO2_zero_coeff out of range 
    ElseIf ((ec100_reset_array(5, 2) <> ec100_setting_array(5, 2)) AND (ec100_reset_array(5, 2) = rst_zro_spn_coeff_array(1, 2))) Then
      
      prev_value_str = "CO2 zro coef: " & CO2_zero_coeff 
      curr_value_str = "CO2 zro coef: " & rst_zro_spn_coeff_array(1, 2) 
      message        = "CO2zro failed: Rest coef bck to " & rst_zro_spn_coeff_array(1, 2) & "."
      
    EndIf '((ec100_reset_array(5, 2) = ec100_setting_array(5, 2)) AND ........    

  EndIf '((CO2_zero_coeff < 0.991) OR (CO2_zero_coeff > 1.011))  
 
      
  'CO2_zero_coeff was inputted in the range from Public or CR1000KD.  
  If ((CO2_zero_coeff >= 0.991) AND (CO2_zero_coeff <= 1.011) AND (CO2_zero_coeff <> ec100_setting_array(5, 2))) Then
    
    prev_value_str = "CO2 zro coef: " & ec100_setting_array(5, 2) 
    curr_value_str = "CO2 zro coef: " & CO2_zero_coeff
    message        = "CO2zro coef rest by user as " & CO2_zero_coeff & "."
    rst_zro_spn_coeff_array(1, 2) = CO2_zero_coeff
    
  EndIf 
  
  If (rst_CO2_zro_coef_flg) Then    
            
    Call Config (rst_zro_spn_coeff_array(1, 1), 1, rst_CO2_zro_coef_flg)
    config_type    = "Rest CO2zro coef"
    config_status  = "Resetting"

    If (NOT rst_CO2_zro_coef_flg) Then 
      config_status      = "Reset" 
      config_commend     = 14   
      get_ec100_config_f = TRUE
   
    operatn_failed_cnt = 0
    Else
      operatn_failed_cnt = operatn_failed_cnt + 1
      curr_value_str     = prev_value_str
            
      Select Case operatn_failed_cnt
        
        Case 1, 2 
          message = "CO2 zro coef rest #" & operatn_failed_cnt & " to retry."
        Case 3 
          rst_CO2_zro_coef_flg = FALSE
          message = "CO2 zro coef rest #3 failed: aborted."
          
          CO2_zero_coeff                = ec100_setting_array(5, 2)
          ec100_reset_array(5, 2)       = CO2_zero_coeff
          rst_zro_spn_coeff_array(1, 2) = CO2_zero_coeff
          
      operatn_failed_cnt = 0    
      EndSelect 
                
    EndIf '(NOT rst_CO2_zro_coef_flg)
    CallTable System_Operatn_Notes
    NaN_cnt        = 0
    config_ec100_f = FALSE

   EndIf '(rst_CO2_zro_coef_flg)  
   

  '** Reset CO2 span coefficient
  ElseIf (rst_CO2_spn_coef_flg AND (sonic_irga_raw(8) <> NaN)) Then  
  
    If ((CO2_span_coeff < 0.962) OR (CO2_span_coeff > 1.039)) Then 
  
      'Initial CO2_span_coeff in IRGA is out of range 
      If ((ec100_reset_array(6, 2) = ec100_setting_array(6, 2)) AND (ec100_reset_array(6, 2) <> rst_zro_spn_coeff_array(2, 2))) Then
      
        prev_value_str = "CO2 spn coef: " & CO2_span_coeff 
        curr_value_str = "CO2 spn coef: " & rst_zro_spn_coeff_array(2, 2) 
        message        = "Initl CO2spn coef out of rng: Rest as " & rst_zro_spn_coeff_array(2, 2) & "."

      'Input of CO2_span_coeff from Public or CR1000KD is out of range 
      ElseIf ((CO2_span_coeff <> ec100_setting_array(6, 2)) AND (rst_zro_spn_coeff_array(2, 2) = ec100_reset_array(6, 2))) Then
      
        prev_value_str = "CO2 spn coef: " & ec100_setting_array(6, 2) 
        curr_value_str = "CO2 spn coef: " & ec100_setting_array(6, 2) 
        message        = "CO2spn coef rest ignored, input out of rng: " & CO2_span_coeff & "."
    
        CO2_span_coeff       = rst_zro_spn_coeff_array(2, 2)
        rst_CO2_spn_coef_flg = FALSE 
        CallTable System_Operatn_Notes
  
      'Span procedure failed: CO2_span_coeff out of range 
      ElseIf ((ec100_reset_array(6, 2) <> ec100_setting_array(6, 2)) AND (ec100_reset_array(6, 2) = rst_zro_spn_coeff_array(2, 2))) Then
      
        prev_value_str = "CO2 spn coef: " & CO2_span_coeff 
        curr_value_str = "CO2 spn coef: " & rst_zro_spn_coeff_array(2, 2) 
        message        = "CO2spn failed: Rest coef bck to " & rst_zro_spn_coeff_array(2, 2) & "."
    
      EndIf '((ec100_reset_array(6, 2) = ec100_setting_array(6, 2)) AND ......
    
    EndIf '((CO2_span_coeff < 0.962) OR (CO2_span_coeff > 1.039)) 
 
      
    'CO2_span_coeff was inputted in the range from Public or CR1000KD.  
    If ((CO2_span_coeff >= 0.962) AND (CO2_span_coeff <= 1.039) AND (CO2_span_coeff <> ec100_setting_array(6, 2))) Then
    
      prev_value_str = "CO2 spn coef: " & ec100_setting_array(6, 2) 
      curr_value_str = "CO2 spn coef: " & CO2_span_coeff
      message        = "CO2spn coef rest by user as " & CO2_span_coeff & "."
      rst_zro_spn_coeff_array(2, 2) = CO2_span_coeff
    
    EndIf 
      
    If (rst_CO2_spn_coef_flg) Then   
    
      Call Config (rst_zro_spn_coeff_array(2, 1), 1, rst_CO2_spn_coef_flg)
      config_type    = "Rest CO2spn coef"
      config_status  = "Resetting"
  
      If (NOT rst_CO2_spn_coef_flg) Then
        config_status      = "Reset"
        config_commend     = 15    
        get_ec100_config_f = TRUE
    
      operatn_failed_cnt = 0
      Else 
       operatn_failed_cnt = operatn_failed_cnt + 1
       curr_value_str     = prev_value_str       
      
       Select Case operatn_failed_cnt
        
         Case 1, 2 
           message = "CO2 spn coef rest #" & operatn_failed_cnt & " to retry."
         Case 3 
           rst_CO2_spn_coef_flg = FALSE
           message = "CO2 spn coef rest #3 failed: aborted."
          
           CO2_span_coeff                = ec100_setting_array(6, 2)
           ec100_reset_array(6, 2)       = CO2_span_coeff
           rst_zro_spn_coeff_array(2, 2) = CO2_span_coeff
          
       operatn_failed_cnt = 0    
       EndSelect 
      EndIf '(NOT rst_CO2_spn_coef_flg)
      CallTable System_Operatn_Notes
      NaN_cnt        = 0
      config_ec100_f = FALSE
    
    EndIf '(rst_CO2_spn_coef_flg)
 

  '** Reset H2O zero coefficient   
  ElseIf (rst_H2O_zro_coef_flg AND (sonic_irga_raw(8) <> NaN)) Then

    If ((H2O_zero_coeff < 0.979) OR (H2O_zero_coeff > 1.020)) Then
 
      'Initial H2O_zero_coeff in IRGA is out of range 
      If ((ec100_reset_array(7, 2) = ec100_setting_array(7, 2)) AND (ec100_reset_array(7, 2) <> rst_zro_spn_coeff_array(3, 2))) Then
      
        prev_value_str = "H2O zro coef: " & H2O_zero_coeff 
        curr_value_str = "H2O zro coef: " & rst_zro_spn_coeff_array(3, 2) 
        message        = "Initl H2Ozro coef out of rng: Rest as " & rst_zro_spn_coeff_array(3, 2) & "."

      'Input of H2O_zero_coeff from Public or CR1000KD is out of range 
      ElseIf ((H2O_zero_coeff <> ec100_setting_array(7, 2)) AND (rst_zro_spn_coeff_array(3, 2) = ec100_setting_array(7, 2))) Then
      
        prev_value_str = "H2O zro coef: " & ec100_setting_array(7, 2)
        curr_value_str = "H2O zro coef: " & ec100_setting_array(7, 2)
        message        = "H2Ozro coef rest ignored, input out of rng: " & H2O_zero_coeff & "."
    
        H2O_zero_coeff       = rst_zro_spn_coeff_array(3, 2)
        rst_H2O_zro_coef_flg = FALSE 
        CallTable System_Operatn_Notes
  
      'Zero procedure failed: H2O_zero_coeff out of range 
      ElseIf ((ec100_reset_array(7, 2) <> ec100_setting_array(7, 2)) AND (ec100_reset_array(7, 2) = rst_zro_spn_coeff_array(3, 2))) Then
      
        prev_value_str = "H2O zro coef: " & H2O_zero_coeff 
        curr_value_str = "H2O zro coef: " & rst_zro_spn_coeff_array(3, 2) 
        message        = "H2Ozro failed: Rest coef bck to " & rst_zro_spn_coeff_array(3, 2) & "."
    
      EndIf '((ec100_reset_array(7, 2) = ec100_setting_array(7, 2)) AND...... 
    
    EndIf '((H2O_zero_coeff < 0.979) OR (H2O_zero_coeff > 1.020))
       
    'H2O_zero_coeff was inputted from Public or CR1000KD.  
    If ((H2O_zero_coeff >= 0.979) AND (H2O_zero_coeff <= 1.020) AND (H2O_zero_coeff <> ec100_setting_array(7, 2))) Then
    
      prev_value_str = "H2O zro coef: " & ec100_setting_array(7, 2)
      curr_value_str = "H2O zro coef: " & H2O_zero_coeff
      message        = "H2Ozro coef rest by user as " & H2O_zero_coeff & "."
      rst_zro_spn_coeff_array(3, 2) = H2O_zero_coeff
    
    EndIf 
  
    If (rst_H2O_zro_coef_flg) Then    
    
      Call Config (rst_zro_spn_coeff_array(3, 1), 1, rst_H2O_zro_coef_flg)
      config_type    = "Rest H2Ozro coef"
      config_status  = "Resetting"
   
      If (NOT rst_H2O_zro_coef_flg) Then 
        config_status  = "Reset"
        config_commend     = 16   
        get_ec100_config_f = TRUE 
              
      operatn_failed_cnt = 0            
      Else
        operatn_failed_cnt = operatn_failed_cnt + 1
        curr_value_str     = prev_value_str
                      
        Select Case operatn_failed_cnt
        
          Case 1, 2 
            message = "H2O zro coef rest #" & operatn_failed_cnt & " to retry."
          Case 3 
            rst_H2O_zro_coef_flg = FALSE
            message = "H2O zro coef rest #3 failed: aborted."
          
            H2O_zero_coeff                = ec100_setting_array(7, 2)
            ec100_reset_array(7, 2)       = H2O_zero_coeff
            rst_zro_spn_coeff_array(3, 2) = H2O_zero_coeff
          
          operatn_failed_cnt = 0    
          EndSelect 
  
      EndIf '(NOT rst_H2O_zro_coef_flg)
      CallTable System_Operatn_Notes
      NaN_cnt        = 0
      config_ec100_f = FALSE
    
    EndIf '(rst_H2O_zro_coef_flg)
    

  '** Reset H2O span coefficient 
  ElseIf (rst_H2O_spn_coef_flg AND (sonic_irga_raw(8) <> NaN)) Then
  
    If ((H2O_span_coeff < 0.940) OR (H2O_span_coeff > 1.057)) Then
  
      'Initial H2O_span_coeff in IRGA is out of range 
      If ((ec100_reset_array(8, 2) = ec100_setting_array(8, 2)) AND (ec100_reset_array(8, 2) <> rst_zro_spn_coeff_array(4, 2))) Then
      
        prev_value_str = "H2O spn coef: " & H2O_span_coeff 
        curr_value_str = "H2O spn coef: " & rst_zro_spn_coeff_array(4, 2) 
        message        = "Intal H2Ospn coef out of rng: Rest as " & rst_zro_spn_coeff_array(4, 2) & "."

      'Input of H2O_span_coeff from Public or CR1000KD is out of range 
      ElseIf ((H2O_span_coeff <> ec100_setting_array(8, 2)) AND (rst_zro_spn_coeff_array(4, 2) = ec100_setting_array(8, 2))) Then
      
        prev_value_str = "H2O spn coef: " & ec100_setting_array(8, 2)
        curr_value_str = "H2O spn coef: " & ec100_setting_array(8, 2)
        message        = "H2Ospn coef rest ignored, input out of rng: " & H2O_span_coeff & "."
    
        H2O_span_coeff       = rst_zro_spn_coeff_array(4, 2)
        rst_H2O_spn_coef_flg = FALSE 
        CallTable System_Operatn_Notes
  
      'H2O span procedure failed: H2O_span_coeff out of range 
      ElseIf ((ec100_reset_array(8, 2) <> ec100_setting_array(8, 2)) AND (ec100_reset_array(8, 2) = rst_zro_spn_coeff_array(4, 2))) Then
      
        prev_value_str = "H2O spn coef: " & H2O_span_coeff 
        curr_value_str = "H2O spn coef: " & rst_zro_spn_coeff_array(4, 2) 
        message        = "H2Ospn failed: Rest coef bck to " & rst_zro_spn_coeff_array(4, 2) & "."
    
      EndIf '((ec100_reset_array(8, 2) = ec100_setting_array(8, 2)) AND......
    
    EndIf '((H2O_span_coeff < 0.940) OR (H2O_span_coeff > 1.057))  
    
    'H2O_span_coeff was inputted from Public or CR1000KD.  
    If ((H2O_span_coeff >= 0.940) AND (H2O_span_coeff <= 1.067) AND (H2O_span_coeff <> ec100_setting_array(8, 2))) Then
    
      prev_value_str = "H2O spn coef: " & ec100_setting_array(8, 2)
      curr_value_str = "H2O spn coef: " & H2O_span_coeff 
      message        = "H2Ospn coef rest by user as " & H2O_span_coeff & "."
      rst_zro_spn_coeff_array(4, 2) = H2O_span_coeff
    
    EndIf 
      
    If (rst_H2O_spn_coef_flg) Then   

      Call Config (rst_zro_spn_coeff_array(4, 1), 1, rst_H2O_spn_coef_flg)
      config_type    = "Reset H2Ospn coef"
      config_status  = "Resetting"
   
      If (NOT rst_H2O_spn_coef_flg) Then
        config_status      = "Reset"
        config_commend     = 17    
        get_ec100_config_f = TRUE 
   
      operatn_failed_cnt = 0
      Else
        operatn_failed_cnt = operatn_failed_cnt + 1 
        curr_value_str     = prev_value_str
            
        Select Case operatn_failed_cnt
        
          Case 1, 2 
            message = "H2O spn coef rest #" & operatn_failed_cnt & " to retry."
          Case 3 
            rst_H2O_zro_coef_flg = FALSE
            message = "H2O spn coef rest #3 failed: aborted."
          
            H2O_span_coeff                = ec100_setting_array(8, 2)
            ec100_reset_array(8, 2)       = H2O_span_coeff
            rst_zro_spn_coeff_array(4, 2) = H2O_span_coeff
          
        operatn_failed_cnt = 0    
        EndSelect 

      EndIf '(NOT rst_H2O_spn_coef_flg)
      CallTable System_Operatn_Notes
      NaN_cnt        = 0
      config_ec100_f = FALSE
    
    EndIf '(rst_H2O_spn_coef_flg)  

    
  '** Switch heating options     
  ElseIf (set_heater_flg AND (sonic_irga_raw(8) <> NaN)) Then
    
     irga_pwr_array(2, 2) = heater_user 
     Call Config (irga_pwr_array(2, 1), 1, set_heater_flg)
     config_type   = "IRGA heating"
     config_status = "Swicthing"  
     
     Select Case ec100_reset_array (9, 2) 
       Case H_AUTO           
         prev_value_str = "Auto" 
       Case H_MAX  
         prev_value_str = "Max" 
       Case H_OFF    
         prev_value_str = "Off" 
     EndSelect 
    
     If (NOT set_heater_flg) Then 
        config_status      = "Swicthed" 
        config_commend     = 18
        get_ec100_config_f = TRUE 

        Select Case heater_user 
          Case H_AUTO           
            curr_value_str = "Auto" 
          Case H_MAX  
            curr_value_str = "Max" 
          Case H_OFF    
            curr_value_str = "Off" 
        EndSelect 
        message = "Heating optn switchd."
        
     operatn_failed_cnt = 0 
     Else
       operatn_failed_cnt = operatn_failed_cnt + 1 
       curr_value_str     = prev_value_str 

       Select Case operatn_failed_cnt 
      
         Case 1, 2
           message        = "Switch heating operatn #" & operatn_failed_cnt & " to retry." 
         Case 3
           set_heater_flg = FALSE
           message        = "Switch heating operatn #3 failed: aborted." 
         
       operatn_failed_cnt = 0          
       EndSelect 'operatn_failed_cnt
               
     EndIf '(NOT set_heater_flg)  
     CallTable System_Operatn_Notes
     NaN_cnt        = 0
     config_ec100_f = FALSE

 EndIf '(irga_pwr_switch_f)
 

 '* VERIFICATION AND ORGANIZATION AFTER CONFIGURING EC100, SWITCHING OPTIONS, AND RESETTING ZERO/SPAN COEFFICIENTS
 If (get_ec100_config_f AND (sonic_irga_raw(8) <> NaN)) Then 
  config_type    = "Config acqustn"
  config_status  = "Acquiring"
  curr_value_str = "Acquirng reconfgurtn" 
  Call Config (ec100_setting_array(1, 1), 11, get_ec100_config_f)          'Get EC100 configuration.

  Select Case config_commend
       
    Case 2  
    prev_value_str = "Swtch press optn"
    Case 14
    prev_value_str = "Rest CO2zro coef" 
    Case 15 
    prev_value_str = "Rest CO2spn coef"
    Case 16
    prev_value_str = "Rest H2Ozro coef"
    Case 17
    prev_value_str = "Rest H2Ospn coef"
    Case 18
    prev_value_str = "Swtch IRGA heatng"
    Case 21
    prev_value_str = "Swtch IRGA pwr"
    Case 25
    prev_value_str = "Swtch shdw crrctn" 
    Case 111
    prev_value_str = "CO2/H2O zro"
    Case 112
    prev_value_str = "CO2 spn"
    Case 113
    prev_value_str = "H2O spn"
    Case 1000  
    prev_value_str = "Reconfig EC100"
         
  EndSelect 'config_commend  
    
  If (operatn_failed_cnt > 0) Then    
  prev_value_str = curr_value_str
  EndIf 
          
  If (NOT get_ec100_config_f) Then
     config_status  = "Acquird"    
     message        = "EC100 reocnfgurtn Acqurd."
     CallTable System_Operatn_Notes
     
     config_status  = "Verifying" 
     prev_value_str = "Acquirng reconfgurtn"
     curr_value_str = "Verfctn"

     Select Case config_commend
       
       Case 2                                 'Switch press transducer option 
         press_source            = ec100_setting_array(2, 2)        'Make the user aware if not correctly switched.  
         ec100_reset_array(2, 2) = ec100_setting_array(2, 2)
         config_status           = "Verified" 
         message                 = "Press optn swtch: Verifd."
             
       Case 14                                'Reset CO2Zro coef
         CO2_zero_coeff          = ec100_setting_array(5, 2)         'Make the user aware if not correctly reset.  
         ec100_reset_array(5, 2) = ec100_setting_array(5, 2) 
         config_status           = "Verified" 
         message                 = "CO2zro coef rest: Verifd." 
          
       Case 15                                'Reset CO2Spn coef 
         CO2_span_coeff          = ec100_setting_array(6, 2)         'Make the user aware if not correctly reset.  
         ec100_reset_array(6, 2) = ec100_setting_array(6, 2)
         config_status           = "Verified" 
         message                 = "CO2spn coef rest: Verifd."  

       Case 16                                'Reset H2OZro coef
         H2O_zero_coeff          = ec100_setting_array(7, 2)         'Make the user aware if not correctly reset. 
         ec100_reset_array(7, 2) = ec100_setting_array(7, 2)
         config_status           = "Verified"  
         message                 = "H2Ozro coef rest: Verifd." 
      
       Case 17                                 'Reset H2OSpn coef
         H2O_span_coeff          = ec100_setting_array(8, 2)         'Make the user aware if not correctly reset.  
         ec100_reset_array(8, 2) = ec100_setting_array(8, 2) 
         config_status           = "Verified" 
         message                 = "H2Ospn coef rest: Verifd." 
         
       Case 18  
         heater_actual            = ec100_setting_array(9,  2)       'Make the user aware if not correctly switched.  
         heater_user              = heater_actual 
         ec100_reset_array(9,  2) = ec100_setting_array(9,  2) 
         config_status            = "Verified" 
         message                  = "Heater optn swtch: Verifd."

       Case 21                                 'Switch IRGA power
         heater_actual            = ec100_setting_array(9,  2)       'Make the user aware if not correctly switched.  
         ec100_reset_array(9,  2) = ec100_setting_array(9,  2) 
         irga_power               = ec100_setting_array(10, 2)       'Make the user aware if not correctly switched.  
         ec100_reset_array(10, 2) = ec100_setting_array(10, 2) 
         config_status            = "Verified" 
         message                  = "Pwr swtch: Verifd."
                
       Case 25                                 'Switch shdw crrctn
         shadow_corr              = ec100_setting_array(11, 2)       'Make the user aware if not correctly switched.  
         ec100_reset_array(11, 2) = ec100_setting_array(11, 2) 
         config_status            = "Verified" 
         message                  = "Shdw crrctn swtch: Verifd."   
            
       Case 111                                'CO2/H2O zero
         CO2_zero_coeff       = ec100_setting_array (5, 2)
         rst_CO2_zro_coef_flg = ((CO2_zero_coeff < 0.990) OR (CO2_zero_coeff > 1.011))   'Using data from 847 IRGASON and 427 EC150 CO2 zero coefficient mean +/- 10xSTD  
     
         If (rst_CO2_zro_coef_flg) Then
            config_status  = "Unsccssfl"
            message        = "CO2zro coef out of rng: To reset." 

         Else 
           config_status  = "Zeroed"
           message        = "CO2 Zro: Verifd." 
           rst_zro_spn_coeff_array (1, 2) = ec100_setting_array(5, 2)
           ec100_reset_array(5, 2)        = ec100_setting_array(5, 2)
            
         EndIf 
         CallTable System_Operatn_Notes        'Must be here 
         
         H2O_zero_coeff       = ec100_setting_array(7, 2)  
         rst_H2O_zro_coef_flg = ((H2O_zero_coeff < 0.979) OR (H2O_zero_coeff > 1.020))    'Using data from 847 IRGASON and 427 EC150 H2O zero coefficient mean +/- 10xSTD   

         If (rst_H2O_zro_coef_flg) Then 
           config_status  = "Unsccssfl"
           message        = "H2Ozro coef out of rng: To reset." 

         Else 
           config_status = "Zeroed"
           message       = "H2O Zro: Verifd." 
           rst_zro_spn_coeff_array (3, 2) = ec100_setting_array(7, 2)
           ec100_reset_array(7, 2)        = ec100_setting_array(7, 2) 

         EndIf      
          
       Case 112                                'CO2 span
         CO2_span_coeff       = ec100_setting_array(6, 2)  
         rst_CO2_spn_coef_flg = ((CO2_span_coeff < 0.962) OR (CO2_span_coeff > 1.039))     'Using data from 847 IRGASON and 427 EC150 CO2 span coefficient mean +/- 5xSTD   

         If (rst_CO2_spn_coef_flg) Then 
           config_status  = "Unsccssfl"
           message        = "CO2spn coef out of rng: To reset." 

         Else 
           config_status = "Spanned"
           message       = "CO2 spn: Verifd." 
           rst_zro_spn_coeff_array (2, 2) = ec100_setting_array(6, 2) 
           ec100_reset_array(6, 2)        = ec100_setting_array(6, 2) 
           
         EndIf      
        
       Case 113                                'H2O span
         H2O_span_coeff       = ec100_setting_array(8, 2)   
         rst_H2O_spn_coef_flg = ((H2O_span_coeff < 0.940) OR (H2O_span_coeff > 1.057))      'Using data from 847 IRGASON and 427 EC150 H2O span coefficient mean +/- 5xSTD   

         If (rst_H2O_spn_coef_flg) Then 
           config_status  = "Unsccssfl"
           message        = "H2Ospn coef out of rng: To reset." 

         Else 
           config_status = "Spanned"
           message       = "H2O spn: Verifd." 
           rst_zro_spn_coeff_array (4, 2) = ec100_setting_array(8, 2)
           ec100_reset_array(8, 2)        = ec100_setting_array(8, 2) 

         EndIf  

       Case 1000                               'Reset all configuration
         config_status = " Resetting"
         message       = "Configrtn reset: Verifd."          

         'Update reset array
         For i = 1 To 11
         ec100_reset_array(i, 2) = ec100_setting_array(i, 2)
         Next
         
         '** For view by the user through the public table, update public variables for IRGA and CSAT configurations,  
         '   which makes sure that the user is aware if not right. 
         press_source = ec100_setting_array(2,  2)          '  'Barometer  
         
         For i = 1 To 4                                                 'CO2/H2O zero/span coefficient array.
         zro_spn_coef_array (i)       = ec100_setting_array(4 + i,  2)
         rst_zro_spn_coeff_array(i, 2) = zro_spn_coef_array (i) 
         Next i
         
         heater_actual = ec100_setting_array(9, 2)                      'IRGA heater option 
         irga_power    = ec100_setting_array(10, 2)                     'IRGA power option    
         shadow_corr   = ec100_setting_array(11, 2)                     'Shadow correction 

     EndSelect 'config_commend 
     CallTable Config_Setting_Notes       
       
  operatn_failed_cnt = 0
  Else      
    operatn_failed_cnt = operatn_failed_cnt + 1 

    message = "Verification failed: #" & operatn_failed_cnt & "." 

  EndIf '(NOT get_ec100_config_f)
  CallTable System_Operatn_Notes
  NaN_cnt        = 0
  config_ec100_f = FALSE 
   
EndIf '(get_ec100_config_f and (sonic_irga_raw(8) <> NaN)) 
EndSelect 'config_ec100_initial_f


'*** Power Voltage Monitoring      
 'Set up diagnosis bit for IRGA power control  
 diag_irga_tmp = IIF ((sonic_irga_raw(8) <> NaN) AND (sonic_irga_raw(8) <> -1), sonic_irga_raw(8), &h4ffefb)
 irga_startup_bit   = diag_irga_tmp AND &h000004
 irga_off_bit       = diag_irga_tmp AND &h000100
 irga_actual_pwr_on = (irga_off_bit  =  &h000000)

 'Keep irga_off_bit right while IRGA off due to lower voltage        
 If (NOT ((sonic_irga_raw(8) <> NaN) AND (sonic_irga_raw(8) <> -1))) Then 
    If (irga_vlt_low_auto_off) Then         'In this case, irga_off_bit is not correctly reported on time
    irga_off_bit       = &h000100           'Force it as it should be
    irga_actual_pwr_on = FALSE
    EndIf  
EndIf

'******************** END of CSI IRGA + CSAT MEASUREMENTS *****************


'******               MEASUREMENTS FOR PULSE SENSORS                  *****
'PulsCount Instructions are placed here after all fast sensors finish their measurements because PulseCount() is not allowed in any conditional statements.
 #If (SENSOR_CNR4 AND SENSOR_CNF4) Then   
 '*** CNF4 tachometer measurements
 PulseCount (cnr4_fan_freq, 1, CNF4_TACHMTR_INPUT, 3, 1, 1, 0)
 #EndIf

 #If (SENSOR_TE525) Then   
 '*** Precipitation measurements 
 PulseCount (P, 1, TE525_PULSE_INPUT, 1, 0, TE525_MULT, 0)
 P_cumul_win_interval += P                            'Use to indicate the rain within current interval to judge poor_energy_closure_flg 
 #EndIf

'**************** END OF MEASUREMENTS FOR PULSE SENSORS  ******************


'*****                     3D WIND PROCESSING                        ***** 
If (scan_count >= (OFFSET + MAX_LAG)) Then

 'Load in CSAT sonic head data that has been lagged by EC100_REC_BCK scans
  GetRecord (dly_data_out(1),delay_3d, EC100_REC_BCK)

  Ts = dly_data_out(4)                                              'sonic(1): Ts
  Ts_K = Ts + T_0C_K
  Move (Ux, 3, dly_data_out(1), 3)                                  'sonic(2), sonic(3), sonic(4) : Ux, Uy, Uz
  diag_sonic = dly_data_out(5)                                      'sonic(5): diag_sonic
  sonic_disable_f = (diag_sonic <> 0)                               'Turn on the intermediate processing disable flag when any CSAT sonic head warning flag is high.
      
  U_rslt = SQR(Ux*Ux + Uy*Uy + Uz*Uz)
  #If (CSAT3A_EC150) Then
  #If (CSAT_TYP_3AH) Then 
  'Calculation for heating control  
  AvgRun (U_total_rung_mean, 1, U_rslt, (SLW_SCN_INTV/SCN_INTV))    'Running average of press           
  #EndIf
  #EndIf '(CSAT3A_EC150)

 'Extract the six warning flags from the sonic diagnostic word
  diag_sonic_tmp = IIF ((diag_sonic <> NAN) AND (diag_sonic <> -1), diag_sonic, &h3f)
  diag_sonic_aggregate = diag_sonic_aggregate OR diag_sonic_tmp  
  mask = &h1
  For i = 1 To 6
    diag_bits_sonic(i) = diag_sonic_tmp AND mask
    mask = mask*2
  Next i


 'Call Table for 5-minute and 30-minute table
  CallTable comp_cov_3d_5min                                              'for Steady State Test
  CallTable comp_cov_3d                                                   'for half-hourly data

  '***** The data for Steady State Test (SST)
  If (comp_cov_3d_5min.Output(1, 1)) Then
    GetRecord (Ux_Avg_SST, comp_cov_3d_5min, 1)

    If (NOT Planar_Fit_flg) Then
     'Double coordinate rotations
     gamma_5min = WD_SONIC_SST                                                          'Rotation angle about z-axis
     alpha_5min = -ATN2(Uz_Avg_SST, SQR(Ux_Avg_SST*Ux_Avg_SST + Uy_Avg_SST*Uy_Avg_SST)) 'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

     ' Rotation for momentum variables
     Call Rotation12_Momentum(alpha_5min, gamma_5min, _
     Ux_Avg_SST, Uy_Avg_SST, Uz_Avg_SST, Ux_Var_SST, Uy_Var_SST, Uz_Var_SST, UxUy_Cov_SST, UxUz_Cov_SST, UyUz_Cov_SST, _
     U_SST,      V_SST,      W_SST,      U_Var_SST,  V_Var_SST,  W_Var_SST,  UV_Cov_SST,   UW_Cov_SST,   VW_Cov_SST)
     'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W

     'Rotation for the covariance of sonic temperature with velocities
      Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
      TsUx_Cov_SST,     TsUy_Cov_SST,     TsUz_Cov_SST, _
      UT_SONIC_Cov_SST, VT_SONIC_Cov_SST, WT_SONIC_Cov_SST)
     'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC 

     Else
      'Planar Fit Rotation
       If (WD_SONIC_SST <= 60)      Then
        alpha_5min = alpha_PF_60_300
        beta_5min  = beta_PF_60_300
       ElseIf (WD_SONIC_SST <= 170) Then
        alpha_5min = alpha_PF_60_170
        beta_5min  = beta_PF_60_170
       ElseIf (WD_SONIC_SST <= 190)  Then
        alpha_5min = alpha_PF_170_190
        beta_5min  = beta_PF_170_190
       ElseIf (WD_SONIC_SST <= 300)  Then
        alpha_5min = alpha_PF_190_300
        beta_5min  = beta_PF_190_300
       Else
        alpha_5min = alpha_PF_60_300
         beta_5min  = beta_PF_60_300
       EndIf

      ' Rotations for momentum variables
       Call Rotation23_Momentum(alpha_5min, beta_5min, _
       Ux_Avg_SST, Uy_Avg_SST, Uz_Avg_SST, Ux_Var_SST, Uy_Var_SST, Uz_Var_SST, UxUy_Cov_SST, UxUz_Cov_SST, UyUz_Cov_SST, _
       U_SST,      V_SST,      W_SST,      U_Var_SST,  V_Var_SST,  W_Var_SST,  UV_Cov_SST,   UW_Cov_SST,   VW_Cov_SST)
      'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
                      
      'Rotations for the covariance of sonic temperature with velocities
       Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
       TsUx_Cov_SST,     TsUy_Cov_SST,     TsUz_Cov_SST, _
       UT_SONIC_Cov_SST, VT_SONIC_Cov_SST, WT_SONIC_Cov_SST)
       'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC 
       EndIf '(NOT Planar_Fit_flg)

       If ((UW_Cov_SST <> NaN) AND (VW_Cov_SST <> NaN) AND (WT_SONIC_Cov_SST <> NaN)) Then
         RN_UW_cov       += UW_Cov_SST
         RN_VW_cov       += VW_Cov_SST
         RN_WT_SONIC_cov += WT_SONIC_Cov_SST

         nmbr_interval_qc_csat += 1
       EndIf

 EndIf '(comp_cov_3d_5min.Output(1, 1))

'***** Processing hourly data 
 If (comp_cov_3d.Output(1, 1) AND comp_cov_3d_5min.Output(1, 1))Then
   GetRecord (Ux_Avg, comp_cov_3d, 1)                                     'Ux_avg is the 1st element of cov_out_sonic
   T_SONIC       = Ts_Avg                                                 'For output in AmeriFlux format 
   Ts_SIGMA      = SQR(Ts_SIGMA)
   T_SONIC_SIGMA = Ts_SIGMA        

  '*** Coordinate rotations
  If (NOT Planar_Fit_flg) Then
    'Double coordinate rotations
    gamma = WD_SONIC                                                      'Rotation angle about z-axis
    alpha = -ATN2(Uz_Avg, SQR(Ux_Avg*Ux_Avg + Uy_Avg*Uy_Avg))             'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

    'Rotation for momentum variables
     Call Rotation12_Momentum(alpha, gamma, _
     Ux_Avg, Uy_Avg, Uz_Avg, Ux_SIGMA, Uy_SIGMA, Uz_SIGMA, UxUy_Cov, UxUz_Cov, UyUz_Cov, _
     U,      V,      W,      U_SIGMA,  V_SIGMA,  W_SIGMA,  UV_Cov,   UW_Cov,   VW_Cov)
    'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W.

    'Rotation for the covariance of sonic temperature with velocities
     Call Rotation12_Scalar_Covariance(alpha, gamma, _
     TsUx_Cov,     TsUy_Cov,     TsUz_Cov, _
     UT_SONIC_Cov, VT_SONIC_Cov, WT_SONIC_Cov)
     'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC
  Else
    'Planar Fit Rotation
    If (WD_SONIC <= 60.0)      Then
      alpha = alpha_PF_60_300
      beta  = beta_PF_60_300
    ElseIf (WD_SONIC <= 170.0) Then
      alpha = alpha_PF_60_170
      beta  = beta_PF_60_170
    ElseIf (WD_SONIC < 190.0)  Then
      alpha = alpha_PF_170_190
      beta  = beta_PF_170_190
    ElseIf (WD_SONIC < 300.0)  Then
      alpha = alpha_PF_190_300
      beta  = beta_PF_190_300
    Else
      alpha = alpha_PF_60_300
      beta  = beta_PF_60_300
    EndIf '(WD_SONIC <= 60.0)  

    'Rotations for momentum variables
    Call Rotation23_Momentum(alpha, beta, _
    Ux_Avg, Uy_Avg, Uz_Avg, Ux_SIGMA, Uy_SIGMA, Uz_SIGMA, UxUy_Cov, UxUz_Cov, UyUz_Cov, _
    U,      V,      W,      U_SIGMA,  V_SIGMA,  W_SIGMA,  UV_Cov,   UW_Cov,   VW_Cov)
    'After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W.
          
    'Rotations for the covariance of sonic temperature with velocities
     Call Rotation23_Scalar_Covariance(alpha, beta, _
     TsUx_Cov,     TsUy_Cov,     TsUz_Cov, _
     UT_SONIC_Cov, VT_SONIC_Cov, WT_SONIC_Cov)
    'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC
  EndIf '(NOT Planar_Fit_flg)
        
  'After coordinate rotation, variables ending with _SIGMA are actually variances but later the square root will be taken to give standard deviation.
  Ux_SIGMA = SQR(Ux_SIGMA)
  Uy_SIGMA = SQR(Uy_SIGMA)
  Uz_SIGMA = SQR(Uz_SIGMA)
        
  '*** Transform the wind direction of WD_SONIC measured from CSAT RHC system into compass convention
  WD = (sonic_azimuth - WD_SONIC + 360) MOD 360

  'Compute specific turbulence kinetic energy
  TKE = 0.5*(U_SIGMA + V_SIGMA + W_SIGMA)

  'Compute the standard deviation from the variance after rotation
  U_SIGMA = SQR (U_SIGMA)
  V_SIGMA = SQR (V_SIGMA)
  W_SIGMA = SQR (W_SIGMA)

  '*** Freq corrections for UW_Cov, VW_Cov, and WT_SONIC_Cov ***
  'Compute online fluxes after rotations (preliminary).
  USTAR_R =  SQR(SQR((UW_Cov*UW_Cov) + (VW_Cov*VW_Cov)))

  'Preparation for freq correction to UW_Cov, VW_Cov, and WT_SONIC_cov
  'Monin-Obukhov length (preliminary)
  MO_LENGTH = -USTAR_R*USTAR_R*USTAR_R*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov)

  'Atmospheric boundary-layer stability (preliminary)
   ZL = z/MO_LENGTH

   FreqFactor_UW_VW_Prev = 1 - 2*ACCURACY_FREQ_FACTOR
   Call  FreqFactorCSAT_uw_vw_BA_LA(z, ZL, WS_RSLT, FreqFactor_UW_VW)

   UW_Cov_fc = FreqFactor_UW_VW * UW_Cov
   VW_Cov_fc = FreqFactor_UW_VW * VW_Cov
   USTAR = SQR(SQR ((UW_Cov_fc*UW_Cov_fc) + (VW_Cov_fc*VW_Cov_fc)))
        
   FreqFactor_WT_SONIC_Prev = 1 - 2*ACCURACY_FREQ_FACTOR
   Call  FreqFactorCSAT_wTs_BA_LA (z, ZL, WS_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactor_WT_SONIC)

   WT_SONIC_Cov_fc = FreqFactor_WT_SONIC * WT_SONIC_Cov

   'Recalculate Monin-Obukhov length
    MO_LENGTH = -USTAR*USTAR*USTAR*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov_fc)

   'Recalculate atmospheric boundary-layer stability
    ZL_prev = ZL
    ZL      = z/MO_LENGTH

    iteration_FreqFactor = 1
    While (((ABS (FreqFactor_UW_VW_Prev -FreqFactor_UW_VW) >= ACCURACY_FREQ_FACTOR) OR _
          (ABS (FreqFactor_WT_SONIC_Prev - FreqFactor_WT_SONIC) >= ACCURACY_FREQ_FACTOR)) AND (iteration_FreqFactor <= 10))

       ZL_prev                  = ZL
       FreqFactor_UW_VW_Prev    = FreqFactor_UW_VW
       FreqFactor_WT_SONIC_Prev = FreqFactor_WT_SONIC

       Call  FreqFactorCSAT_uw_vw_BA_LA (z, ZL, WS_RSLT, FreqFactor_UW_VW)
       UW_Cov_fc = FreqFactor_UW_VW * UW_Cov
       VW_Cov_fc = FreqFactor_UW_VW * VW_Cov
       USTAR = SQR(SQR (UW_Cov_fc*UW_Cov_fc + VW_Cov_fc*VW_Cov_fc))

       Call  FreqFactorCSAT_wTs_BA_LA (z, ZL, WS_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactor_WT_SONIC)
       WT_SONIC_Cov_fc = FreqFactor_WT_SONIC * WT_SONIC_Cov

       'Monin-Obukhov length
       MO_LENGTH = -USTAR*USTAR*USTAR*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov_fc)

       'Atmospheric boundary-layer stability
       ZL = z/MO_LENGTH

       iteration_FreqFactor += 1
     Wend

 '*** Beginning of data quality classification for momentum flux
   'Calculate the measures of relative non-stationarity (Steady State Test)
    RN_UW_VW_cov = ABS(((RN_UW_cov + RN_VW_cov)/nmbr_interval_qc_csat - UW_Cov - VW_Cov)/(UW_Cov + VW_Cov))  'in fraction
    RN_UW_cov = 0
    RN_VW_cov = 0
        
    Call Data_Quality_SSITC_w_WndDir_Momentum  (Planar_Fit_flg, ZL, U_SIGMA, W_SIGMA, USTAR, latitude, WD_SONIC, RN_UW_VW_cov, TAU_QC)
    Call Data_Quality_SSITC_wo_WndDir_Momentum (Planar_Fit_flg, ZL, U_SIGMA, W_SIGMA, USTAR, latitude,           RN_UW_VW_cov, TAU_SSITC_TEST)

 '*** Footprint characteristics of measured fluxes
   'Update roughness length when a user does not specify z0 and wind is sufficiently strong during a neutral condition
   If ((ABS(ZL) < 0.02) AND (roughness_user = 0) AND (WS_RSLT > 3.0) AND (TAU_QC <= 6.0)) Then z0 = z*EXP(-k*WS_RSLT/USTAR)

   'Determining upwind distance of interest
   If (WD_SONIC <= 60.0) Then
     UPWND_DIST_INTRST = dist_intrst_60_300
   ElseIf (WD_SONIC <= 170.0) Then
     UPWND_DIST_INTRST = dist_intrst_60_170
   ElseIf (WD_SONIC < 190.0)  Then
     UPWND_DIST_INTRST = dist_intrst_170_190
   ElseIf (WD_SONIC < 300.0)  Then
     UPWND_DIST_INTRST = dist_intrst_190_300
   Else
     UPWND_DIST_INTRST = dist_intrst_60_300
   EndIf '(WD_SONIC <= 60.0)
        
   'Calculate planetary boundary layer height
    Call Planetary_Boundary_Layer_Height(MO_LENGTH, PBLH)

   'Footprint selection
    If ((ZL >= -200.0) AND (ZL <= 1.0) AND (USTAR >= 0.2) AND (z >= 1.0)) Then  'See section 6 on page 518 (Kljun et al. 2004) 
      'Kljun et al (2004)
       FP_EQUATION = "Kljun et al"
      'Calculate footprint characteristics
       Call FootprintCharacteristics_Kljun(USTAR, W_SIGMA, z, MO_LENGTH, z0, UPWND_DIST_INTRST, FP_DIST_INTRST, FETCH_MAX, FETCH_90, FETCH_55, FETCH_40)
     Else
      'Kormann and Meixner (2001)
       FP_EQUATION = "KormannMeixner"
      'Calculate footprint characteristics
       Call FootprintCharacteristics_KormannMeixner(USTAR, z, ZL, WS_RSLT, UPWND_DIST_INTRST, FP_DIST_INTRST, FETCH_MAX, FETCH_90, FETCH_55, FETCH_40)
     EndIf
EndIf '(comp_cov_3d.Output(1, 1) AND comp_cov_3d_5min.Output(1, 1))
'************************ End of 3D wind processing  *********************


'*****                    IRGA data processing                       *****
'Load in the IRGA data that has been lagged by EC100_REC_BCK scans.
 mask = &h1
 For i = MAX_LAG To - MAX_LAG Step -1
   array_index = MAX_LAG + 1 - i                                 'Convert i = MAX_LAG, ..., 1, 0, -1, ..., MAX_LAG to array_index = 1, 2, 3,..., 2*MAX_LAG +1

   GetRecord (dly_data_out(1), delay_cs, (EC100_REC_BCK + i))
   If (i = 0) Then
     Move (CO2_density, 7, dly_data_out(1), 7)                   'CO2_density, H2O_density, diag_irga, T_amb, press_amb, CO2_sig_strgth, and H2O_sig_strgth
     
     Select Case CO2_fast_tmpr 
       Case True 
         CO2_density_fast_tmpr = CO2_density
         CO2_density_slow_tmpr = dly_data_out(8)
               
       Case FALSE  
         CO2_density_fast_tmpr = dly_data_out(8)
         CO2_density_slow_tmpr = CO2_density
    EndSelect 
   EndIf

   'Extract the diagnostic word from each record of lagged data, used to exclude data from covariance calculation in Tables: comp_cov_CO2, comp_cov_H2O, and comp_cov_cs_5min.
   diag_irga_tmp = IIF ((dly_data_out(3) <> NAN) AND (dly_data_out(3) <> -1),dly_data_out(3), &h3fffff)
   irga_bad_data_flg_array(array_index) = mask AND diag_irga_tmp
        
   If (NOT sonic_disable_f) AND (NOT irga_bad_data_flg_array(array_index)) Then
     T_tmp= (2*Ts_K*dly_data_out(5))/(dly_data_out(5) + SQR(dly_data_out(5)*(dly_data_out(5) +1.28*Rv*dly_data_out(2)*Ts_K))) 'See "An approach of total differential to derivation for the correction equation of air temperature flux from sonic temperature flux", equation 28, v2 (Aug 3, 2015) by Zhou et al.(unpublished)
        
   ElseIf (irga_bad_data_flg_array(array_index) AND (NOT (diag_irga_tmp AND &H400)))  '&H400 for amb_temp flag 
     T_tmp = dly_data_out(4) + T_0C_K
               
   ElseIf (irga_bad_data_flg_array(array_index) AND (diag_irga_tmp AND &H400))         '&H400 for amb_temp flag 
     T_tmp = NaN
  
   ElseIf (sonic_disable_f) AND (NOT irga_bad_data_flg_array(array_index))
     T_tmp = dly_data_out(4) + T_0C_K
        
   EndIf          
         
  'Compute the molar number of dry air in m^3 
  divisor = (dly_data_out(5)/(R*T_tmp))-(dly_data_out(2)/18.01528)

 'Load the arrays that hold the input data for the covariance instructions.
  Move (cov_array_CO2(array_index, 1), 1, dly_data_out(1),1)                           'CO2_density in mg m-3
  Move (cov_array_CO2(array_index, 2), 3, Ux, 3)
  CO2_bad_rng_sig_array (array_index) = ((dly_data_out(6) < CO2_SIG_STRGTH_THRESHOLD) OR (dly_data_out(1) <0) OR (dly_data_out(1) > CO2_RNG_TOP_LIMIT))
  cov_array_CO2(array_index, 5)       = dly_data_out(1)/(0.04401*divisor)              'CO2 in umol mol-1 (See http://www.carbontracker.eu/glossary.html) 

  Move (cov_array_H2O(array_index, 1), 1, dly_data_out(2),1)                           'H2O_density in g m-3  
  Move (cov_array_H2O(array_index, 2), 3, Ux, 3)
  H2O_bad_rng_sig_array (array_index) = ((dly_data_out(7) < H2O_SIG_STRGTH_THRESHOLD) OR (dly_data_out(2) <0) OR (dly_data_out(2) > H2O_RNG_TOP_LIMIT))
  cov_array_H2O(array_index, 5)       = dly_data_out(2)/(0.01801582*divisor)           'H2O in mmol mol-1 (See http://www.carbontracker.eu/glossary.html) 
       
 Next i

  'Call tables for lag maximization
   CallTable comp_cov_CO2
   CallTable comp_cov_H2O

   'Extract the twenty two flags from the IRGA diagnostic word
    diag_irga_tmp = IIF ((diag_irga <> NAN) AND (diag_irga <> -1),diag_irga, &h3fffff)
    diag_irga_aggregate = diag_irga_aggregate OR diag_irga_tmp
      
    For i = 1 To 22
      diag_bits_irga(i) = diag_irga_tmp AND mask
      mask = mask*2
    Next i

    'Filter data in the covariance instruction if the IRGA reports bad data.
     irga_disable_f = irga_bad_data_f

     'Call table for data used for data quality grading
     CallTable comp_cov_cs_5min
      
 '***** Water vapor pressure, dry air density, moist air density, saturate water pressure, RH and dew point temperature  

    'Using 107 temperature, H2O, and pressure 
    'water vapor pressure, dry air density, and moist air density 
     e_amb     = H2O_density*Rv*(T_amb + T_0C_K )                         'Ideal gas equation (kPa)
     rho_d_amb = (press_amb - e_amb)/((T_amb + T_0C_K)*Rd)                'g/m^3
     rho_a_amb = (rho_d_amb + H2O_density)/1000.0                         'kg/m^3

     'Saturation water pressure at current temperature
     Enhance_Factor1 = 1.00041 + press_amb*(3.48e-5 + 7.4e-9*(T_amb + 30.6 - 0.38*press_amb)^2.0) 'Eq. 6 from Appendix A of flux program manual

     Select Case T_amb                                                   'Eq. 5 from Appendix A of flux program manual
      Case Is >= 0.0
        e_sat_amb = 0.61121*Enhance_Factor1*EXP((17.368*T_amb)/(T_amb + 238.88))
      Case Is < 0.0
        e_sat_amb = 0.61121*Enhance_Factor1*EXP((17.966*T_amb)/(T_amb + 247.15))
     EndSelect

    'Relative humidity
     RH_amb = 100.0 * e_amb/e_sat_amb
      
    'Dew point temperature for general use for accurately computing the final dew point temperature
     Enhance_Factor2 = 1.00072 + 3.46e-5*press_amb                        'Eq. 9 from Appendix A of flux program manual
     x_tmp           = LN(e_amb/(0.61121*Enhance_Factor2))                'For dew point temperature, assume that e is saturation water vapor pressure
     Td_gp           = 240.97*x_tmp/(17.502-x_tmp)

     'Accurate dew point temperature
     Enhance_Factor1 = 1.00041 + press_amb*(3.48e-5 + 7.4e-9*(Td_gp + 30.6 - 0.38*press_amb)^2.0)    'Eq. 6 from Appendix A of flux program manual
     x_tmp           = LN(e_amb/(0.61121*Enhance_Factor1))                'For dew point temperature, assume that e is saturation water vapor pressure

      Select Case Td_gp                                                   'Eq. 11 from Appendix A of flux program manual
      Case Is >= 0.0
        T_DP_amb = 238.88*x_tmp/(17.368 - x_tmp)
      Case Is < 0.0
        T_DP_amb = 247.15*x_tmp/(17.966 - x_tmp)
      EndSelect

     'Compute fast response air temperature from sonic temperature, IRGASON vapor density, and atmospheric pressure.
      If (Ts_K <> NaN) Then
        Tc_K = Tc_function (Ts_K, H2O_density, press_amb) 
        'Compute fast response air temperature from sonic temperature and IRGASON vapor density.
        'x_tmp = SQR(((1-epsilon)*Rd*H2O_density*Ts_K + epsilon*press_amb)^2.0 - 4*epsilon*(1-1.511494*epsilon)*Rd*H2O_density*press_amb*Ts_K)  
        'Tc_K  = ((1.0 - epsilon)*Rd*H2O_density*Ts_K + epsilon*press_amb - x_tmp)/(2.0*(1.0 - 1.511494*epsilon)*Rd*H2O_density)   'Eq 21 from "Derivation and application of air temperature equation from collocated and synchronously measured sonic temperature and water vapor density", Zhou and Campbell, 2014 (unpublished)
      Else
        Tc_K = NaN                                                        'Tc_K in K
      EndIf
       
      'Calculate water vapor pressure using sonic and IRGA measurements
      e     = H2O_density*Rv*Tc_K                                         'Ideal gas equation (kPa)
      rho_d = (press_amb - e)/(Tc_K*Rd)                                   'g/m^3
      rho_a = (rho_d + H2O_density)/1000                                  'kg/m^3
    
      'Convert Tc in K to Tc in C
      Tc = Tc_K - T_0C_K                                                  'Tc in C
      
      'Saturation water pressure at current temperature
      Enhance_Factor1 = 1.00041 + press_amb*(3.48e-5 + 7.4e-9*(Tc + 30.6 - 0.38*press_amb)^2.0) 'Eq. 6 from Appendix A of flux program manual

      Select Case Tc                                                      'Eq. 5 from Appendix A of flux program manual
      Case Is >= 0
        e_sat = 0.61121*Enhance_Factor1*EXP((17.368*Tc)/(Tc + 238.88))
      Case Is < 0
        e_sat = 0.61121*Enhance_Factor1*EXP((17.966*Tc)/(Tc + 247.15))
      EndSelect

      'Relative humidity
      RH = 100.0 * e/e_sat
      
      'Dew point temperature for general use for accurately computing the final dew point temperature
      Enhance_Factor2 = 1.00072 + 3.46e-5*press_amb                       'Eq. 9 from Appendix A of flux program manual
      x_tmp           = LN(e/(0.61121*Enhance_Factor2))                   'For dew point temperature, assume that e is saturation water vapor pressure
      Td_gp           = 240.97*x_tmp/(17.502-x_tmp)

      'Accurate dew point temperature
      Enhance_Factor1 = 1.00041 + press_amb*(3.48e-5 + 7.4e-9*(Td_gp + 30.6 - 0.38*press_amb)^2.0) 'Eq. 6 from Appendix A of flux program manual
      x_tmp           = LN(e/(0.61121*Enhance_Factor1))                   'For dew point temperature, assume that e is saturation water vapor pressure

      Select Case Td_gp                                                   'Eq. 11 from Appendix A of flux program manual
       Case Is >= 0
        T_DP = 238.88*x_tmp/(17.368 - x_tmp)
       Case Is < 0
        T_DP = 247.15*x_tmp/(17.966 - x_tmp)
      EndSelect

      'Compute the molar mixing ratio of CO2 and H2O.
      divisor = (press_amb/(R*Tc_K))-(H2O_density/18.01528)
      CO2_mixratio = CO2_density/(0.04401*divisor)
      H2O_mixratio = H2O_density/(0.01802*divisor)
      
      divisor = (press_amb/(R*(T_amb + T_0C_K)))-(H2O_density/18.01528)   'For CR1000KD display
      CO2_mixratio_kd = CO2_density/(0.04401*divisor)
      H2O_mixratio_kd = H2O_density/(0.01802*divisor)

      CallTable comp_mean                                                 'Calculate the means of air temperature, relative humidity, dew point temperature, and pressure              

     #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
      '* Temperature and RH probe data processing 
       #If (SENSOR_T_RH) Then       
       Call H2O_vapor_dewpoint (T_probe, RH_probe, press_amb, e_sat_probe, e_probe, T_DP_Probe, H2O_density_probe, rho_d_probe) 
       #EndIf 
       CallTable stats_tmpr_rh
     #EndIf '(SENSOR_T_RH OR SENSOR_HYGRO)    


'***** Processing data quality grading 
 If (comp_cov_cs_5min.Output(1, 1)) Then
   GetRecord (CO2_density_var_SST, comp_cov_cs_5min, 1)

   If (NOT Planar_Fit_flg) Then
    'Rotation for the covariance of CO2 with velocities
     Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
     UxCO2_Cov_SST, UyCO2_Cov_SST, UzCO2_Cov_SST, _
     UCO2_Cov_SST,  VCO2_Cov_SST,  WCO2_Cov_SST)
     'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
          
    'Rotation for the covariance of H2O with velocities
     Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
     UxH2O_Cov_SST, UyH2O_Cov_SST, UzH2O_Cov_SST, _
     UH2O_Cov_SST,  VH2O_Cov_SST,  WH2O_Cov_SST)
     'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
   Else
    'Rotations for the covariance of CO2 with velocities
     Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
     UxCO2_Cov_SST, UyCO2_Cov_SST, UzCO2_Cov_SST, _
     UCO2_Cov_SST,  VCO2_Cov_SST,  WCO2_Cov_SST)
     'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
          
     'Rotations for the covariance of H2O with velocities
      Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
      UxH2O_Cov_SST, UyH2O_Cov_SST, UzH2O_Cov_SST, _
      UH2O_Cov_SST,  VH2O_Cov_SST,  WH2O_Cov_SST)
      'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W 
    EndIf '(NOT Planar_Fit_flg) 

    If ((WCO2_Cov_SST <> NaN) AND (WH2O_Cov_SST <> NaN)) Then
      RN_WCO2_Cov += WCO2_Cov_SST
      RN_WH2O_Cov += WH2O_Cov_SST
      nmbr_interval_qc_irga += 1
    EndIf

 EndIf '(comp_cov_cs_5min.Output(1, 1))


'***** Processing hourly data 
 If (comp_cov_CO2.Output(1,1) AND comp_cov_H2O.Output(1,1) AND comp_mean.Output(1,1) AND comp_cov_cs_5min.Output(1, 1))  Then
   GetRecord (CO2_Avg_lag_b5, comp_cov_CO2, 1)
   GetRecord (H2O_Avg_lag_b5, comp_cov_H2O, 1)
   GetRecord (TA_1_1_1,       comp_mean,    1)

   VPD = 10.0*(e_sat_Avg - e_Avg)                                         'Water vapor pressure deficit in hPa. "10" is used to convert unit of kPa to hPa

   #If (SENSOR_T_RH OR SENSOR_HYGRO) Then
   '*** Processing temperature and RH probe data
   If (stats_tmpr_rh.Output(1,1)) Then
     GetRecord (TA_1_1_3, stats_tmpr_rh, 1)
     rho_a_probe_Avg = (rho_d_probe_Avg + H2O_density_probe_Avg)/1000.0     'kg/m^3
   EndIf
   #EndIf 


   'Rotate CO2-related covariance
   WCO2_Cov_major_sign = 0.0                                              'Variable indicating the major direction (sign) of CO2 flux

   For i = 1 To (2* MAX_LAG + 1)
     array_index = 7*(i-1) + 5
     If (NOT Planar_Fit_flg) Then
       'Double rotations
       'Rotation for the covariance of CO2 with velocities
        Call Rotation12_Scalar_Covariance(alpha, gamma, _
        Cov_out_CO2(array_index), Cov_out_CO2(array_index + 1), Cov_out_CO2(array_index + 2), _
        UCO2_VCO2_Cov_lag(i, 1),  UCO2_VCO2_Cov_lag(i, 2),      WCO2_Cov_lag (i))
        'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
     Else
       'Planar Fit rotations
       'Rotation for the covariance of CO2 with velocities
        Call Rotation23_Scalar_Covariance(alpha, beta, _
        Cov_out_CO2(array_index), Cov_out_CO2(array_index + 1), Cov_out_CO2(array_index + 2), _
        UCO2_VCO2_Cov_lag(i, 1),  UCO2_VCO2_Cov_lag(i, 2),      WCO2_Cov_lag (i))
        'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
     EndIf '(NOT Planar_Fit_flg)

     WCO2_Cov_major_sign += WCO2_Cov_lag (i)

   Next i

   'Calculate the separation distance normal (lateral) to wind and separation distance along wind
    Call Separation_Lag_Lateral_Distances (WD_SONIC, separation_x_irga, separation_y_irga, separation_lat_dist_irga, separation_lag_dist_irga)
    separation_lag_scan_irga = 1000*(separation_lag_dist_irga/WS_RSLT)/SCN_INTV   'in scan

    WCO2_Cov = NaN
    Select Case WCO2_Cov_major_sign
      Case Is >= 0.0
          
       If (separation_lag_scan_irga <= - MAX_LAG)        Then             'Find max of wCO2_cov_R
         MaxSpa (WCO2_Cov, 2, WCO2_Cov_lag (1))                           'Map 2 elements

       ElseIf separation_lag_scan_irga < - (MAX_LAG - 1) Then             'Search 3 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 3, WCO2_Cov_lag (1))                           'Map 3 elements

       ElseIf separation_lag_scan_irga < - (MAX_LAG - 2) Then             'Search 4 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (1))                           'Map 4 elements
         
       ElseIf separation_lag_scan_irga < - (MAX_LAG - 3) Then             'Search 4 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (2))                           'Map 4 elements
         lag_irga = lag_irga + 1

       ElseIf separation_lag_scan_irga < - (MAX_LAG - 4) Then             'Search 4 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (3))                           'Map 4 elements
         lag_irga = lag_irga + 2
            
       ElseIf separation_lag_scan_irga < (MAX_LAG - 5)   Then             'Search 4 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (4))                           'Map 4 elements
         lag_irga = lag_irga + 3
 
       ElseIf separation_lag_scan_irga = 0               Then             'Do not have to search if IRGASON Search 3 elements if CSAT3A + EC150
         #If (IRGASON) Then 
         WCO2_Cov = WCO2_Cov_lag (MAX_LAG + 1)                            'Do not have to search
         lag_irga = MAX_LAG + 1
         #Else
         MaxSpa (WCO2_Cov, 3, WCO2_Cov_lag (5))                           'Map 3 elements
         lag_irga = lag_irga + (MAX_LAG -1) 
         #EndIf 

       ElseIf separation_lag_scan_irga < 1               Then             'Search 4 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG))                     'Map 4 elements
         lag_irga = lag_irga + (MAX_LAG - 1)  

       ElseIf separation_lag_scan_irga < 2               Then             'Search 4 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 1))                 'Map 4 elements
         lag_irga = lag_irga + MAX_LAG 
          
       ElseIf separation_lag_scan_irga < 3               Then             'Search 4 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 2))                 'Map 4 elements
         lag_irga = lag_irga + (MAX_LAG  + 1) 

       ElseIf separation_lag_scan_irga < 4               Then             'Search 4 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 3))                 'Map 4 elements
         lag_irga = lag_irga + (MAX_LAG  + 2) 

       ElseIf separation_lag_scan_irga < 5                Then            'Search 3 elements in the array to ensure maximization of wCO2_cov_R
         MaxSpa (WCO2_Cov, 3, WCO2_Cov_lag (MAX_LAG + 4))                 'Map 3 elements
         lag_irga = lag_irga + (MAX_LAG  + 3) 

       Else
         MaxSpa (WCO2_Cov, 2, WCO2_Cov_lag (2*MAX_LAG)                    'Map 3 elements
         lag_irga = lag_irga + (2*MAX_LAG -1)  
            
       EndIf '(separation_lag_scan_irga <= - MAX_LAG) 

    Case Is < 0.0

       If (separation_lag_scan_irga <= - MAX_LAG)       Then              'Find min of wCO2_cov_R
         MinSpa (WCO2_Cov, 2, WCO2_Cov_lag (1))                           'Map 2 elements

       ElseIf separation_lag_scan_irga < - (MAX_LAG - 1) Then             'Search 3 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 3, WCO2_Cov_lag (1))                           'Map 3 elements
           
       ElseIf separation_lag_scan_irga < - (MAX_LAG - 2) Then             'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (1))                           'Map 4 elements
           
       ElseIf separation_lag_scan_irga < - (MAX_LAG - 3) Then             'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (2))                           'Map 4 elements
         lag_irga = lag_irga + 1
           
       ElseIf separation_lag_scan_irga < - (MAX_LAG - 4) Then             'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (3))                           'Map 4 elements
         lag_irga = lag_irga + 2

       ElseIf separation_lag_scan_irga < (MAX_LAG - 5)   Then             'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (4))                           'Map 4 elements
         lag_irga = lag_irga + 3           

       ElseIf separation_lag_scan_irga = 0               Then             'Do not have to search if IRGASON Search 3 elements if CSAT3A + EC150
         #If (IRGASON) Then
         WCO2_Cov = WCO2_Cov_lag (MAX_LAG + 1)                            'Do not have to search
         lag_irga = MAX_LAG + 1
         #Else
         MinSpa (WCO2_Cov, 3, WCO2_Cov_lag (5))                           'Search 3 elements
         lag_irga = lag_irga + (MAX_LAG -1)
         #EndIf
        
       ElseIf separation_lag_scan_irga < 1                Then            'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG))                     'Map 4 elements
         lag_irga = lag_irga + (MAX_LAG - 1)           

       ElseIf separation_lag_scan_irga < 2                Then            'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 1))                 'Map 4 elements
         lag_irga = lag_irga + MAX_LAG       

       ElseIf separation_lag_scan_irga < 3                Then            'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 2))                 'Map 4 elements
         lag_irga = lag_irga + MAX_LAG + 1   
           
       ElseIf separation_lag_scan_irga < 4                Then            'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 4, WCO2_Cov_lag (MAX_LAG + 3))                 'Map 4 elements
         lag_irga = lag_irga + MAX_LAG + 2         

       ElseIf separation_lag_scan_irga < 5                Then            'Search 3 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WCO2_Cov, 3, WCO2_Cov_lag (MAX_LAG + 4))                 'Map 3 elements
         lag_irga = lag_irga + MAX_LAG + 3        
         
       Else  
         MinSpa (WCO2_Cov, 2, WCO2_Cov_lag (2*MAX_LAG))                   'Map 2 elements
         lag_irga = lag_irga + (2*MAX_LAG -1)        
       EndIf '(separation_lag_scan_irga <= - MAX_LAG) 

  EndSelect 'WCO2_Cov_major_sign

  If (WCO2_Cov = NaN) Then lag_irga = MAX_LAG + 1                         'Lag_irga is not evaluated inside SELECT CASE if WCO2_Cov = NaN. In this case, data w/o lag delay in cov_out_CO2 are kept.

  'For final storage in flux file
  'Covariance values related to CO2 before coordinate rotation can be found using lag-IRGA
  array_index =  7*(lag_irga - 1) + 1
  Move (CO2, 7, Cov_out_CO2(array_index), 7)
  CO2_SIGMA         = SQR (CO2_SIGMA)
  CO2_density_SIGMA = SQR (CO2_density_SIGMA)
         
  'Covariance of horizontal wind (after coordinate rotations) and CO2 using lag-IRGA
  UCO2_Cov = UCO2_VCO2_Cov_lag(lag_irga, 1)
  VCO2_Cov = UCO2_VCO2_Cov_lag(lag_irga, 2)
        
  'Covariance values related to H2O before coordinate rotation can be found using lag-IRGA
  Move (H2O, 7, Cov_out_H2O(array_index), 7)
  H2O_SIGMA         = SQR (H2O_SIGMA)
  H2O_density_SIGMA = SQR (H2O_density_SIGMA)

 'Rotate covariance related to H2O
  If (NOT Planar_Fit_flg) Then
    'Double rotations
    'Rotation for the covariance of H2O with velocities
     Call Rotation12_Scalar_Covariance(alpha, gamma, _
     UxH2O_Cov, UyH2O_Cov, UzH2O_Cov, _
     UH2O_Cov,  VH2O_Cov,  WH2O_Cov)
     'Note: After coordinate rotations, Ux Is denoted by U, Uy by V, AND Uz by W
            
  ElseIf (Planar_Fit_flg) Then
     'Planar Fit rotations
     'Rotation for the covariance of H2O with velocities
      Call Rotation23_Scalar_Covariance(alpha, beta, _
      UxH2O_Cov, UyH2O_Cov, UzH2O_Cov, _
      UH2O_Cov,  VH2O_Cov,  WH2O_Cov)
      'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W
            
   EndIf '(NOT Planar_Fit_flg)

  'Convert lag_IRGA as an array index in sequential number as a lag number in scan (compare to CSAT data, negative: backward and positive: forward)
  lag_irga  = lag_irga - (MAX_LAG + 1)

  'Calculate the frequency correction factor for WCO2_cov_R and WH2O_Cov
   Call FreqFactorCSOPEC_wco2_wh2o_BA_LA_SP (z, ZL, WS_RSLT, separation_lat_dist_irga, FreqFactor_WCO2_WH2O)
   WCO2_Cov_fc = FreqFactor_WCO2_WH2O*WCO2_Cov
   WH2O_Cov_fc = FreqFactor_WCO2_WH2O*WH2O_Cov

 #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then   
  'Momentum flux after coordinate rotation and frequency corrections
  TAU = rho_a_Avg*USTAR*USTAR                                          'eq. (9.14), page 384 (Wallace and Hobbs (2006)
        
  'Correct sonic temperature flux for humidity and calculate sensible heat flux
  WT_SONIC_Cov_fc_SND = WT_SONIC_Cov_fc*(1- 0.51*(H2O_density_Avg/(1e3*rho_a_Avg)))-0.51*(T_SONIC + T_0C_K)*WH2O_Cov_fc/(1e3*rho_a_Avg)     'eq. 2.53 in van Dijk (2002)
      
  Cp = (Cpd*rho_d_Avg + Cpw*H2O_density_Avg)/(rho_d_Avg + H2O_density_Avg) 'Specific heat of moist air
  H  = Cp*rho_a_Avg*WT_SONIC_Cov_fc_SND

 #Else 
  'Momentum flux after coordinate rotation and frequency corrections
   TAU = rho_a_probe_Avg*USTAR*USTAR                                      'eq. (9.14), page 384 (Wallace and Hobbs (2006)
        
  'Correct sonic temperature flux for humidity and calculate sensible heat flux
   WT_SONIC_Cov_fc_SND = WT_SONIC_Cov_fc*(1- 0.51*(H2O_density_probe_Avg/(1e3*rho_a_probe_Avg)))-0.51*(T_SONIC + T_0C_K)*WH2O_Cov_fc/(1e3*rho_a_probe_Avg)     'eq. 2.53 in van Dijk (2002)
      
   Cp = (Cpd*rho_d_probe_Avg + Cpw*H2O_density_probe_Avg)/(rho_d_probe_Avg + H2O_density_probe_Avg) 'Specific heat of moist air
   H  = Cp*rho_a_probe_Avg*WT_SONIC_Cov_fc_SND

   If ((rho_a_probe_Avg = NaN) OR (H2O_density_probe_Avg = NaN) OR (rho_d_probe_Avg = NaN)) Then   
   'Momentum flux after coordinate rotation and frequency corrections
   TAU = rho_a_Avg*USTAR*USTAR                                          'eq. (9.14), page 384 (Wallace and Hobbs (2006)
        
   'Correct sonic temperature flux for humidity and calculate sensible heat flux
   WT_SONIC_Cov_fc_SND = WT_SONIC_Cov_fc*(1- 0.51*(H2O_density_Avg/(1e3*rho_a_Avg))) - 0.51*(T_SONIC + T_0C_K)*WH2O_Cov_fc/(1e3*rho_a_Avg)     'eq. 2.53 in van Dijk (2002)
      
   Cp = (Cpd*rho_d_Avg + Cpw*H2O_density_Avg)/(rho_d_Avg + H2O_density_Avg) 'Specific heat of moist air
   H  = Cp*rho_a_Avg*WT_SONIC_Cov_fc_SND
   EndIf    
    
 #EndIf '(NOT (SENSOR_T_RH OR SENSOR_HYGRO)) 

  TSTAR = - WT_SONIC_Cov_fc_SND/USTAR                                     'Surface layer scaling temperature, eq.(1.25b) page 16, Kaimal and Finnigan (1994). 

  'Apply WPL correction after coordinate rotation and freq corrections
  'IRGA Webb et al. (1980) term for carbon dioxide Eq. (24).
 #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then   
   sigma_wpl    = H2O_density_Avg/rho_d_Avg
   CO2_E_WPL_fc = MU_WPL*CO2_density_Avg*WH2O_Cov_fc/rho_d_Avg
   CO2_T_WPL_fc = (1 + (MU_WPL*sigma_wpl))*CO2_density_Avg*WT_SONIC_Cov_fc_SND/(TA_1_1_2+T_0C_K)
 #Else
   sigma_wpl    = H2O_density_probe_Avg/rho_d_probe_Avg
   CO2_E_WPL_fc = MU_WPL*CO2_density_Avg*WH2O_Cov_fc/rho_d_probe_Avg
   CO2_T_WPL_fc = (1 + (MU_WPL*sigma_wpl))*CO2_density_Avg*WT_SONIC_Cov_fc_SND/(TA_1_1_3+T_0C_K)
   
   If ((H2O_density_probe_Avg = NaN) OR (rho_d_probe_Avg = NaN) OR (TA_1_1_3 = NaN))  Then 
   sigma_wpl    = H2O_density_Avg/rho_d_Avg
   CO2_E_WPL_fc = MU_WPL*CO2_density_Avg*WH2O_Cov_fc/rho_d_Avg
   CO2_T_WPL_fc = (1 + (MU_WPL*sigma_wpl))*CO2_density_Avg*WT_SONIC_Cov_fc_SND/(TA_1_1_2 + T_0C_K)
   EndIf 
 #EndIf    

   FC_mass  = WCO2_Cov_fc + CO2_E_WPL_fc + CO2_T_WPL_fc                  'in mg/(m^2 s)
   FC = 22.72237*FC_mass                                                 '"22.72237" converts mg/(m^2 s) to umol/(m^2 s)

   'IRGA Webb et al. (1980) term for water vapor Eq. (25).
   H2O_E_WPL_fc  = MU_WPL*sigma_wpl*WH2O_Cov_fc
 #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then     
   H2O_T_WPL_fc  = (1 + (MU_WPL*sigma_wpl))*H2O_density_Avg*WT_SONIC_Cov_fc_SND/(TA_1_1_2 + T_0C_K)
   Lv  = 2501 - 2.365*TA_1_1_2                                           'Stull (1989)
 #Else
   H2O_T_WPL_fc  = (1 + (MU_WPL*sigma_wpl))*H2O_density_probe_Avg*WT_SONIC_Cov_fc_SND/(TA_1_1_3 + T_0C_K)
   Lv  = 2501 - 2.365*TA_1_1_3                                           'Stull (1989)

   If ((H2O_density_probe_Avg = NaN) OR (TA_1_1_3 = NaN))  Then 
   H2O_T_WPL_fc  = (1 + (MU_WPL*sigma_wpl))*H2O_density_Avg*WT_SONIC_Cov_fc_SND/(TA_1_1_2 + T_0C_K)
   Lv  = 2501 - 2.365*TA_1_1_2                                           'Stull (1989)
   EndIf 
 #EndIf  

   LE  = Lv* (WH2O_Cov_fc + H2O_E_WPL_fc + H2O_T_WPL_fc)                 'W/m^2
   ET  = 3.6*(WH2O_Cov_fc + H2O_E_WPL_fc + H2O_T_WPL_fc)                 'mm/hr

   Bowen_ratio = H/LE

'***** Data quality classification for scalar fluxes ***
  'Sensible heat flux
  'Calculate the measures of relative non-stationarity (Steady State Test)
   RN_WT_SONIC_cov  = ABS((RN_WT_SONIC_cov/nmbr_interval_qc_csat - WT_SONIC_Cov)/WT_SONIC_Cov)                                            'in fraction
   Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WT_SONIC_cov, H_QC)         'Quality classification for sensible heat flux w/ considering wind direction  
   Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WT_SONIC_cov, H_SSITC_TEST) 'Quality classification for sensible heat flux w/o considering wind direction  
   RN_WT_SONIC_cov = 0.0
   nmbr_interval_qc_csat = 0.0

   'CO2 flux
   'Calculate measures of relative non-stationarity (Steady State Test)
   RN_WCO2_Cov = ABS((RN_WCO2_Cov/nmbr_interval_qc_irga - WCO2_Cov)/WCO2_Cov)                                                              'in fraction
   Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WCO2_Cov, FC_QC)             'Quality classification for CO2 flux w/ considering wind direction  
   Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WCO2_Cov, FC_SSITC_TEST)     'Quality classification for CO2 flux w/o considering wind direction 
   RN_WCO2_Cov   = 0.0

   'H2O flux
   'Calculate measures of relative non-stationarity (Steady State Test)
    RN_WH2O_Cov = ABS((RN_WH2O_Cov/nmbr_interval_qc_irga - WH2O_Cov)/WH2O_Cov)  'in fraction
    Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WH2O_Cov, LE_QC)             'Quality classification for latent heat flux w/ considering wind direction  
    Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WH2O_Cov, LE_SSITC_TEST)     'Quality classification for latent heat flux w/o considering wind direction 
    RN_WH2O_Cov   = 0.0
    nmbr_interval_qc_irga = 0.0
          
   '***** Construct ending time stamp
    CR1000X_clock = status.timestamp(4,1)
    TIMESTAMP_END = Left (CR1000X_clock, 4) & Mid (CR1000X_clock, 6, 2) & Mid (CR1000X_clock, 9, 2) & Mid (CR1000X_clock,12,2)& Mid (CR1000X_clock,15,2)   
   
 EndIf '(comp_cov_CO2.Output(1,1) AND comp_cov_H2O.Output(1,1) AND comp_mean.Output(1,1) AND comp_cov_cs_5min.Output(1, 1))

'********************  End of IRGA data processing  **********************
        

'*****   Data processing for the rest of slow-response sensors       *****  
 
 #If (SENSOR_CNR4 AND SENSOR_CNF4) Then
  '*** Beginning of 3-second running mean of horizontal wind for NR Lite and/or CNF4 ***
  hor_wind_raw = SQR (sonic_irga_raw(1)*sonic_irga_raw(1) + sonic_irga_raw(2)*sonic_irga_raw(2))
  AvgRun (hor_wind, 1 , hor_wind_raw, NMBR_WND_SAMPLES)               'Maintain a three second running mean of horizontal wind.
 #EndIf '(SENSOR_CNR4 AND SENSOR_CNF4)

 #If (SENSOR_Rn) Then
   CallTable stats_net_radiation

   '*** Get Rn for the current averaging interval
   If (stats_net_radiation.Output(1,1)) Then
      GetRecord (NETRAD, stats_net_radiation, 1)
   EndIf
 #EndIf '(SENSOR_Rn)

 #If (SENSOR_HFP) Then

   '*** Table for soil heat flux plate ***
   CallTable stats_SHF

   '*** Calculating the change in heat storage of soil above soil heat flux plate
   If (stats_SHF.Output(1,1)) Then

     GetRecord (G_plate_1_1_1, stats_SHF, 1)

     #If (SENSOR_SWC) Then
          
      For i = 1 To NMBR_HFP
        SG_rep (i) = ((Tsoil_current (i) - Tsoil_prev (i))*Cds*soil_bulk_density + _
                      (Tsoil_current(i)*soil_wtr_current (i) - Tsoil_prev(i)*soil_wtr_prev(i))*1000*Cw)*thick_abv_SHFP/(60*OUTPUT_INTV - Offset_intv_delta_ht_storage)
                   
        G_surface_rep(i) = shf_plate_avg(i) + SG_rep (i)  
      Next i
 
      AvgSpa(G_surface, NMBR_HFP, shf_plate_avg(1))                       'G_surface is used as a temporary variable
      AvgSpa(SG,        NMBR_HFP, SG_rep (1))
        
      G_surface = G_surface + SG
        
      Offset_intv_delta_ht_storage = 0                                    'Reset time interval offset
        
     #If (SENSOR_TCAV) Then
       Move (Tsoil_prev (1), NMBR_TCAV, Tsoil_current(1), NMBR_TCAV)
     #EndIf
     
     #If ((NOT SENSOR_TCAV) AND (SENSOR_SWC)) Then
       Move (Tsoil_prev (1), NMBR_CS65x, Tsoil_current(1), NMBR_CS65x)
     #EndIf

       Move (soil_wtr_prev(1), NMBR_CS65x, soil_wtr_current (1), NMBR_CS65x)

    #If (SENSOR_Rn) Then
     'NR01 and CNR4: smallest sensitivity is 10 uV/(W/m^2), CR1000X resolution at the measurement range (+/-200 mV) is 0.1 uV.
     'Radiation < 0.01 W/m^2 cannot be resolved by CR1000X. The value of 0.1 is used for this threshold although this is approximation.
      If (ABS(NETRAD - G_surface) > 0.1) Then
        energy_closure = (LE + H)/(NETRAD - G_surface)          
      Else
        energy_closure = 1
      EndIf
        
     #If (SENSOR_TE525) Then  
     If (((energy_closure > 1.25) OR (energy_closure < 0.75) OR (energy_closure = NaN)) AND (USTAR > 0.2)  AND (RH_1_1_2 < 85) AND (P_cumul_win_interval = 0) AND (sun_elevation > 15)) Then 
        poor_energy_closure_flg = TRUE 
     Else 
       poor_energy_closure_flg = (energy_closure = NaN)
     EndIf 

       P_cumul_win_interval = 0     'Use to indicate the rain within a current interval to judge poor_energy_closure_flg 
     #EndIf '(SENSOR_TE525)        
       
   #EndIf '(SENSOR_Rn)
 #EndIf '(SENSOR_SWC) 

 EndIf '(stats_SHF.Output(1,1)) 
#EndIf '(SENSOR_HFP)
'****** End of data processing for the rest of slow-response sensors *****  


#If (SENSOR_FW) Then
'*****                  FW data processing                           *****

 'Load in the FW data that has been lagged by OFFSET scans.
  For i = MAX_LAG To - MAX_LAG Step -1
    array_index = MAX_LAG + 1 - i                                         'Convert i = MAX_LAG, ..., 1, 0 -1, ..., MAX_LAG to array_index = 1, 2, ..., 2*MAX_LAG +1

    GetRecord (dly_data_FW_out(1), delay_fw, (OFFSET + i))

    'Load the arrays that hold the input data for the covariance instructions.
    Cov_array_FW(array_index, 1) = dly_data_FW_out(1)                     'fw
    Move (Cov_array_FW(array_index, 2), 3, Ux, 3)
     
    FW_bad_data_flg(array_index) = (dly_data_FW_out(2) = -1)
                             
  Next i

  FW = Cov_array_FW(MAX_LAG + 1, 1)                                       'FW with no lag will be stored to Time_Series table

  CallTable comp_cov_fw

  If (comp_cov_fw.Output(1,1)) Then
    GetRecord (FW_Avg_lag_b5, comp_cov_fw, 1)

    WFW_cov_major_sign =0

    For i = 1 To (2* MAX_LAG + 1)
      array_index = 6*(i -1) + 3
      If (NOT (Planar_Fit_flg)) Then
       'Double rotations
       'Rotation for the covariance of FW temperature with wind velocities
       Call Rotation12_Scalar_Covariance(alpha, gamma, _
       Cov_out_FW(array_index), Cov_out_FW(array_index + 1), Cov_out_FW(array_index + 2), _
       UFW_VFW_Cov_lag(i, 1),   UFW_VFW_Cov_lag(i, 2),       WFW_Cov_lag (i))
            
      Else
       'Planar fit rotations
       'Rotation for the covariance of FW temperature with velocities
        Call Rotation23_Scalar_Covariance(alpha, beta, _
        Cov_out_FW(array_index), Cov_out_FW(array_index + 1), Cov_out_FW(array_index + 2), _
        UFW_VFW_Cov_lag(i, 1),   UFW_VFW_Cov_lag(i, 2),       WFW_Cov_lag (i))
      EndIf '(NOT (Planar_Fit_flg)) 

        WFW_cov_major_sign += WFW_Cov_lag(i)
    Next i

   'Calculate the separation distances normal (lateral) to wind and separation distances along wind
    Call Separation_Lag_Lateral_Distances (WD_SONIC, separation_x_FW, separation_y_FW, separation_lat_dist_FW, separation_lag_dist_FW)
    separation_lag_scan_FW = 1000.0*(separation_lag_dist_FW/WS_RSLT)/SCN_INTV         ' in scan

    WFW_Cov = NaN
    Select Case WFW_cov_major_sign
      Case Is >= 0.0
          
        If (separation_lag_scan_FW <= - MAX_LAG)        Then              'Find max of wFW_cov_R
           MaxSpa (WFW_Cov, 2, WFW_Cov_lag (1))                           'Map 2 elements

        ElseIf separation_lag_scan_FW < - (MAX_LAG - 1) Then              'Search 3 elements in the array to ensure maximization of WFW_cov
           MaxSpa (WFW_Cov, 3, WFW_Cov_lag (1))                           'Map 3 elements

        ElseIf separation_lag_scan_FW < - (MAX_LAG - 2) Then              'Search 4 elements in the array to ensure maximization of WFW_cov
           MaxSpa (WFW_Cov, 4, WFW_Cov_lag (1))                           'Map 4 elements
         
        ElseIf separation_lag_scan_FW < - (MAX_LAG - 3) Then              'Search 4 elements in the array to ensure maximization of WFW_cov
           MaxSpa (WFW_Cov, 4, WFW_Cov_lag (2))                           'Map 4 elements
           lag_FW = lag_FW + 1

        ElseIf separation_lag_scan_FW < - (MAX_LAG - 4) Then              'Search 4 elements in the array to ensure maximization of WFW_cov
          MaxSpa (WFW_Cov, 4, WFW_Cov_lag (3))                            'Map 4 elements
          lag_FW = lag_FW + 2
            
        ElseIf separation_lag_scan_FW < (MAX_LAG - 5)   Then              'Search 4 elements in the array to ensure maximization of WFW_cov
          MaxSpa (WFW_Cov, 4, WFW_Cov_lag (4))                            'Map 4 elements
         lag_FW = lag_FW + 3
          
        ElseIf separation_lag_scan_FW = 0               Then              'Search 3 elements in the array to ensure maximization of WFW_cov
          MaxSpa (WFW_Cov, 3, WFW_Cov_lag (MAX_LAG))                      'Map 3 elements
          lag_FW = lag_FW + (MAX_LAG -1)
  
        ElseIf separation_lag_scan_FW < 1               Then              'Search 4 elements in the array to ensure maximization of WFW_cov
          MaxSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG))                      'Map 4 elements
          lag_FW = lag_FW + (MAX_LAG - 1)  

        ElseIf separation_lag_scan_FW < 2               Then              'Search 4 elements in the array to ensure maximization of WFW_cov
          MaxSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 1))                  'Map 4 elements
          lag_FW = lag_FW + (MAX_LAG) 
          
        ElseIf separation_lag_scan_FW < 3               Then              'Search 4 elements in the array to ensure maximization of WFW_cov
          MaxSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 2))                  'Map 4 elements
          lag_FW = lag_FW + (MAX_LAG  + 1) 

        ElseIf separation_lag_scan_FW < 4               Then              'Search 4 elements in the array to ensure maximization of WFW_cov
          MaxSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 3))                  'Map 4 elements
          lag_FW = lag_FW + (MAX_LAG  + 2) 

       ElseIf separation_lag_scan_FW < 5                Then              'Search 3 elements in the array to ensure maximization of WFW_cov_R
          MaxSpa (WFW_Cov, 3, WFW_Cov_lag (MAX_LAG + 4))                  'Map 3 elements
          lag_FW = lag_FW + (MAX_LAG  + 3) 

       Else
          MaxSpa (WFW_Cov, 2, WFW_Cov_lag (2*MAX_LAG)                     'Map 2 elements
          lag_FW = lag_FW + (2*MAX_LAG -1)  
       EndIf '(separation_lag_scan_FW <= - MAX_LAG)

    Case Is < 0.0
       If (separation_lag_scan_FW <= - MAX_LAG)        Then               'Find min of WFW_cov
         MinSpa (WFW_Cov, 2, WFW_Cov_lag (1))                             'Map 2 elements

       ElseIf separation_lag_scan_FW < - (MAX_LAG - 1) Then               'Search 3 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 3, WFW_Cov_lag (1))                             'Map 3 elements
           
       ElseIf separation_lag_scan_FW < - (MAX_LAG - 2) Then               'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 4, WFW_Cov_lag (1))                             'Map 4 elements
           
       ElseIf separation_lag_scan_FW < - (MAX_LAG - 3) Then               'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 4, WFW_Cov_lag (2))                             'Map 4 elements
         lag_FW = lag_FW + 1
           
         ElseIf separation_lag_scan_FW < - (MAX_LAG - 4) Then             'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 4, WFW_Cov_lag (3))                             'Map 4 elements
         lag_FW = lag_FW + 2

       ElseIf separation_lag_scan_FW < (MAX_LAG - 5)   Then               'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 4, WFW_Cov_lag (4))                             'Map 4 elements
         lag_FW = lag_FW + 3
           
       ElseIf separation_lag_scan_FW = 0               Then               'Search 3 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 3, WFW_Cov_lag (MAX_LAG))                       'Map 3 elements
         lag_FW = lag_FW + (MAX_LAG -1)           

       ElseIf separation_lag_scan_FW < 1               Then               'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG))                       'Map 4 elements
         lag_FW = lag_FW + (MAX_LAG - 1)           

       ElseIf separation_lag_scan_FW < 2               Then               'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 1))                   'Map 4 elements
         lag_FW = lag_FW + MAX_LAG       

       ElseIf separation_lag_scan_FW < 3               Then               'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 2))                   'Map 4 elements
         lag_FW = lag_FW + MAX_LAG + 1   
           
       ElseIf separation_lag_scan_FW < 4               Then               'Search 4 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 4, WFW_Cov_lag (MAX_LAG + 3))                   'Map 4 elements
         lag_FW = lag_FW + MAX_LAG + 2         

       ElseIf separation_lag_scan_FW < 5               Then               'Search 3 elements in the array to ensure maximization in terms of absolute value.
         MinSpa (WFW_Cov, 3, WFW_Cov_lag (MAX_LAG + 4))                   'Map 3 elements
         lag_FW = lag_FW + MAX_LAG + 3        
         
       Else  
         MinSpa (WFW_Cov, 2, WFW_Cov_lag (2*MAX_LAG))                     'Map 2 elements
         lag_FW = lag_FW + (2*MAX_LAG -1)        
       EndIf '(separation_lag_scan_FW <= - MAX_LAG) 

    EndSelect 'WFW_cov_major_sign
                   
    If (WFW_Cov = NaN) Then lag_FW = MAX_LAG + 1                          'Lag_FW is not evaluated inside SELECT CASE if WFW_Cov = NaN. In this case, data w/o lag delay in cov_out_fw are kept.

    'For final storage in flux table
    'FW Covariance before coordinate rotation can be found using lag-variable
     array_index = 6*(lag_FW - 1)
     FW_Avg      = Cov_out_FW(array_index + 1)
     FW_SIGMA    = SQR(Cov_out_FW(array_index + 2))
     UxFW_Cov    = Cov_out_FW(array_index + 3)
     UyFW_Cov    = Cov_out_FW(array_index + 4)
     UzFW_Cov    = Cov_out_FW(array_index + 5)
                                
     nmbr_smpl_FW = Cov_out_FW(array_index + 6)
        
     'FW Covariance after coordinate rotation also can be found using lag-variable
     UFW_Cov = UFW_VFW_Cov_lag(lag_FW, 1)
     VFW_Cov = UFW_VFW_Cov_lag(lag_FW, 2)

    'Convert lag_FW in sequential number for array index to that in scan number. Compare to CSAT data, negative: backward and positive: forward.
     lag_FW  = lag_FW - (MAX_LAG + 1)

    'Calculate FW time constant
     #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then   
       Call Time_Const_Thermocouple_E(FW_diameter, FW_Avg, WS_RSLT, rho_a_Avg,       time_const_FW)
     #Else 
       If (NOT (rho_a_probe_Avg = NaN)) Then  
       Call Time_Const_Thermocouple_E(FW_diameter, FW_Avg, WS_RSLT, rho_a_probe_Avg, time_const_FW)
       Else       
       Call Time_Const_Thermocouple_E(FW_diameter, FW_Avg, WS_RSLT, rho_a_Avg,       time_const_FW)
       EndIf
     #EndIf
      
     Call FreqFactorCSATFW_wT_BA_LA_TC_SP(z, ZL, WS_RSLT, separation_lat_dist_FW, time_const_FW, FreqFactor_WFW)
     WFW_Cov_fc = FreqFactor_WFW*WFW_Cov
     
     #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then      
       H_FW = Cp*rho_a_Avg*WFW_Cov_fc
     #Else 
       If (NOT (rho_a_probe_Avg = NaN)) Then 
       H_FW = Cp*rho_a_probe_Avg*WFW_Cov_fc
       Else
       H_FW = Cp*rho_a_Avg*WFW_Cov_fc  
       EndIf
     #EndIf 
             
   EndIf '(comp_cov_fw.Output(1,1))
'********************  End of FW data processing  ************************
#EndIf '(SENSOR_FW)
 
'*****                 Ending section of main scan                   *****

  'Save time series data.
   CallTable Time_Series

  'Save averaged and calculated data.
  CallTable Flux_AmeriFluxFormat
         
  CallTable Flux_CSFormat
     
  #If (NOT ONE_FL_TABLE) Then
  CallTable Flux_Notes
  #EndIf
      
  If (Flux_AmeriFluxFormat.Output(1,1)) Then
     diag_sonic_aggregate = &H0
     diag_irga_aggregate  = &H0

    'The ending time stamp in current interval is the starting time stamp for next interval 
     TIMESTAMP_START = TIMESTAMP_END
     Erase(TIMESTAMP_END)
     
  EndIf '(Flux_AmeriFluxFormat.Output(1,1))
          
  slowsequence_disable_f = TRUE
  If (slowsequence_finished_f) Then
    slowsequence_finished_f = FALSE
    slowsequence_disable_f  = FALSE
  EndIf

 Else
  scan_count += 1
 EndIf '(scan_count >= (OFFSET + MAX_LAG))

NextScan

SlowSequence
Scan (SLW_SCN_INTV, mSec, 7, 0)
  
  'Read timer 
  secs_snc_pwr_swtch = Timer(1, sec, 4)

 'Measure battery voltage.
  Battery (V_batt)
  If (V_batt < SYSTEM_PWR_OFF_SET_PT) AND (NOT irga_pwr_off_f) Then 
    cnt_lwr_pwr_off_set_pt = cnt_lwr_pwr_off_set_pt + 1  
  Else 
    cnt_lwr_pwr_off_set_pt = 0 
  EndIf 
  AvgRun (V_batt_runng, 1, V_batt, (120000/SLW_SCN_INTV))
      
 'Measure CR1000X panel temperature
  PanelTemp (T_panel, NTCH_FRQ_SLW)
    
  #If (CSAT3A_EC150) Then
  #If (CSAT_TYP_3AH) Then 
    GetVariables  (com_rslt_get, ComC1, 0, 2, 0000, 0, "Public", "array_to_csat(1)", array_frm_heating_ctrl(1), 17)  'Get data from heating controller
    If (com_rslt_get = 0) Then  
      AvgRun (pwr_hr_trnsds_arms, 1, pwr_trnsds_arms, INT(60*60*1000/SLW_SCN_INTV))
    EndIf 

    CSAT3H_user_ctrl_on = CSAT3H_user_ctrl_flg 
    SendVariables (com_rslt_snt, ComC1, 0, 2, 0000, 0, "Public", "array_frm_csat(1)", array_to_heating_ctrl(1), 7)    'Sent data to heating controller 

    If (com_rslt_snt = 0) Then 
      diag_sonic_slwintv = 0
      If (CSAT3H_user_ctrl_flg_prev <> CSAT3H_user_ctrl_flg) Then 
        config_type = "CSAT3AH heating"
        
        Select Case CSAT3H_user_ctrl_flg
           Case true 
              config_status = "On" 
           Case FALSE 
              config_status = "Off"
        EndSelect  
             
          CSAT3H_user_ctrl_flg_prev = CSAT3H_user_ctrl_flg
          CallTable Config_Setting_Notes   
          
      EndIf '(CSAT3H_user_ctrl_flg_prev <> CSAT3H_user_ctrl_flg) 
    EndIf '(com_rslt_snt = 0) 
        
  #EndIf '(CSAT_TYP_3AH)         
  #EndIf '(CSAT3A_EC150)  
    
    
  #If (CDM_VOLT_116 AND (NOT SENSOR_FW)) Then
  #If (NMBR_TMPR_CDM_VOLT > 0) Then
   '*** Beginning of CDM-A/VOLT116 panel temperature measurement
   CDM_PanelTemp (MODEL_CDMVLT, CPI_CDM_VOLT, T_cdm_volt_1, NMBR_TMPR_CDM_VOLT, CDM_VOLT_1ST_TMPR_CHAN, NTCH_FRQ_SLW)
  #EndIf     
  #EndIf '(CDM_VOLT_116 AND (NOT SENSOR_FW))  
    
   process_time = (Status.ProcessTime(1,1))/1000.0                  'in ms 
   buff_depth   = Status.BuffDepth(1,1)
    
  CallTable diagnostic
             
 #If (SENSOR_Rn) Then
'*****                   Net radiation measurements                  *****
    
 #If (SENSOR_NR01 OR SENSOR_CNR4) Then
   '*** A 4-way radiometer measurements  
    CDM_VoltDiff(MODEL_CDMVLT, CPI_CDM_VOLT, R_SW_in, 4, mV200, NR_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    'Compute net radiation, albedo, downwelling and upwelling long-wave radiation.
    R_SW_in       = R_SW_in*SW_IN_CAL
    SW_IN         = R_SW_in                                          'for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
    R_SW_out      = R_SW_out*SW_OUT_CAL
    R_LW_in_meas  = R_LW_in*LW_IN_CAL
    R_LW_out_meas = R_LW_out*LW_OUT_CAL

    NETRAD_raw = R_SW_in - R_SW_out + R_LW_in_meas - R_LW_out_meas

    'NR01 or CNR4: Smallest sensitivity is 10 uV/(W/m^2), CR1000X resolution at the measurement range (+/-200 mV) is 0.1 uV.
    'Radiation < 0.01 W/m^2 cannot be resolved by CR1000X. The value of 0.1 is used for this threshold although this is approximation.
    If (R_SW_in > 0.1) AND (R_SW_in >= R_SW_out) Then
      albedo = 100.0*(R_SW_out/R_SW_in)                               'in %
    Else
      albedo = 0.0
    EndIf 

    #If (SENSOR_NR01) Then
    'Measure the resistance to calculate the body temperature.
    CDM_Resistance(MODEL_CDMVLT, CPI_CDM_VOLT, T_nr, 1, mV200, T_NR_ANALOG_INPUT, T_NR_CURRENT_EXCITATION, 1, 1675, TRUE, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    T_nr = T_nr/100.0
    PRT (T_nr, 1, T_nr, 1, T_0C_K)

   'Correct long-wave radiation.
    R_LW_in  = R_LW_in_meas  + Sigma_SB*(T_nr*T_nr*T_nr*T_nr)
    R_LW_out = R_LW_out_meas + Sigma_SB*(T_nr*T_nr*T_nr*T_nr)
    
    #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then 
    If (((Tc - T_DP > NETRAD_HEATER_T_TD_THRSHLD) OR (V_batt_runng <= 11)) AND NR01_heater_on_f) Then            'Turn off heater when the difference between T and TD is greater than setting threshold 
    #Else         
    If (((T_probe - T_DP_Probe > NETRAD_HEATER_T_TD_THRSHLD) OR (V_batt_runng <= 11)) AND NR01_heater_on_f) Then 'Turn off heater when the difference between T and TD is greater than setting threshold 
    #EndIf 
       #If (NOT SENSOR_HFPSC) Then 
       CDM_SW12 (MODEL_CDMVLT, CPI_CDM_VOLT, 1, FALSE, 1)
       #Else
       SW12 (SW12_1, FALSE, 1)
       #EndIf
       NR01_heater_on_f = FALSE
    EndIf 
    
    #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then  
    If ((Tc - T_DP <= NETRAD_HEATER_T_TD_THRSHLD) AND (NOT NR01_heater_on_f) AND (V_batt_runng > 11)) Then             'Turn on heater when the difference between T and TD is smaller than setting threshold   
    #Else                       
    If ((T_probe - T_DP_Probe <= NETRAD_HEATER_T_TD_THRSHLD) AND (NOT NR01_heater_on_f) AND (V_batt_runng > 11)) Then  'Turn on heater when the difference between T and TD is smaller than setting threshold   
    #EndIf

       #If (NOT SENSOR_HFPSC) Then 
       CDM_SW12 (MODEL_CDMVLT, CPI_CDM_VOLT, 1, TRUE, 1)
       #Else
       SW12 (SW12_1, TRUE, 1)
       #EndIf
       NR01_heater_on_f = TRUE 
    EndIf                  
   #EndIf '(SENSOR_NR01)

    #If (SENSOR_CNR4) Then
    'Correct longwave radiation.
    CDM_BrHalf (MODEL_CDMVLT, CPI_CDM_VOLT, X_cnr4, 1, mV1000, 2*T_NR_ANALOG_INPUT - 1, T_NR_VOLTAGE_EXCITATION, 1, 1000, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    ln_R = LOG (1000.0*X_cnr4/(1-X_cnr4))
    T_nr = (1/(A_SHH+B_SHH*ln_R+C_SHH*ln_R*ln_R*ln_R))

    R_LW_in  = R_LW_in_meas  + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
    R_LW_out = R_LW_out_meas + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
    
    #If (SENSOR_CNF4) Then 
      If ((hor_wind > CNR4_FAN_WND_THRSHLD) OR  (V_batt_runng <= 11)) Then 
          cnr4_fan_on_f = FALSE                                    'Turn off fan due to strong wind if heater is not on 
      Else 
          cnr4_fan_on_f = TRUE                                     'Turn on fan due to low wind
      EndIf 

      #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then 
      If ((Tc - T_DP > NETRAD_HEATER_T_TD_THRSHLD) OR (V_batt_runng <= 11)) Then             'Turn off heater when the difference between T and TD is greater than setting threshold 
      #Else                       
      If ((T_probe - T_DP_Probe > NETRAD_HEATER_T_TD_THRSHLD) OR (V_batt_runng <= 11)) Then  'Turn off heater when the difference between T and TD is greater than setting threshold 
      #EndIf 

        cnr4_heater_1_on_f = FALSE
        cnr4_heater_2_on_f = FALSE
       
      Else                                                         'Turn on two heater lines and fan 
        cnr4_heater_1_on_f = TRUE 
        cnr4_heater_2_on_f = TRUE
        cnr4_fan_on_f      = TRUE

      EndIf
     
     CDM_SW5 (MODEL_CDMVLT, CPI_CDM_VOLT, CNF4_FAN_SW5_PORT,     cnr4_fan_on_f,      0)
     CDM_SW5 (MODEL_CDMVLT, CPI_CDM_VOLT, CNF4_HEATER1_SW5_PORT, cnr4_heater_1_on_f, 0)                              
     CDM_SW5 (MODEL_CDMVLT, CPI_CDM_VOLT, CNF4_HEATER2_SW5_PORT, cnr4_heater_2_on_f, 0)
     
    #EndIf '(SENSOR_CNF4)                 
    #EndIf '(SENSOR_CNR4)
    #EndIf '(SENSOR_NR01 OR SENSOR_CNR4)
    
    #If (SENSOR_SN500) Then
      '*** A 4-way radiometer measurements 
       SDI12Recorder(R_SW_in, SN500_SDI_PORT, SN500SDI_ADR, "C!",  1, 0, -1)
 
      'Compute net radiation, albedo, downwelling and upwelling long-wave radiation.
      SW_IN      = R_SW_in                                       'for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
      NETRAD_raw = R_SW_in - R_SW_out + R_LW_in - R_LW_out

      'The value of 10 for zero offset is used here for this threshold although this is approximation.
       If ((R_SW_in > 10) AND (R_SW_in >= R_SW_out)) Then
         albedo = 100.0*(R_SW_out/R_SW_in)                       'in %
       Else
         albedo = 0.0
       EndIf 
                
       SDI12Recorder(LW_in_sgnl_mV, SN500_SDI_PORT, SN500SDI_ADR, "C3!",  1, 0, -1)
       T_nr     = LW_in_tmpr  + T_0C_K
       T_nr_out = LW_out_tmpr + T_0C_K
       
       'Turn off heater when the difference between T and TD is greater than setting threshold 
       #If (SENSOR_T_RH OR SENSOR_HYGRO) Then                 
       If ((T_probe - T_DP_Probe >= SN500_HEATER_T_TD_THRSHLD) OR (V_batt_runng <= 11)) Then  
       #Else 
       If ((Tc - T_DP >= SN500_HEATER_T_TD_THRSHLD) OR (V_batt_runng <= 11)) Then               
       #EndIf 
          If (sn500_heater_on_f) Then 
          SDI12Recorder(sn500_heater_set_dummy, SN500_SDI_PORT, SN500SDI_ADR, "XHOFF!", 1, 0, -1)
          sn500_heater_on_f = FALSE
          EndIf 
       EndIf 
       
       'Turn on heater when the difference between T and TD is smaller than setting threshold 
       #If (SENSOR_T_RH OR SENSOR_HYGRO) Then                 
       If ((T_probe - T_DP_Probe < SN500_HEATER_T_TD_THRSHLD) AND (V_batt_runng > 11.5)) Then  
       #Else 
       If ((Tc - T_DP < SN500_HEATER_T_TD_THRSHLD) AND (V_batt_runng > 11.5)) Then               
       #EndIf  
          If (NOT sn500_heater_on_f) Then 
          SDI12Recorder(sn500_heater_set_dummy, SN500_SDI_PORT, SN500SDI_ADR, "XHON!", 1, 0, -1)
          sn500_heater_on_f = TRUE
          EndIf 
        EndIf 
     #EndIf '(SENSOR_SN500)
'******************* End of net radiation measurements *******************  
 #EndIf '(SENSOR_Rn)
   

 #If (SENSOR_HFP) Then 
'*****            Soil heat flux plate measurements                  *****   
 
 #If (SENSOR_HFP01) Then
    '*** HFP01 measurements
    CDM_VoltDiff (MODEL_CDMVLT, CPI_CDM_VOLT, shf_plate(1), NMBR_HFP, mV200C, SHF_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, shf_plate_cal(),0)
 #EndIf

 #If (SENSOR_HFPSC) Then
   '*** HFP01SC measurements
   CDM_VoltDiff (MODEL_CDMVLT, CPI_CDM_VOLT, shf_mV(1), NMBR_HFP, mV200C, SHF_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
    
   'Apply HFP01SC soil heat flux plate calibration.
   For i_slow = 1 To NMBR_HFP
     shf_plate(i_slow) = shf_mV(i_slow)*shf_plate_cal(i_slow)
   Next i_slow
     
  'Measure voltage across the heater (V_Rf).
  CDM_VoltDiff  (MODEL_CDMVLT, CPI_CDM_VOLT, V_rf(1), 1, mV5000, SHF_HEATER_ANALOG_INPUT,     TRUE, 500, NTCH_FRQ_SLW, 0.001, 0)
  #If  (NMBR_HFP > 1) 
  CDM_VoltDiff  (MODEL_CDMVLT, CPI_CDM_VOLT, V_rf(2), 1, mV5000, SHF_HEATER_ANALOG_INPUT + 1, TRUE, 500, NTCH_FRQ_SLW, 0.001, 0)
  #EndIf 
  #If  (NMBR_HFP > 2) 
  CDM_VoltDiff  (MODEL_CDMVLT, CPI_CDM_VOLT, V_rf(3), 1, mV5000, SHF_HEATER_ANALOG_INPUT + 3, TRUE, 500, NTCH_FRQ_SLW, 0.001, 0)
  #EndIf 

  'Maintain filtered values for calibration.
   AvgRun (shf_mV_run(1), NMBR_HFP, shf_mV(1), 10)
   AvgRun (V_rf_run(1),   NMBR_HFP, V_rf(1),   10)

   'Begin HFP01SC calibration one minute into every CAL_INTERVAL in minutes.
    If (IfTime (1, CAL_INTERVAL, Min)) Then
      shf_cal_on_f = TRUE
      Move (shf_mV_0(1), NMBR_HFP, shf_mV_run(1), NMBR_HFP)
      
     'Power the HFP01SC heaters.
      CDM_SW12 (MODEL_CDMVLT, CPI_CDM_VOLT, 1, TRUE, 1)
      #If (NMBR_HFP > 2)
      CDM_SW12 (MODEL_CDMVLT, CPI_CDM_VOLT, 2, TRUE, 1)
      #EndIf 
    
    EndIf '(IfTime (1, CAL_INTERVAL, Min))

    If (IfTime (4, CAL_INTERVAL, Min)) Then
      Move (shf_mV_180(1), NMBR_HFP, shf_mV_run(1), NMBR_HFP)
      Move (V_rf_180(1),   NMBR_HFP, V_rf_run(1),   NMBR_HFP)
    
     'Power off the HFP01SC heaters.
      CDM_SW12 (MODEL_CDMVLT, CPI_CDM_VOLT, 1, FALSE, 1)
      #If (NMBR_HFP > 2)
      CDM_SW12 (MODEL_CDMVLT, CPI_CDM_VOLT, 2, FALSE, 1)
      #EndIf 

    EndIf '(IfTime (4, CAL_INTERVAL, Min))

    'End HFP01SC calibration sequence.
    If (IfTime(END_CAL, CAL_INTERVAL, Min)) Then
      Move (shf_mV_end(1), NMBR_HFP, shf_mV_run(1), NMBR_HFP)
      'Compute new HFP01SC calibration factors.
      For i_slow = 1 To NMBR_HFP
        If (V_rf_180(i_slow) <> NaN) AND (shf_mV_0(i_slow) <> NaN) AND (shf_mV_180(i_slow) <> NaN) Then
           shf_cal_fail_f(i_slow) = FALSE
           
          'In the following equation
          'a. 10 is the resistance of reference resistor in ohms.
           'b. 2 means that heat emits outward on two plate sides. 
           'c. 3.855e-3 is HFP01SC area in m^2 . 
          
          shf_plate_cal(i_slow) = (((V_rf_180(i_slow)/10)*(V_rf_180(i_slow)/10)*shf_htr_resstnc (i_slow)/2)/3.855e-3) _
                                 /ABS (((shf_mV_0(i_slow)+shf_mV_end(i_slow))/2)-shf_mV_180(i_slow))

          'Self-calibrated sensitivity must be win 80~105% of manufacture one and mV reading must not be NaN. (see formula 3.2.4, HukseFlux HFP01SC manual v1624)         
          If ((1000/shf_plate_cal(i_slow) < 800/shf_mfct_cal(i_slow)) OR (1000/shf_plate_cal(i_slow) > 1050/shf_mfct_cal(i_slow))) Then 
             shf_cal_fail_f(i_slow) = TRUE                             
             shf_plate_cal(i_slow)    = shf_mfct_cal(i_slow)
           EndIf  

        Else 
            shf_cal_fail_f(i_slow)  = TRUE 
        EndIf '(V_rf_180(i_slow) <> NaN) AND (shf_mV_0(i_slow) <> NaN) AND (shf_mV_180(i_slow) <> NaN)

      Next i_slow
        shf_cal_on_f = FALSE
        
   EndIf '(IfTime(END_CAL, CAL_INTERVAL, Min))

 #EndIf '(SENSOR_HFPSC)
'************** End of soil heat flux plate measurements *****************     
 #EndIf '(SENSOR_HFP)

    
#If (SENSOR_TCAV) Then
'*****                    TCAV measurements                          *****
  #If (NMBR_TCAV <= 2) Then 
  CDM_TCDiff (MODEL_CDMVLT, CPI_CDM_VOLT, Tsoil(1), NMBR_TCAV, mV200, TCAV_ANALOG_INPUT +1, TypeE, T_cdm_volt_1, TRUE, 500, NTCH_FRQ_SLW, 1, 0)  
  #Else 
  CDM_TCDiff (MODEL_CDMVLT, CPI_CDM_VOLT, Tsoil(1), NMBR_TCAV, mV200, TCAV_ANALOG_INPUT,    TypeE, T_cdm_volt_1, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
  #EndIf '(NMBR_TCAV <= 2)
  Move(TS_1_1_1, NMBR_TCAV, Tsoil(1), NMBR_TCAV)                          'To store the data in AmeriFlux standard  
    
   #If (SENSOR_HFP AND SENSOR_SWC) Then
     AvgRun (Tsoil_current(1), NMBR_TCAV, Tsoil(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

     For i_slow = 1 To NMBR_TCAV
       If (Tsoil_prev(i_slow) = NaN) Then                                 'As soon as program starts
         Tsoil_prev(i_slow) = Tsoil(i_slow)
       EndIf
     Next i_slow
    
  #EndIf
'*****               End of TCAV measurements                        *****
#EndIf '(SENSOR_TCAV) 


#If (SENSOR_CS65X) Then
'*****                CS65X measurements                             *****
  SDI12Recorder (cs65x_raw(1), CS65X_SDI_PORT, CS65SDI_ADR1, "M!", 1, 0, -1)
  cs65x_wc(1)   = cs65x_raw(1)                                      
  cs65x_ec(1)   = cs65x_raw(2)
  cs65x_tmpr(1) = cs65x_raw(3)
  #If (NMBR_CS65x > 1) Then
  SDI12Recorder (cs65x_raw(1), CS65X_SDI_PORT, CS65SDI_ADR2, "M!", 1, 0, -1)
  cs65x_wc(2)   = cs65x_raw(1)                                   
  cs65x_ec(2)   = cs65x_raw(2)
  cs65x_tmpr(2) = cs65x_raw(3)
  #EndIf
  #If (NMBR_CS65x > 2) Then
  SDI12Recorder (cs65x_raw(1), CS65X_SDI_PORT, CS65SDI_ADR3, "M!", 1, 0, -1)
  cs65x_wc(3)   = cs65x_raw(1)                                   
  cs65x_ec(3)   = cs65x_raw(2)
  cs65x_tmpr(3) = cs65x_raw(3)
  #EndIf
      
  'Soil temperature values measured from CS65X are used to report soil temperature if a TCAV sensor is not used  
  #If (SENSOR_CS65X AND (NOT SENSOR_TCAV)) Then
  Move (TS_1_1_1, NMBR_CS65x, cs65x_tmpr(1), NMBR_CS65x)
  #EndIf 
  
  'Correct volumetric soil moisture content using CS65x soil temperature  
  For i_slow = 1 To NMBR_CS65x
    'SWC_1_1_1 if NMBR_CS65x =1 and  SWC_1_1_1  and SWC_1_1_2 if NMBR_CS65x = 2  
    If ((cs65x_wc(i_slow) > 0.05) AND  (cs65x_wc(i_slow) <> NaN)) Then    
      SWC_array(i_slow) = cs65x_wc(i_slow)*(1.32 - 1.6*cs65x_wc(i_slow) + 2.4* cs65x_wc(i_slow)*cs65x_wc(i_slow)) _
                        + cs65x_tmpr(i_slow)*cs65x_wc(i_slow)*(0.0029 + 0.0014*cs65x_wc(i_slow) - 0.0044*cs65x_wc(i_slow)*cs65x_wc(i_slow)) _
                        - 0.0002*cs65x_tmpr(i_slow) - 0.046    'Page 22 in the manual for CS650 & CS655 Water Content Reflectometer (Revision 4/18)
    Else 
      SWC_array(i_slow) = cs65x_wc(i_slow)
    
    EndIf  

 Next i_slow 
'**************** End of CS65X measurements ******************************
#EndIf '(SENSOR_CS65X)
    

#If (SENSOR_TDR) Then
'*****                  TDR measurements                             *****
  SDI12Recorder (tdr_raw(1), TDR_SDI_PORT, TDRSDI_ADR1, "M!", 1, 0, -1)
  tdr_wc(1)     = tdr_raw(1)/100.0 'scale % --> v/v for calculations
  tdr_tmpr(1)   = tdr_raw(2)
  tdr_E(1)      = tdr_raw(3)
  tdr_bulkEC(1) = tdr_raw(4)/1000.0 'scale uS/cm --> dS/m
  tdr_poreEC(1) = tdr_raw(5)/1000.0
  #If (NMBR_CS65x > 1) Then
  SDI12Recorder (tdr_raw(1), TDR_SDI_PORT, TDRSDI_ADR2, "M!", 1, 0, -1)
  tdr_wc(2)     = tdr_raw(1)/100.0                                      
  tdr_tmpr(2)   = tdr_raw(2)
  tdr_E(2)      = tdr_raw(3)
  tdr_bulkEC(2) = tdr_raw(4)/1000.0
  tdr_poreEC(2) = tdr_raw(5)/1000.0
  #EndIf
  #If (NMBR_CS65x > 2) Then
  SDI12Recorder (tdr_raw(1), TDR_SDI_PORT, TDRSDI_ADR3, "M!", 1, 0, -1)
  tdr_wc(3)     = tdr_raw(1)/100.0                                      
  tdr_tmpr(3)   = tdr_raw(2)
  tdr_E(3)      = tdr_raw(3)
  tdr_bulkEC(3) = tdr_raw(4)/1000.0
  tdr_poreEC(3) = tdr_raw(5)/1000.0
  #EndIf
      
  'Soil temperature values measured from TDR are used to report soil temperature if a TCAV sensor is not used  
  #If (SENSOR_TDR AND (NOT SENSOR_TCAV)) Then
  Move (TS_1_1_1, NMBR_CS65x, tdr_tmpr(1), NMBR_CS65x)
  #EndIf 
  
  'Correct volumetric soil moisture content using TDR soil temperature  
  For i_slow = 1 To NMBR_CS65x
    'SWC_1_1_1 if NMBR_CS65x =1 and  SWC_1_1_1  and SWC_1_1_2 if NMBR_CS65x = 2  
    If ((tdr_wc(i_slow) > 0.05) AND  (tdr_wc(i_slow) <> NaN)) Then    
      SWC_array(i_slow) = tdr_wc(i_slow)*(1.32 - 1.6*tdr_wc(i_slow) + 2.4* tdr_wc(i_slow)*tdr_wc(i_slow)) _
                        + tdr_tmpr(i_slow)*tdr_wc(i_slow)*(0.0029 + 0.0014*tdr_wc(i_slow) - 0.0044*tdr_wc(i_slow)*tdr_wc(i_slow)) _
                        - 0.0002*tdr_tmpr(i_slow) - 0.046    'Section 8.3.5 Temperature dependence and correction, manual for CS650 & CS655 Water Content Reflectometer (Rev 11/2021)
    Else 
      SWC_array(i_slow) = tdr_wc(i_slow)
    
    EndIf  
  Next i_slow     
  '**************** End of TDR measurements ********************************
  #EndIf '(SENSOR_TDR)


#If (SENSOR_SWC) Then
'*****                  SWC measurements                             *****  
 #If (SENSOR_HFP) Then    
   AvgRun (soil_wtr_current(1), NMBR_CS65x, SWC_array(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)
    
    For i_slow = 1 To NMBR_CS65x
      If (soil_wtr_prev (i_slow) = NaN) Then
        soil_wtr_prev (i_slow) = SWC_array(i_slow)
      EndIf
    Next i_slow 

    #If (SENSOR_CS65X AND (NOT SENSOR_TCAV)) Then
       AvgRun (Tsoil_current(1), NMBR_CS65x, cs65x_tmpr(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

       For i_slow = 1 To NMBR_CS65x
         If (Tsoil_prev (i_slow) = NaN) Then                              'As soon as program starts
           Tsoil_prev(i_slow) = cs65x_tmpr(i_slow)
         EndIf
       Next  i_slow 
    #EndIf '(SENSOR_CS65X AND (NOT SENSOR_TCAV))
    #If (SENSOR_TDR AND (NOT SENSOR_TCAV)) Then
      AvgRun (Tsoil_current(1), NMBR_CS65x, tdr_tmpr(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

      For i_slow = 1 To NMBR_CS65x
        If (Tsoil_prev (i_slow) = NaN) Then                              'As soon as program starts
          Tsoil_prev(i_slow) = tdr_tmpr(i_slow)
        EndIf
      Next  i_slow 
    #EndIf '(SENSOR_TDR AND (NOT SENSOR_TCAV))
 #EndIf '(SENSOR_HFP) 
      
 'Convert volumetric fraction to percent 
  For i_slow = 1 To NMBR_CS65x
     SWC_array(i_slow) = 100*SWC_array(i_slow)                            'Conversion into percent for output 
  Next i_slow 
  '**************** End of SWC measurements ********************************
  #EndIf '(SENSOR_SWC)
    

#If (SENSOR_CS320 OR SENSOR_CS301) Then
#If (SENSOR_CS320) Then
'*****                Pyranometer measurements                       *****
  SDI12Recorder (SW_IN_CS320, CS320_SDI_PORT, CS320SDI_ADR, "C4!", 1, 0, -1)

  If (SW_IN_CS320 < 0) Then 
     SW_IN_CS320 = 0
  EndIf 
               
  SW_IN =SW_IN_CS320 
  
  'Turn off heater when the difference between T and TD is greater than setting threshold or power voltage is lower                
  #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then                 
  If ((Tc - T_DP >= CS320_HEATER_T_TD_THRSHLD) OR (V_batt_runng < 11)) Then   
  #Else 
  If ((T_probe - T_DP_Probe >= CS320_HEATER_T_TD_THRSHLD) OR (V_batt_runng < 11)) Then    
  #EndIf 
    If (CS320_heater_on_f) Then 
    SDI12Recorder(CS320_heater_set_dummy, CS320_SDI_PORT, CS320SDI_ADR, "XHOFF",  1, 0, -1)
    CS320_heater_on_f = FALSE
    EndIf 
  EndIf 
 
  'Turn on heater when the difference between T and TD is smaller than setting threshold while power voltage is adequate  
  #If (NOT (SENSOR_T_RH OR SENSOR_HYGRO)) Then   
  If ((Tc - T_DP < CS320_HEATER_T_TD_THRSHLD) AND (V_batt_runng > 11.5)) Then  
  #Else 
  If ((T_probe - T_DP_Probe < CS320_HEATER_T_TD_THRSHLD) AND (V_batt_runng > 11.5)) Then      
  #EndIf
   If (NOT CS320_heater_on_f) Then 
   SDI12Recorder(CS320_heater_set_dummy, CS320_SDI_PORT, CS320SDI_ADR, "XHON",  1, 0, -1)
   CS320_heater_on_f = TRUE
   EndIf 
 EndIf  
#EndIf '(SENSOR_CS320)

#If (SENSOR_CS301) Then
  CDM_VoltDiff (MODEL_CDMVLT, CPI_CDM_VOLT, SW_IN_pyran, 1, mV1000, PYRAN_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
  If SW_IN_pyran <=0 Then
     SW_IN = 0                                                       
  Else
     SW_IN =PYRAN_MULT*SW_IN_pyran                        
  EndIf
#EndIf '(SENSOR_CS301)
'**************  End of pyranometer measurements  ************************
#EndIf '(SENSOR_CS320 OR SENSOR_CS301) 

    
#If (SENSOR_CS310) Then
'*****                    CS310 measurements                         ***** 
 CDM_VoltDiff (MODEL_CDMVLT, CPI_CDM_VOLT, PPFD_IN, 1, mV200, QUANTUM_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
 If (PPFD_IN <= 0) Then
    PPFD_IN = 0
 Else
    PPFD_IN = QUNTM_MULT*PPFD_IN 
 EndIf
'********************* End of CS310 measurements *************************
#EndIf

      
#If (SENSOR_HYGRO) Then
  '*****         Temperature and humidity probe measurements           *****
  SDI12Recorder(T_probe,HYGRO_SDI_PORT, HYGROSDI_ADR, "R0!", 1, 0, -1) 
    
  'Saturation water pressure at current temperature
  Call H2O_vapor_dewpoint (T_probe, RH_probe, press_amb, e_sat_probe, e_probe, T_DP_Probe, H2O_density_probe, rho_d_probe) 
   
'**********  End of temperature and humidity probe measurements ***********
#EndIf '(SENSOR_HYGRO) 


#If (CDM_VOLT_116) Then 
#If (SENSOR_SI111) Then
'*****                      SI111 measurements                       *****
  CDM_Therm109 (MODEL_CDMVLT, CPI_CDM_VOLT, T_SI111_body, 1, 2*SI111_ANALOG_INPUT + 1, SI111_EXCITATION, 500, NTCH_FRQ_SLW, 1.0, 0)  'T_SI111_body in C
  m_SI111 = m0_SI111 + m1_SI111*T_SI111_body + m2_SI111*T_SI111_body*T_SI111_body                                   'parameter in target temp equation  
  b_SI111 = b0_SI111 + b1_SI111*T_SI111_body + b2_SI111*T_SI111_body*T_SI111_body                                   'parameter in target temp equation  

  CDM_VoltDiff (MODEL_CDMVLT, CPI_CDM_VOLT, T_CANOPY, 1, mV200, SI111_ANALOG_INPUT, TRUE, 500, NTCH_FRQ_SLW, 1, 0)
  T_CANOPY = ((T_SI111_body + T_0C_K)^4 + m_SI111*T_CANOPY + b_SI111)^0.25 - T_0C_K                                 'T_CANOPY in C
'********************** End of SI111 measurements ************************
#EndIf '(SENSOR_SI111)
#EndIf'(CDM_VOLT_116)


'*****                Time and geographic location                   *****                           
#If (SENSOR_GPS) Then 
 'Correct input values of latitude and longitude using GPS data 
  If (gps_ready > gps_ready_best) Then 
     latitude = latitude_GPS_degree + latitude_GPS_minute/60
     hemisphere_NS = SGN (latitude_GPS_degree)*1     
     longitude = longitude_GPS_degree + longitude_GPS_minute/60 
     hemisphere_EW = SGN (longitude_GPS_degree)*1
        
     altitude = altitude_GPS - height_GPS16X
      
     gps_ready_best = gps_ready
  EndIf
#EndIf '(SENSOR_GPS) 
    
 'Calculate solar position 
  RealTime(realtime_array(1))
    SolarPosition(solar_position_array(1), realtime_array(1), UTC_OFST*3600, latitude, longitude, altitude, 10*press_amb, T_amb)
    hour_angle      = 180.0*hour_angle/PI                                 'Radians to degrees 
    sun_declination = 180.0*sun_declination/PI                            'Radians to degrees
    
    If (sun_elevation > 0) Then 
       daytime = 1
       daytime_frac_scan_intv = SCAN_INTERVAL_WEIGHT
    Else
       daytime = 0
       daytime_frac_scan_intv = 0
    EndIf      
'*******************  Time and geographic location ************************


'*****                   SYSTEM POWER CONTROL                         *****
 If ((V_batt_runng < SYSTEM_PWR_OFF_SET_PT) AND (cnt_lwr_pwr_off_set_pt > (120000/SLW_SCN_INTV)) AND _
    (IfTime(0, 2*SLW_SCN_INTV, mSec)) AND (irga_off_bit <> &h000100) AND (irga_startup_bit <> &h000004)) Then
    
   irga_pwr_switch_f      = TRUE
   irga_pwr_array(1, 2)   = PWR_OFF    'Turn IRGA off.
   irga_pwr_array(2, 2)   = H_OFF      'Turn heater off.
   cnt_lwr_pwr_off_set_pt = 0

   prev_value_str = "Batt volt >" & SYSTEM_PWR_OFF_SET_PT & " V"
   curr_value_str = "Batt volt =" & V_batt_runng & " V"
   message        = "IRGA auto-off: low volt."
 
 ElseIf ((V_batt_runng > SYSTEM_PWR_OFF_SET_PT + SYSTEM_PWR_DEAD_BAND_WIDTH) AND _
         (secs_snc_pwr_swtch > 100) AND (irga_vlt_low_auto_off) AND (irga_user_set_pwr_on)) Then
         
   irga_pwr_switch_f    = TRUE
   irga_pwr_array(1, 2) = PWR_ON          'Turn IRGA on.
   irga_pwr_array(2, 2) = heater_user     'Turn heater on.

   prev_value_str = "Batt volt <" & SYSTEM_PWR_OFF_SET_PT & " V"
   curr_value_str = "Batt volt =" & V_batt_runng & " V"
   message = "IRGA auto-on: volt resumed."
   
 EndIf '((volt_batt < SYSTEM_PWR_OFF_SET_PT)......
'*******************  END OF SYSTEM POWER CONTROL  ************************
  

'*****  Updating files of station variables and planar fit angles    *****
'*** Determine whether or not the planar fit is used. It is used as long as one planar fit angle is not zero.
For i_slow = 1 To NMBR_STN_VAR
      
 If (stn_conf_array_prev(i_slow) <> stn_conf_array(i_slow)) Then
           
   Select Case i_slow
     'Update the pointing direction of CSAT
     Case 1
       If ((sonic_azimuth < 0.0) OR (sonic_azimuth > 360.0)) Then 
         sonic_azimuth = stn_conf_array_prev(1)                           'Set back to previous value 
       EndIf           
   
     'Update geo-coordinates
     Case 2        
       If (ABS(latitude) > 90.0) Then  
         latitude = stn_conf_array_prev(2)                                'Set back to previous value 
       EndIf 
        
     Case 3
      If ((hemisphere_NS <> NORTH) AND (hemisphere_NS <> SOUTH)) Then 
         hemisphere_NS = stn_conf_array_prev(3) 
      EndIf 

      If (hemisphere_NS = NORTH) Then
        latitude = ABS(latitude)
      Else
        latitude = - ABS(latitude)
      EndIf
        
     Case 4
      If (ABS(longitude) > 180.0) Then  
        longitude = stn_conf_array_prev(4)                                'Set back to previous value 
      EndIf
         
      Case 5
         If ((hemisphere_EW <> EAST) AND (hemisphere_EW <> WEST)) Then 
           hemisphere_EW = stn_conf_array_prev(5) 
         EndIf         
        
        If (hemisphere_EW = EAST) Then
          longitude = ABS(longitude)
        Else
          longitude = -ABS(longitude)
        EndIf
        
      Case 6         
       If ((altitude > 8000.0) OR (altitude < -1000.0))  Then  
         altitude = stn_conf_array_prev(6)                                'Set back to previous value 
       EndIf
         
      'Update Aerodynamic height (z)
      Case 7, 8, 9, 10, 11
        If ((height_measurement > 250.0) OR (height_measurement < 0.2)) Then 
           height_measurement = stn_conf_array_prev(7)                    'Set back to  previous value
        EndIf 
        
        If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND ((height_measurement > 100 OR height_measurement < 0.2))) Then 
          height_measurement = stn_conf_array_prev(7)                     'Set back to previous value
        EndIf 
        
        If ((surface_type = FOREST) AND ((height_measurement > 250.0) OR (height_measurement < 0.2))) Then 
          height_measurement = stn_conf_array_prev(7)                     'Set back to previous value
        EndIf  
        
        If ((surface_type < CROP) OR (surface_type > ICE)) Then   
          surface_type = stn_conf_array_prev(8) 
        EndIf   

        If ((surface_type = BARELAND) OR (surface_type = WATER) OR (surface_type = ICE)) Then 
           height_canopy = 0                                              'Set back to default value
        EndIf
 
        If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND (height_canopy > 15)) Then 
          height_canopy = stn_conf_array_prev(9)                          'Set back to previous value
        EndIf  

        If ((surface_type = FOREST ) AND (height_canopy > 100.0)) Then 
          height_canopy = stn_conf_array_prev(9)                          'Set back to previous value
        EndIf  
  
        If (displacement_user > height_measurement) OR (displacement_user < 0.0) Then  
           displacement_user = stn_conf_array_prev(10) 
        EndIf
  
        If (roughness_user > height_measurement) OR (roughness_user < 0.0) Then  
           roughness_user = stn_conf_array_prev(11) 
        EndIf

        Call Displacement_roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
        surface_type_text = surface_type_array(surface_type)
     
        For j_slow = 14 To 17
          If (stn_conf_array(j_slow) = 100.0*z_prev) Then           
              stn_conf_array(j_slow) = 100.0*z                            'Default value of 100*z for all sectors in different directions
          EndIf 
        Next j_slow
        
        z_prev = z
                     
      Case 12, 13
       
        If (IRGASON) Then
          separation_x_irga = 0.0                                         'Coordinate x of IRGASON IRGA measurement center in the CSAT coordinate system
          separation_y_irga = 0.0                                         'Coordinate y of IRGASON IRGA measurement center in the CSAT coordinate system
        EndIf
  
        If (NOT IRGASON) Then
           If ((separation_x_irga < 0.04066) OR (separation_x_irga > 0.09126)) Then 
            separation_x_irga = stn_conf_array_prev(12)                   'Set back to previous value                                
           EndIf 
           If ((separation_y_irga < 0.02905) OR (separation_y_irga > 0.03348)) Then 
            separation_y_irga = stn_conf_array_prev(13)                   'Set back to previous value  
           EndIf
         EndIf
         
       Case 14, 15, 16, 17
         If ((stn_conf_array (i_slow) > 5000) OR (stn_conf_array (i_slow) < 0)) Then 
           stn_conf_array (i_slow) = stn_conf_array_prev (i_slow)         'Set back to previous value  
         EndIf
         
    EndSelect 'i_slow
    
    #If (SENSOR_GPS) Then 
       If (height_GPS16X > height_measurement + 10) OR (height_GPS16X < 0) Then
         height_GPS16X = stn_conf_array_prev (18)                         'Set back to previous value  
       EndIf   
    #EndIf 

    #If (SENSOR_FW) Then
      If ((separation_y_FW > 0.1) OR (separation_y_FW < 0)) Then 
         Select Case IRGASON
           Case True        
             separation_y_FW = 0.03259                                    'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
                   
           Case False
             separation_y_FW = -0.02306                                   'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
         EndSelect 'IRGASON
      EndIf '((separation_y_FW > 0.1) OR (separation_y_FW < 0))  
       
      If ((separation_x_FW > 0.30) OR (separation_x_FW < 0)) Then 
         separation_x_FW = stn_conf_array_prev (18 - 1*SENSOR_GPS)        'Set back to previous value 
       EndIf 
       If ((FW_diameter <> FW05DIA) AND (FW_diameter <> FW1_DIA) AND (FW_diameter <> FW2_DIA) AND (FW_diameter <> FW3_DIA)) Then   
             FW_diameter = stn_conf_array_prev (20 - 1*SENSOR_GPS)        'Set back to previous value 
       EndIf        
    #EndIf '(SENSOR_FW)
  
    #If (SENSOR_HFP AND SENSOR_SWC)) Then
      If (soil_bulk_density > 1800.0) OR (soil_bulk_density <600.0) Then 
         soil_bulk_density = stn_conf_array_prev (18 - 1*SENSOR_GPS -3*SENSOR_FW) 'Set back to previous value 
      EndIf 
      If (Cds < 400.0) OR (Cds > 1500.0) Then  
         Cds = stn_conf_array_prev (19 - 1*SENSOR_GPS -3*SENSOR_FW)                'Set back to previous value 
      EndIf 
      If (thick_abv_SHFP > 0.30) OR (thick_abv_SHFP < 0.0) Then 
         thick_abv_SHFP = stn_conf_array_prev (20 - 1*SENSOR_GPS -3*SENSOR_FW)     'Set back to previous value 
      EndIf 
    #EndIf '(SENSOR_HFP AND SENSOR_SWC))

      Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:stn_conf_array.dat", 0)       'Store the new values to the file.
      Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR) 'Update stn_conf_array_prev()
      ExitFor

 EndIf '(stn_conf_array_prev(i_slow) <> stn_conf_array(i_slow)) 

 If (i_slow <= 4) Then
   For j_slow = 1 To 4

    If (planar_fit_angle_conf_array_prev (j_slow, 1) <> planar_fit_angle_conf_array (j_slow, 1)) _
       OR (planar_fit_angle_conf_array_prev (j_slow, 2) <> planar_fit_angle_conf_array (j_slow, 2)) Then

        If ((ABS(planar_fit_angle_conf_array (j_slow, 1)) > 30) OR (ABS(planar_fit_angle_conf_array (j_slow, 2)) > 30)) Then   
            Move (planar_fit_angle_conf_array(j_slow, 1), 2, planar_fit_angle_conf_array_prev(j_slow, 1), 2) 'Set back to previous value    
        
        Else
            Calfile (planar_fit_angle_conf_array (1,1),8,"CPU:planar_fit_angle_conf_array.dat",0)             'Store the new values to the file.

            'Keep current values of planar_fit_angle_conf_array() in planar_fit_angle_prev_array() for later use as previous values
            Move (planar_fit_angle_conf_array_prev(j_slow, 1), 2, planar_fit_angle_conf_array(j_slow, 1), 2)

        EndIf       

        Planar_Fit_flg = FALSE
        For k_slow = 1 To 4
          If (planar_fit_angle_conf_array (k_slow, 1) <> 0) OR (planar_fit_angle_conf_array (k_slow, 2) <> 0) Then
            Planar_Fit_flg = TRUE
            ExitFor
          EndIf
        Next k_slow
        
      ExitFor
      
    EndIf '(planar_fit_angle_conf_array_prev (j_slow, 1)............
   Next j_slow

 EndIf '(i_slow <= 4)

Next i_slow
'*** End of updating files of station variables and planar fit angles ***


'*****      Estimate the days of MicroSD for more data storage       *****    
 If (card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") Then
  '1000 converts mSecond to Second, 24 hours/day, and 3600 seconds/hour
   card_storage_available_days = card_storage_available_days - (SLW_SCN_INTV/1000)/(24*3600)
     
  '*** Time_Series files 
  'Normal computation 
   days_actv_tbl_Time_Series = days_actv_tbl_Time_Series - (SLW_SCN_INTV/1000)/(24*3600)
   days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series
     
  'Computation immediately after file normal closing
   If ((LastFileName_Time_Series <> LastFileName_Time_Series_prev) AND (realtime_array(4)= 0)) Then
      card_bytes_free           = Status.CardBytesFree                                 'in bytes. 
      card_bytes_free_assgnd    = card_bytes_free_assgnd    - bytes_tbl_Time_Series
      days_actv_tbl_Time_Series = DAY_TSRS_CRD 
      days_more_tbl_Time_Series = days_more_tbl_Time_Series - DAY_TSRS_CRD
      days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series
        
      LastFileName_Time_Series_prev = LastFileName_Time_Series    
   EndIf
         
   '*** Flux files 
    'Normal computation      
    #If (ONE_FL_TABLE) Then 
    days_actv_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat - (SLW_SCN_INTV/1000)/(24*3600)     
    days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat + days_more_tbl_flux_CSFormat   
    #Else 
    days_actv_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes - (SLW_SCN_INTV/1000)/(24*3600)    
    days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes
    #EndIf
       
    'Computation immediately after file normal closing
    If ((LastFileName_flux_CSFormat <> LastFileName_flux_CSFormat_prev) AND (realtime_array(4) = 0)) Then 
      card_bytes_free           = Status.CardBytesFree                                  'in bytes. 
      card_bytes_free_assgnd    = card_bytes_free_assgnd - bytes_tbl_flux_CSFormat - bytes_tbl_AmeriFluxFormat 

      #If (ONE_FL_TABLE) Then 
      days_actv_tbl_flux_CSFormat = DAY_FLUX_CRD     
      days_more_tbl_flux_CSFormat = days_more_tbl_flux_CSFormat - DAY_FLUX_CRD
      days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat + days_more_tbl_flux_CSFormat  
    
      #Else 
      days_actv_tbl_flux_CSFormat_notes = DAY_FLUX_CRD
      days_more_tbl_flux_CSFormat_notes = days_more_tbl_flux_CSFormat_notes - DAY_FlUX_CRD
      days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes
      #EndIf 
      
      LastFileName_flux_CSFormat_prev = LastFileName_flux_CSFormat

    EndIf '((LastFileName_flux_CSFormat <> LastFileName_flux_CSFormat_prev) AND (realtime_array(4) = 0))      

 Else 
    days_actv_tbl_Time_Series          = NaN
    days_more_tbl_Time_Series          = NaN
    days_totl_tbl_Time_Series          = NaN
     
   #If (ONE_FL_TABLE) Then 
      days_actv_tbl_flux_CSFormat       = NaN    
      days_more_tbl_flux_CSFormat       = NaN   
      days_totl_tbl_flux_CSFormat       = NaN   
   #Else 
      days_actv_tbl_flux_CSFormat_notes = NaN  
      days_more_tbl_flux_CSFormat_notes = NaN
      days_totl_tbl_flux_CSFormat_notes = NaN
   #EndIf 
      card_storage_available_days       = NaN 
      
 EndIf '(card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.")
 
   
 'Computation immediately after MicroSD is replaced 
 If ((card_storage_available_days = NaN) AND (Status.CardStatus = "Card OK.")) Then

  're-estimate card_storage_available_days 
  card_bytes_free = Status.CardBytesFree                                  'in bytes. 

  If (card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") Then

    day_snc_0101_1990 = SecsSince1990(status.TimeStamp(1,1), 1)/(24*3600)
            
    days_actv_tbl_Time_Series = DAY_TSRS_CRD - (day_snc_0101_1990 MOD DAY_TSRS_CRD)  

   'Pre-set, assume no extra storage in MicroSD
    days_totl_tbl_Time_Series = days_actv_tbl_Time_Series 
  
    #If (ONE_FL_TABLE) Then 
       
    days_actv_tbl_flux_CSFormat = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD) 
     
    'Pre-set, assume no extra storage in MicroSD     
    days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat 
    
    'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat uses. 
    'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.    
    card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat 
    
    #Else 
     days_actv_tbl_flux_CSFormat_notes = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD)

    'Pre-set, assume no extra storage in MicroSD
     days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes
    
    'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat and Flux_Notes uses. 
    'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.   
     card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat_notes/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat  

    #EndIf '(ONE_FL_TABLE) 
     
    card_bytes_free_unassgnd   = card_bytes_free - card_bytes_free_assgnd 
    days_more_tbl_Time_Series = 0                                         'Reset after MicroSD abnormal including the replacement of MicroSD

    #If (ONE_FL_TABLE) Then
      days_more_tbl_flux_CSFormat = 0                                     'Reset after MicroSD abnormal including the replacement of MicroSD 
      
     While (((days_totl_tbl_flux_CSFormat >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR _
           ((days_totl_tbl_flux_CSFormat < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat))))      

       If (days_totl_tbl_flux_CSFormat >= days_totl_tbl_Time_Series) Then
          card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series 
          days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
          days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series    
        
       Else 
          card_bytes_free_assgnd      = card_bytes_free_assgnd      + bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat 
          days_more_tbl_flux_CSFormat = days_more_tbl_flux_CSFormat + DAY_FLUX_CRD
          days_totl_tbl_flux_CSFormat = days_actv_tbl_flux_CSFormat + days_more_tbl_flux_CSFormat    

        EndIf '(days_totl_tbl_flux_CSFormat >= days_totl_tbl_Time_Series)
        
         card_bytes_free_unassgnd  = card_bytes_free - card_bytes_free_assgnd  
 
     Wend 
    
        If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat) Then 
          card_storage_available_days = days_totl_tbl_flux_CSFormat
        Else
          card_storage_available_days = days_totl_tbl_Time_Series
        EndIf  

   #Else
     
     days_more_tbl_flux_CSFormat_notes = 0                               'Reset after MicroSD abnormal including the replacement of MicroSD 
    
     While (((days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR _
            ((days_totl_tbl_flux_CSFormat_notes < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat + bytes_tbl_flux_notes))))      

       If (days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) Then
          card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series 
          days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
          days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series   
        
       Else 
          card_bytes_free_assgnd            = card_bytes_free_assgnd + bytes_tbl_flux_CSFormat + bytes_tbl_AmeriFluxFormat + bytes_tbl_flux_notes 
          days_more_tbl_flux_CSFormat_notes = days_more_tbl_flux_CSFormat_notes + DAY_FLUX_CRD
          days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes   

       EndIf 
      
       card_bytes_free_unassgnd  = card_bytes_free - card_bytes_free_assgnd          

     Wend 

        If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat_notes) Then 
          card_storage_available_days = days_totl_tbl_flux_CSFormat_notes
        Else
          card_storage_available_days = days_totl_tbl_Time_Series
        EndIf  

  #EndIf '(ONE_FL_TABLE) 
        LastFileName_Time_Series_prev   = LastFileName_Time_Series
        LastFileName_flux_CSFormat_prev = LastFileName_flux_CSFormat  
          

 Else
     days_actv_tbl_Time_Series          = NaN
     days_more_tbl_Time_Series          = NaN
     days_totl_tbl_Time_Series          = NaN
     
   #If (ONE_FL_TABLE) Then 
      days_actv_tbl_flux_CSFormat       = NaN    
      days_more_tbl_flux_CSFormat       = NaN   
      days_totl_tbl_flux_CSFormat       = NaN   
   #Else 
      days_actv_tbl_flux_CSFormat_notes = NaN  
      days_more_tbl_flux_CSFormat_notes = NaN
      days_totl_tbl_flux_CSFormat_notes = NaN
   #EndIf 

      card_storage_available_days       = NaN 
         
 EndIf '(card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") 
     
 EndIf '((card_storage_available_days = NaN) AND (Status.CardStatus = "Card OK."))  
'*** End of Checking how many days left for data storage in MicroSD **** 

    slowsequence_finished_f = TRUE
    
NextScan 'SLW_SCN_INTV
EndProg
'*************************************************************************
